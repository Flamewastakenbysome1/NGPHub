<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>NGP Hub — Audio Remix (Beta)</title>

<link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500;700&display=swap" rel="stylesheet" />
<link rel="icon" href="/assets/ngp-logo.png" type="image/png">
<style>
  :root{
    --bg:#0e0e11; --card:#15151b; --ink:#ececf1; --muted:#b5b7c3;
    --brandA:#6a11cb; --brandB:#2575fc; --line:#3a66ff;
    --ring:0 0 0 .2rem rgba(37,117,252,.35);
    --radius:16px; --shadow:0 10px 30px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:linear-gradient(180deg,#0b0b0e,#121219 60%,#0d0d14);
    color:var(--ink); font-family:'Rubik',system-ui,-apple-system,Segoe UI,Roboto,Arial,Helvetica,sans-serif;
    -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility; scroll-behavior:smooth;
  }
  .wrap{max-width:1024px; margin:0 auto; padding:0 16px}

  header{position:sticky; top:0; z-index:50; backdrop-filter:saturate(140%) blur(10px);
    background:rgba(10,10,14,.6); border-bottom:1px solid rgba(255,255,255,.06)}
  .bar{display:flex; align-items:center; justify-content:space-between; padding:12px 0}
  .logo{display:flex; align-items:center; gap:10px; text-decoration:none; color:var(--ink)}
  .logo-mark{width:28px; height:28px; border-radius:10px; background:linear-gradient(135deg,var(--brandA),var(--brandB)); box-shadow:var(--shadow)}
  .logo-img{width:28px; height:28px; border-radius:10px; object-fit:contain; box-shadow:var(--shadow)}
  .logo h1{font-size:1.05rem; margin:0; letter-spacing:.3px}
  nav{display:flex; align-items:center; gap:6px; flex-wrap:wrap}
  nav a{color:var(--ink); text-decoration:none; font-weight:500; padding:8px 10px; border-radius:10px; opacity:.9}
  nav a:hover, nav a:focus-visible{background:rgba(255,255,255,.06); outline:none; box-shadow:var(--ring)}

  footer{border-top:1px solid rgba(255,255,255,.08); color:var(--muted); padding:24px 0 36px; text-align:center}

  main{padding:28px 0 40px}
  .grid{display:grid; grid-template-columns:320px 1fr; gap:24px}
  .panel{background:var(--card); border:1px solid rgba(255,255,255,.06); border-radius:var(--radius); box-shadow:var(--shadow); overflow:hidden}
  .panel h2{margin:0; padding:14px 16px; border-bottom:1px solid rgba(255,255,255,.06); font-size:1rem}
  .list{max-height:420px; overflow:auto}
  .fileRow{display:flex; align-items:center; justify-content:space-between; gap:8px; padding:12px 14px; border-bottom:1px solid rgba(255,255,255,.05)}
  .fileRow.muted{color:var(--muted)}
  .fileTitle{font-weight:600}
  .fileMeta{color:var(--muted); font-size:.85rem}
  .controls{padding:16px}
  .knob{margin:14px 0}
  .knob label{display:flex; align-items:center; justify-content:space-between; font-weight:600; margin-bottom:8px}
  .knob small{color:var(--muted); margin-left:8px; font-weight:400}
  input[type="range"]{width:100%}
  .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .btn{background:linear-gradient(135deg,var(--brandA),var(--brandB)); color:#fff; border:none; border-radius:12px; padding:10px 14px; font-weight:700; cursor:pointer; box-shadow:var(--shadow)}
  .btn:disabled{opacity:.5; cursor:not-allowed}
  .btnGhost{background:transparent; color:var(--ink); border:1px solid rgba(255,255,255,.2); border-radius:12px; padding:9px 12px; font-weight:600; cursor:pointer}
  .pill{background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12); padding:6px 10px; border-radius:999px; user-select:none; cursor:pointer}
  
  .wave-container{position:relative; height:140px}
  .wave{height:140px; background:repeating-linear-gradient(90deg,rgba(255,255,255,.06) 0 1px, transparent 1px 4px), radial-gradient(ellipse at center, rgba(106,17,203,.2), transparent 60%); position:relative}
  .progress-indicator{position:absolute; top:0; bottom:0; width:2px; background:var(--brandB); z-index:10; transform:translateX(-50%); opacity:.8; box-shadow: 0 0 8px rgba(37,117,252,.6)}
  
  .timeline{display:flex; justify-content:space-between; font-size:.85rem; color:var(--muted); padding:6px 10px 0}
  .playerBar{position:sticky; bottom:0; left:0; right:0; background:rgba(10,10,14,.8); backdrop-filter:saturate(140%) blur(10px); border-top:1px solid rgba(255,255,255,.08)}
  .playerInner{max-width:1024px; margin:0 auto; padding:10px 16px; display:flex; align-items:center; gap:10px}
  .play{width:42px; height:42px; border-radius:999px; display:grid; place-items:center; border:1px solid rgba(255,255,255,.25); background:rgba(255,255,255,.06); cursor:pointer}
  .time{min-width:64px; text-align:center; font-variant-numeric:tabular-nums}
  .grow{flex:1}
  .muted{color:var(--muted)}
  .tag{font-size:.75rem; padding:3px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.18); color:#cbd5ff; cursor:pointer}
  .unlockWrap{display:none; align-items:center; gap:8px}
  .unlockWrap label{font-size:.85rem; color:var(--muted)}

  /* Floating Gain (outside) */
  .gainFloat{
    position:fixed; right:10px; top:140px; z-index:60; display:flex; flex-direction:column; align-items:center; gap:6px;
    padding:10px 8px; border-radius:14px; background:rgba(21,21,27,.85); border:1px solid rgba(255,255,255,.09); box-shadow:var(--shadow);
    backdrop-filter: blur(8px) saturate(140%);
  }
  .gainFloat .cap{font-size:.7rem; color:var(--muted)}
  .gainFloat input[type="range"]{
    writing-mode: bt-lr; -webkit-appearance: slider-vertical; appearance: slider-vertical;
    width: 44px; height: 260px;
  }
  .gainBadge{font-size:.75rem; padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.2); background:rgba(255,255,255,.06)}

  /* Disclaimer */
  .disclaimer{
    background:rgba(255,69,0,.1); border:1px solid rgba(255,69,0,.3); border-radius:12px; padding:12px;
    margin:16px 0; color:#ffb3b3; font-size:.85rem; line-height:1.4;
  }
  .disclaimer strong{color:#ff6b6b}

  /* Progress bar styling */
  .progress-bar{
    width:100%; height:4px; background:rgba(255,255,255,.1); border-radius:2px; margin:8px 0;
  }
  .progress-fill{
    height:100%; background:linear-gradient(90deg,var(--brandA),var(--brandB)); border-radius:2px;
    transition:width .1s ease; width:0%;
  }

  @media (max-width:920px){ .grid{grid-template-columns:1fr} .gainFloat{display:none} }
  @media (prefers-reduced-motion: reduce){*{transition:none !important; animation:none !important}}
</style>
</head>
<body>
<header>
  <div class="wrap bar">
    <a class="logo" href="/">
      <img src="/assets/ngp-logo.png" alt="NGP Logo" class="logo-img" />
      <h1>NGP</h1>
    </a>
    <nav aria-label="Primary">
      <a href="/tools">Tools</a><a href="/discordservers/">Servers</a><a href="/projects">Projects</a>
      <a href="/docs/">Docs</a><a href="/roblox">Roblox</a><a href="/contact">Contact</a>
    </nav>
  </div>
</header>

<main>
  <div class="wrap">
    <!-- Disclaimer -->
    <div class="disclaimer">
      <strong>⚠️ Disclaimer:</strong> NGP is not responsible for any injuries, hearing damage, or other harm that may occur from using this audio remix tool. Please use reasonable volume levels and take breaks when using audio equipment. Use at your own risk.
    </div>

    <div class="row" style="margin-bottom:6px; justify-content:space-between;">
      <div class="row">
        <button id="addBtn" class="btnGhost">+ Add file</button>
        <button id="clearBtn" class="btnGhost">✕ Clear</button>
      </div>

      <div style="display:flex; flex-direction:column; align-items:flex-end; gap:6px">
        <div class="unlockWrap" id="unlockWrap">
          <input type="checkbox" id="unlockBox" />
          <label for="unlockBox">Extra range</label>
        </div>
        <span class="tag" id="freeTag">No need to pay, straight from the browser!</span>
      </div>
    </div>

    <div class="grid">
      <!-- Files -->
      <section class="panel" aria-label="Files">
        <h2>Files</h2>
        <div class="list" id="fileList">
          <div class="fileRow muted">No file yet. Click "Add file".</div>
        </div>
      </section>

      <!-- Editor -->
      <section class="panel" aria-label="Editor">
        <h2 id="currentName">—</h2>
        <div class="wave-container">
          <div class="wave" id="wave"></div>
          <div class="progress-indicator" id="progressIndicator" style="left:0%"></div>
        </div>
        <div class="timeline"><span id="tStart">0:00</span><span id="tEnd">0:00</span></div>

        <div class="controls">
          <div class="row" style="gap:12px;">
            <span class="pill">Presets</span>
            <button class="btnGhost" data-preset="slowed">Slowed+Reverb</button>
            <button class="btnGhost" data-preset="nightcore">Nightcore</button>
            <button class="btnGhost" data-preset="perfection">Slowed to Perfection</button>
          </div>

          <div class="knob">
            <label>Speed <small id="speedLbl">(1.00×)</small></label>
            <input type="range" id="speed" min="0.5" max="1.5" step="0.01" value="1.0" />
            <div class="row" style="margin-top:6px;">
              <input type="checkbox" id="preserve" />
              <label for="preserve" class="muted">Keep original pitch when changing speed</label>
            </div>
          </div>

          <div class="knob">
            <label>Pitch <small id="pitchLbl">(0 semitones)</small></label>
            <input type="range" id="pitch" min="-12" max="12" step="0.1" value="0" />
            <div class="row" style="margin-top:4px;">
              <small class="muted">Note: Pitch changes only apply to downloaded files, not live preview</small>
            </div>
          </div>

          <div class="knob">
            <label>Reverb <small id="reverbLbl">(0%)</small></label>
            <input type="range" id="reverb" min="0" max="100" step="1" value="0" />
          </div>

          <div class="knob">
            <label>Bass boost <small id="bassLbl">(0 dB)</small></label>
            <input type="range" id="bass" min="0" max="18" step="1" value="0" />
          </div>

          <div class="knob">
            <label>Muffle <small id="muffleLbl">(0%)</small></label>
            <input type="range" id="muffle" min="0" max="100" step="1" value="0" />
          </div>

          <div class="knob">
            <label>Echo <small id="echoLbl">(0%)</small></label>
            <input type="range" id="echo" min="0" max="100" step="1" value="0" />
          </div>

          <div class="row" style="margin-top:10px">
            <button id="downloadBtn" class="btn" disabled>Download Remix</button>
            <button id="trimBtn" class="btnGhost" disabled>Export selection</button>
            <span class="muted" id="status">Ready</span>
          </div>
          
          <div class="progress-bar" id="renderProgress" style="display:none">
            <div class="progress-fill" id="renderProgressFill"></div>
          </div>
        </div>
      </section>
    </div>
  </div>
</main>

<!-- Floating Gain -->
<aside class="gainFloat" aria-label="Output Gain">
  <span class="cap">+24</span>
  <input type="range" id="gainSlider" min="-24" max="24" step="1" value="0" aria-label="Gain (dB)" />
  <span class="cap">-24</span>
  <span class="gainBadge" id="gainLbl">Gain 0 dB</span>
</aside>

<div class="playerBar">
  <div class="playerInner">
    <button class="play" id="playBtn" aria-label="Play/Pause">▶</button>
    <div class="time" id="curTime">0:00</div>
    <input class="grow" type="range" id="seek" min="0" max="1" step="0.0001" value="0" />
    <div class="time" id="durTime">0:00</div>
  </div>
</div>

<footer>
  <div class="wrap"><small>© <span id="year"></span> NGP</small></div>
</footer>

<input type="file" id="fileInput" accept="audio/*" hidden />

<script>
try {
  // Set year
  document.getElementById('year').textContent = new Date().getFullYear();
  
  // Get elements
  const     elements = {
    addBtn: document.getElementById('addBtn'),
    clearBtn: document.getElementById('clearBtn'),
    fileInput: document.getElementById('fileInput'),
    fileList: document.getElementById('fileList'),
    playBtn: document.getElementById('playBtn'),
    seek: document.getElementById('seek'),
    curTime: document.getElementById('curTime'),
    durTime: document.getElementById('durTime'),
    tStart: document.getElementById('tStart'),
    tEnd: document.getElementById('tEnd'),
    wave: document.getElementById('wave'),
    status: document.getElementById('status'),
    downloadBtn: document.getElementById('downloadBtn'),
    trimBtn: document.getElementById('trimBtn'),
    speed: document.getElementById('speed'),
    reverb: document.getElementById('reverb'),
    bass: document.getElementById('bass'),
    pitch: document.getElementById('pitch'),
    speedLbl: document.getElementById('speedLbl'),
    reverbLbl: document.getElementById('reverbLbl'),
    bassLbl: document.getElementById('bassLbl'),
    pitchLbl: document.getElementById('pitchLbl'),
    muffle: document.getElementById('muffle'),
    muffleLbl: document.getElementById('muffleLbl'),
    echo: document.getElementById('echo'),
    echoLbl: document.getElementById('echoLbl'),
    preserve: document.getElementById('preserve'),
    currentName: document.getElementById('currentName'),
    gainSlider: document.getElementById('gainSlider'),
    gainLbl: document.getElementById('gainLbl'),
    freeTag: document.getElementById('freeTag'),
    unlockWrap: document.getElementById('unlockWrap'),
    unlockBox: document.getElementById('unlockBox'),
    progressIndicator: document.getElementById('progressIndicator'),
    renderProgress: document.getElementById('renderProgress'),
    renderProgressFill: document.getElementById('renderProgressFill')
  };

  // Audio setup
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();
  let audioBuffer = null;
  let sourceNode = null;
  let isPlaying = false;
  let currentTime = 0;
  let startOffset = 0;
  let lastPlayTime = 0;
  let animationFrame = null;

  // Audio nodes
  const nodes = {
    muffle: audioContext.createBiquadFilter(),
    convolver: audioContext.createConvolver(),
    bass: audioContext.createBiquadFilter(),
    dryGain: audioContext.createGain(),
    delay: audioContext.createDelay(2.0),
    feedback: audioContext.createGain(),
    echoWet: audioContext.createGain(),
    master: audioContext.createGain()
  };

  // Setup audio nodes
  nodes.muffle.type = 'lowpass';
  nodes.muffle.frequency.value = 20000;
  nodes.muffle.Q.value = 0.7;
  nodes.bass.type = 'lowshelf';
  nodes.bass.frequency.value = 140;
  nodes.dryGain.gain.value = 1;
  nodes.feedback.gain.value = 0;
  nodes.echoWet.gain.value = 0;
  nodes.master.gain.value = 1;

  // Connect audio graph
  nodes.delay.connect(nodes.feedback);
  nodes.feedback.connect(nodes.delay);
  nodes.muffle.connect(nodes.convolver);
  nodes.convolver.connect(nodes.bass);
  nodes.bass.connect(nodes.dryGain);
  nodes.bass.connect(nodes.delay);
  nodes.delay.connect(nodes.echoWet);
  nodes.dryGain.connect(nodes.master);
  nodes.echoWet.connect(nodes.master);
  nodes.master.connect(audioContext.destination);

  // Helper functions
  function formatTime(seconds) {
    const mins = Math.floor(Math.max(0, seconds) / 60);
    const secs = Math.floor(Math.max(0, seconds) % 60);
    return mins + ':' + secs.toString().padStart(2, '0');
  }

  function dbToLinear(db) {
    return Math.pow(10, db / 20);
  }

  function setStatus(text) {
    elements.status.textContent = text;
  }

  function updateProgressIndicator() {
    if (!audioBuffer) return;
    const progress = currentTime / audioBuffer.duration;
    elements.progressIndicator.style.left = Math.min(100, Math.max(0, progress * 100)) + '%';
  }

  function createImpulseResponse(seconds, decay) {
    seconds = seconds || 1.5;
    decay = decay || 2.5;
    const sampleRate = audioContext.sampleRate;
    const length = Math.max(1, Math.floor(seconds * sampleRate));
    const impulse = audioContext.createBuffer(2, length, sampleRate);
    
    // Create a very short, almost dry impulse for default (no reverb)
    if (seconds < 0.01) {
      for (let channel = 0; channel < 2; channel++) {
        const channelData = impulse.getChannelData(channel);
        channelData[0] = 1; // Single impulse for dry signal
      }
    } else {
      for (let channel = 0; channel < 2; channel++) {
        const channelData = impulse.getChannelData(channel);
        for (let i = 0; i < length; i++) {
          const n = length - i;
          channelData[i] = (Math.random() * 2 - 1) * Math.pow(n / length, decay);
        }
      }
    }
    return impulse;
  }

  // Initialize reverb with proper dry signal
  nodes.convolver.buffer = createImpulseResponse(0.001, 0.1);

  function createAudioSource() {
    if (!audioBuffer) return;
    
    if (sourceNode) {
      try { sourceNode.stop(); } catch (e) {}
      sourceNode.disconnect();
    }
    
    sourceNode = audioContext.createBufferSource();
    sourceNode.buffer = audioBuffer;
    
    const speedMultiplier = parseFloat(elements.speed.value);
    const pitchSemitones = parseFloat(elements.pitch.value);
    const pitchMultiplier = Math.pow(2, pitchSemitones / 12);
    
    if (elements.preserve.checked) {
      // When preserving pitch, only apply speed change
      sourceNode.playbackRate.value = speedMultiplier;
    } else {
      // When not preserving, apply both speed and pitch
      sourceNode.playbackRate.value = speedMultiplier * pitchMultiplier;
    }
    
    sourceNode.connect(nodes.muffle);
    
    sourceNode.onended = function() {
      if (isPlaying) {
        isPlaying = false;
        elements.playBtn.textContent = '▶';
        if (animationFrame) {
          cancelAnimationFrame(animationFrame);
          animationFrame = null;
        }
      }
    };
  }

  // File handling
  elements.addBtn.onclick = function() {
    elements.fileInput.click();
  };

  elements.fileInput.onchange = async function(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    setStatus('Loading file...');
    
    try {
      const arrayBuffer = await file.arrayBuffer();
      audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
      
      // Initialize all effects properly
      updateMuffleFilter();
      updateEchoEffect();
      updateGain();
      
      createAudioSource();
      elements.currentName.textContent = file.name;
      drawWaveform(audioBuffer);
      
      elements.tStart.textContent = '0:00';
      elements.tEnd.textContent = formatTime(audioBuffer.duration);
      elements.durTime.textContent = formatTime(audioBuffer.duration);
      
      elements.seek.value = 0;
      elements.seek.max = audioBuffer.duration;
      currentTime = 0;
      updateProgressIndicator();
      
      const fileInfo = elements.speed.value + '× speed, ' + elements.pitch.value + ' semitones, ' + 
                      elements.reverb.value + '% reverb, ' + elements.bass.value + ' dB bass, ' + 
                      elements.muffle.value + '% muffle, ' + elements.echo.value + '% echo';
      elements.fileList.innerHTML = '<div class="fileRow"><div><div class="fileTitle">' + file.name + 
                                   '</div><div class="fileMeta">' + fileInfo + '</div></div><div>♪</div></div>';
      
      elements.downloadBtn.disabled = false;
      elements.trimBtn.disabled = false;
      setStatus('Ready');
      
    } catch (error) {
      console.error('Error loading file:', error);
      setStatus('Failed to load file');
    }
  };

  elements.clearBtn.onclick = function() {
    if (sourceNode) {
      try { sourceNode.stop(); } catch (e) {}
      sourceNode.disconnect();
    }
    
    sourceNode = null;
    audioBuffer = null;
    isPlaying = false;
    currentTime = 0;
    
    elements.fileList.innerHTML = '<div class="fileRow muted">No file yet. Click "Add file".</div>';
    elements.currentName.textContent = '—';
    
    const canvas = elements.wave.querySelector('canvas');
    if (canvas) {
      const ctx2d = canvas.getContext('2d');
      ctx2d.clearRect(0, 0, canvas.width, canvas.height);
    }
    
    elements.seek.value = 0;
    elements.durTime.textContent = '0:00';
    elements.tEnd.textContent = '0:00';
    elements.curTime.textContent = '0:00';
    elements.playBtn.textContent = '▶';
    elements.downloadBtn.disabled = true;
    updateProgressIndicator();
    
    if (animationFrame) {
      cancelAnimationFrame(animationFrame);
      animationFrame = null;
    }
    
    setStatus('Cleared');
  };

  // Waveform drawing
  function drawWaveform(buffer) {
    let canvas = elements.wave.querySelector('canvas');
    if (!canvas) {
      canvas = document.createElement('canvas');
      elements.wave.appendChild(canvas);
    }
    
    const rect = elements.wave.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    
    const ctx2d = canvas.getContext('2d');
    ctx2d.clearRect(0, 0, canvas.width, canvas.height);
    
    if (!buffer) return;
    
    const channelData = buffer.getChannelData(0);
    const samples = channelData.length;
    const step = Math.max(1, Math.floor(samples / canvas.width));
    const midHeight = canvas.height / 2;
    
    ctx2d.fillStyle = 'rgba(255, 255, 255, 0.8)';
    
    for (let x = 0; x < canvas.width; x++) {
      let min = 1;
      let max = -1;
      
      const start = x * step;
      const end = Math.min(start + step, samples);
      
      for (let i = start; i < end; i++) {
        const sample = channelData[i];
        if (sample < min) min = sample;
        if (sample > max) max = sample;
      }
      
      const height = Math.max(1, (max - min) * midHeight);
      const y = midHeight + min * midHeight;
      
      ctx2d.fillRect(x, y, 1, height);
    }
  }

  // Playback controls
  function getCurrentPlaybackTime() {
    if (!audioBuffer) return 0;
    if (!isPlaying) return currentTime;
    
    const elapsed = (audioContext.currentTime - lastPlayTime) * sourceNode.playbackRate.value;
    return Math.min(audioBuffer.duration, startOffset + elapsed);
  }

  function updateTimeDisplay() {
    if (!audioBuffer) return;
    
    currentTime = getCurrentPlaybackTime();
    elements.curTime.textContent = formatTime(currentTime);
    elements.seek.value = currentTime;
    updateProgressIndicator();
    
    if (isPlaying && currentTime < audioBuffer.duration) {
      animationFrame = requestAnimationFrame(updateTimeDisplay);
    }
  }

  elements.playBtn.onclick = function() {
    if (!audioBuffer) return;
    
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }
    
    if (!isPlaying) {
      createAudioSource();
      startOffset = currentTime;
      sourceNode.start(0, startOffset);
      lastPlayTime = audioContext.currentTime;
      isPlaying = true;
      elements.playBtn.textContent = '⏸';
      updateTimeDisplay();
    } else {
      try { sourceNode.stop(); } catch (e) {}
      currentTime = getCurrentPlaybackTime();
      isPlaying = false;
      elements.playBtn.textContent = '▶';
      if (animationFrame) {
        cancelAnimationFrame(animationFrame);
        animationFrame = null;
      }
    }
  };

  // Seek control
  elements.seek.oninput = function() {
    if (!audioBuffer) return;
    currentTime = parseFloat(elements.seek.value);
    elements.curTime.textContent = formatTime(currentTime);
    updateProgressIndicator();
  };

  elements.seek.onchange = function() {
    if (!audioBuffer) return;
    
    currentTime = parseFloat(elements.seek.value);
    
    if (isPlaying) {
      try { sourceNode.stop(); } catch (e) {}
      
      createAudioSource();
      startOffset = currentTime;
      sourceNode.start(0, startOffset);
      lastPlayTime = audioContext.currentTime;
    }
  };

  // Effect controls
  function updateMuffleFilter() {
    const muffleValue = parseInt(elements.muffle.value);
    const isUnlocked = elements.unlockBox && elements.unlockBox.checked;
    const maxFreq = 20000;
    const minFreq = isUnlocked ? 60 : 300;
    const range = Math.max(0, Math.min(isUnlocked ? 2 : 1, muffleValue / 100));
    
    const frequency = maxFreq * Math.pow(minFreq / maxFreq, range);
    nodes.muffle.frequency.value = Math.max(60, frequency);
    elements.muffleLbl.textContent = '(' + muffleValue + '%)';
  }

  function updateEchoEffect() {
    const echoValue = parseInt(elements.echo.value);
    const isUnlocked = elements.unlockBox && elements.unlockBox.checked;
    const range = Math.max(0, Math.min(isUnlocked ? 2 : 1, echoValue / 100));
    
    const delayTime = 0.08 + (isUnlocked ? 1.2 : 0.42) * range;
    const feedback = Math.min(0.95, (isUnlocked ? 0.95 : 0.85) * range);
    const wetLevel = Math.min(1.2, (isUnlocked ? 1.2 : 0.8) * range);
    
    nodes.delay.delayTime.value = Math.min(2.0, delayTime);
    nodes.feedback.gain.value = feedback;
    nodes.echoWet.gain.value = wetLevel;
    elements.echoLbl.textContent = '(' + echoValue + '%)';
  }

  elements.speed.oninput = function() {
    const speedValue = parseFloat(elements.speed.value);
    elements.speedLbl.textContent = '(' + speedValue.toFixed(2) + '×)';
    if (sourceNode) {
      const pitchSemitones = parseFloat(elements.pitch.value);
      const pitchMultiplier = Math.pow(2, pitchSemitones / 12);
      
      if (elements.preserve.checked) {
        sourceNode.playbackRate.value = speedValue;
      } else {
        sourceNode.playbackRate.value = speedValue * pitchMultiplier;
      }
    }
  };

  elements.pitch.oninput = function() {
    const pitchValue = parseFloat(elements.pitch.value);
    const roundedPitch = Math.round(pitchValue * 10) / 10;
    elements.pitchLbl.textContent = '(' + (roundedPitch >= 0 ? '+' : '') + roundedPitch + ' semitones)';
    
    // Pitch slider ONLY affects final download, not live playback
    // This is because Web Audio API cannot do independent pitch shifting in real-time
    if (sourceNode) {
      const speedMultiplier = parseFloat(elements.speed.value);
      // Always use only speed for live playback
      sourceNode.playbackRate.value = speedMultiplier;
    }
  };

  elements.preserve.onchange = function() {
    if (sourceNode) {
      const speedMultiplier = parseFloat(elements.speed.value);
      const pitchSemitones = parseFloat(elements.pitch.value);
      const pitchMultiplier = Math.pow(2, pitchSemitones / 12);
      
      if (elements.preserve.checked) {
        sourceNode.playbackRate.value = speedMultiplier;
      } else {
        sourceNode.playbackRate.value = speedMultiplier * pitchMultiplier;
      }
    }
  };

  elements.reverb.oninput = function() {
    const reverbValue = parseInt(elements.reverb.value);
    elements.reverbLbl.textContent = '(' + reverbValue + '%)';
    const reverbAmount = Math.max(0.001, reverbValue / 100);
    nodes.convolver.buffer = createImpulseResponse(1.8 * reverbAmount + 0.05, 3 * reverbAmount + 0.5);
  };

  elements.bass.oninput = function() {
    const bassValue = parseInt(elements.bass.value);
    elements.bassLbl.textContent = '(' + bassValue + ' dB)';
    nodes.bass.gain.value = bassValue;
  };

  elements.muffle.oninput = updateMuffleFilter;
  elements.echo.oninput = updateEchoEffect;

  function updateGain() {
    const gainValue = parseInt(elements.gainSlider.value);
    nodes.master.gain.value = dbToLinear(gainValue);
    elements.gainLbl.textContent = 'Gain ' + (gainValue >= 0 ? '+' : '') + gainValue + ' dB';
  }
  
  elements.gainSlider.oninput = updateGain;

  // Initialize effects
  updateMuffleFilter();
  updateEchoEffect();
  updateGain();

  // Presets
  document.querySelectorAll('[data-preset]').forEach(function(button) {
    button.onclick = function() {
      const preset = button.dataset.preset;
      
      if (preset === 'slowed') {
        elements.speed.value = 0.70;
        elements.pitch.value = 0;
        elements.reverb.value = 45;
        elements.bass.value = 2;
        elements.muffle.value = 10;
        elements.echo.value = 10;
        elements.preserve.checked = true;
      } else if (preset === 'nightcore') {
        elements.speed.value = 1.25;
        elements.pitch.value = 2;
        elements.reverb.value = 0;
        elements.bass.value = 0;
        elements.muffle.value = 0;
        elements.echo.value = 0;
        elements.preserve.checked = false;
      } else if (preset === 'perfection') {
        elements.speed.value = 0.83;
        elements.pitch.value = -1;
        elements.reverb.value = 26;
        elements.bass.value = 10;
        elements.muffle.value = 12;
        elements.echo.value = 8;
        elements.preserve.checked = true;
      }
      
      // Trigger all updates
      elements.speed.oninput();
      elements.pitch.oninput();
      elements.reverb.oninput();
      elements.bass.oninput();
      updateMuffleFilter();
      updateEchoEffect();
    };
  });

  // Download functionality - full version
  elements.downloadBtn.onclick = async function() {
    if (!audioBuffer) return;
    
    elements.downloadBtn.disabled = true;
    elements.renderProgress.style.display = 'block';
    setStatus('Preparing render...');
    
    try {
      const params = {
        speed: parseFloat(elements.speed.value),
        pitch: parseFloat(elements.pitch.value),
        reverb: parseInt(elements.reverb.value),
        bass: parseInt(elements.bass.value),
        muffle: parseInt(elements.muffle.value),
        echo: parseInt(elements.echo.value),
        gain: parseInt(elements.gainSlider.value),
        preservePitch: elements.preserve.checked,
        isUnlocked: elements.unlockBox && elements.unlockBox.checked
      };
      
      const renderedBuffer = params.preservePitch 
        ? await renderWithTimeStretching(audioBuffer, params)
        : await renderWithResampling(audioBuffer, params);
      
      setStatus('Creating download...');
      elements.renderProgressFill.style.width = '90%';
      
      const wavBlob = audioBufferToWav(renderedBuffer);
      const url = URL.createObjectURL(wavBlob);
      
      const filename = (elements.currentName.textContent || 'audio').replace(/\.[^.]+$/, '') + '_ngp-remix.wav';
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.style.display = 'none';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      URL.revokeObjectURL(url);
      
      elements.renderProgressFill.style.width = '100%';
      setStatus('Download complete!');
      
      setTimeout(function() {
        elements.renderProgress.style.display = 'none';
        elements.renderProgressFill.style.width = '0%';
        setStatus('Ready');
      }, 2000);
      
    } catch (error) {
      console.error('Render error:', error);
      setStatus('Render failed: ' + error.message);
      elements.renderProgress.style.display = 'none';
      elements.renderProgressFill.style.width = '0%';
    } finally {
      elements.downloadBtn.disabled = false;
    }
  };

  // Export selection functionality
  elements.trimBtn.onclick = function() {
    if (!audioBuffer) return;
    setStatus('Export selection coming soon - will allow you to trim and export specific parts of the audio!');
  };

  // Rendering functions
  async function renderWithResampling(buffer, params) {
    setStatus('Rendering (resampling)...');
    elements.renderProgressFill.style.width = '20%';
    
    const channels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    
    // Calculate playback rate based on speed and pitch
    const pitchMultiplier = Math.pow(2, params.pitch / 12);
    const finalPlaybackRate = params.preservePitch ? params.speed : params.speed * pitchMultiplier;
    
    const outputLength = Math.max(1, Math.floor(buffer.length / finalPlaybackRate));
    
    const offlineCtx = new OfflineAudioContext(channels, outputLength, sampleRate);
    
    // Create source
    const source = offlineCtx.createBufferSource();
    source.buffer = buffer;
    source.playbackRate.value = finalPlaybackRate;
    
    elements.renderProgressFill.style.width = '40%';
    
    // Create effects chain
    const muffle = offlineCtx.createBiquadFilter();
    muffle.type = 'lowpass';
    muffle.Q.value = 0.7;
    const maxFreq = 20000;
    const minFreq = params.isUnlocked ? 60 : 300;
    const muffleRange = Math.max(0, Math.min(params.isUnlocked ? 2 : 1, params.muffle / 100));
    muffle.frequency.value = Math.max(60, maxFreq * Math.pow(minFreq / maxFreq, muffleRange));
    
    const conv = offlineCtx.createConvolver();
    const reverbAmount = Math.max(0.001, params.reverb / 100);
    conv.buffer = createOfflineImpulseResponse(offlineCtx, 1.8 * reverbAmount + 0.05, 3 * reverbAmount + 0.5);
    
    const bassEQ = offlineCtx.createBiquadFilter();
    bassEQ.type = 'lowshelf';
    bassEQ.frequency.value = 140;
    bassEQ.gain.value = params.bass;
    
    const dryGain = offlineCtx.createGain();
    dryGain.gain.value = 1;
    
    // Echo
    const delay = offlineCtx.createDelay(2.0);
    const feedback = offlineCtx.createGain();
    const echoWet = offlineCtx.createGain();
    
    const echoRange = Math.max(0, Math.min(params.isUnlocked ? 2 : 1, params.echo / 100));
    const delayTime = 0.08 + (params.isUnlocked ? 1.2 : 0.42) * echoRange;
    const feedbackAmount = Math.min(0.95, (params.isUnlocked ? 0.95 : 0.85) * echoRange);
    const wetLevel = Math.min(1.2, (params.isUnlocked ? 1.2 : 0.8) * echoRange);
    
    delay.delayTime.value = Math.min(2.0, delayTime);
    feedback.gain.value = feedbackAmount;
    echoWet.gain.value = wetLevel;
    
    const master = offlineCtx.createGain();
    master.gain.value = dbToLinear(params.gain);
    
    elements.renderProgressFill.style.width = '60%';
    
    // Connect graph conditionally
    let currentNode = source;
    
    // Only apply muffle if > 0
    if (params.muffle > 0) {
      currentNode.connect(muffle);
      currentNode = muffle;
    }
    
    // Only apply reverb if > 0
    if (params.reverb > 0) {
      currentNode.connect(conv);
      currentNode = conv;
    }
    
    // Connect to bass EQ
    currentNode.connect(bassEQ);
    
    // Bass and dry path
    bassEQ.connect(dryGain);
    dryGain.connect(master);
    
    // Only apply echo if > 0
    if (params.echo > 0) {
      bassEQ.connect(delay);
      delay.connect(feedback);
      feedback.connect(delay);
      delay.connect(echoWet);
      echoWet.connect(master);
    }
    
    master.connect(offlineCtx.destination);
    
    source.start(0);
    
    elements.renderProgressFill.style.width = '80%';
    return await offlineCtx.startRendering();
  }

  async function renderWithTimeStretching(buffer, params) {
    setStatus('Rendering (time-stretch)...');
    elements.renderProgressFill.style.width = '10%';
    
    // When preserving pitch, we need to handle speed and pitch separately
    const channels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const inputLength = buffer.length;
    
    // First apply speed change with time-stretching to preserve pitch
    const speedStretchedLength = Math.max(1, Math.floor(inputLength / params.speed));
    
    const frameSize = Math.max(512, Math.floor(0.05 * sampleRate));
    const hopInput = Math.floor(frameSize * 0.25);
    const hopOutput = Math.max(1, Math.floor(hopInput / params.speed));
    
    const window = createHannWindow(frameSize);
    
    elements.renderProgressFill.style.width = '20%';
    
    // Time-stretch each channel
    const stretchedChannels = [];
    for (let c = 0; c < channels; c++) {
      const inputData = buffer.getChannelData(c);
      const outputData = new Float32Array(speedStretchedLength);
      
      let inputPos = 0;
      let outputPos = 0;
      
      while (inputPos + frameSize < inputLength && outputPos + frameSize < speedStretchedLength) {
        for (let i = 0; i < frameSize; i++) {
          if (outputPos + i < speedStretchedLength) {
            outputData[outputPos + i] += inputData[inputPos + i] * window[i];
          }
        }
        inputPos += hopInput;
        outputPos += hopOutput;
      }
      
      stretchedChannels.push(outputData);
    }
    
    elements.renderProgressFill.style.width = '40%';
    
    // Create buffer with time-stretched audio
    const stretchedBuffer = audioContext.createBuffer(channels, speedStretchedLength, sampleRate);
    for (let c = 0; c < channels; c++) {
      stretchedBuffer.getChannelData(c).set(stretchedChannels[c]);
    }
    
    elements.renderProgressFill.style.width = '50%';
    
    // Now apply pitch shift and effects using offline context
    const pitchMultiplier = Math.pow(2, params.pitch / 12);
    const finalLength = Math.max(1, Math.floor(speedStretchedLength / pitchMultiplier));
    
    const offlineCtx = new OfflineAudioContext(channels, finalLength, sampleRate);
    const source = offlineCtx.createBufferSource();
    source.buffer = stretchedBuffer;
    source.playbackRate.value = pitchMultiplier; // Apply pitch shift
    
    // Apply effects
    const muffle = offlineCtx.createBiquadFilter();
    muffle.type = 'lowpass';
    muffle.Q.value = 0.7;
    const maxFreq = 20000;
    const minFreq = params.isUnlocked ? 60 : 300;
    const muffleRange = Math.max(0, Math.min(params.isUnlocked ? 2 : 1, params.muffle / 100));
    muffle.frequency.value = Math.max(60, maxFreq * Math.pow(minFreq / maxFreq, muffleRange));
    
    const conv = offlineCtx.createConvolver();
    const reverbAmount = Math.max(0.001, params.reverb / 100);
    conv.buffer = createOfflineImpulseResponse(offlineCtx, 1.8 * reverbAmount + 0.05, 3 * reverbAmount + 0.5);
    
    const bassEQ = offlineCtx.createBiquadFilter();
    bassEQ.type = 'lowshelf';
    bassEQ.frequency.value = 140;
    bassEQ.gain.value = params.bass;
    
    const dryGain = offlineCtx.createGain();
    const delay = offlineCtx.createDelay(2.0);
    const feedback = offlineCtx.createGain();
    const echoWet = offlineCtx.createGain();
    
    const echoRange = Math.max(0, Math.min(params.isUnlocked ? 2 : 1, params.echo / 100));
    delay.delayTime.value = Math.min(2.0, 0.08 + (params.isUnlocked ? 1.2 : 0.42) * echoRange);
    feedback.gain.value = Math.min(0.95, (params.isUnlocked ? 0.95 : 0.85) * echoRange);
    echoWet.gain.value = Math.min(1.2, (params.isUnlocked ? 1.2 : 0.8) * echoRange);
    
    const master = offlineCtx.createGain();
    master.gain.value = dbToLinear(params.gain);
    
    elements.renderProgressFill.style.width = '70%';
    
    // Connect conditionally
    let currentNode = source;
    
    // Only apply muffle if > 0
    if (params.muffle > 0) {
      currentNode.connect(muffle);
      currentNode = muffle;
    }
    
    // Only apply reverb if > 0
    if (params.reverb > 0) {
      currentNode.connect(conv);
      currentNode = conv;
    }
    
    // Connect to bass EQ
    currentNode.connect(bassEQ);
    
    // Bass and dry path
    bassEQ.connect(dryGain);
    dryGain.connect(master);
    
    // Only apply echo if > 0
    if (params.echo > 0) {
      bassEQ.connect(delay);
      delay.connect(feedback);
      feedback.connect(delay);
      delay.connect(echoWet);
      echoWet.connect(master);
    }
    
    master.connect(offlineCtx.destination);
    
    source.start(0);
    
    elements.renderProgressFill.style.width = '90%';
    return await offlineCtx.startRendering();
  }

  function createHannWindow(size) {
    const window = new Float32Array(size);
    for (let i = 0; i < size; i++) {
      window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (size - 1)));
    }
    return window;
  }

  function createOfflineImpulseResponse(offlineCtx, seconds, decay) {
    seconds = seconds || 1.5;
    decay = decay || 2.5;
    const sampleRate = offlineCtx.sampleRate;
    const length = Math.max(1, Math.floor(seconds * sampleRate));
    const impulse = offlineCtx.createBuffer(2, length, sampleRate);
    
    for (let channel = 0; channel < 2; channel++) {
      const channelData = impulse.getChannelData(channel);
      for (let i = 0; i < length; i++) {
        const n = length - i;
        channelData[i] = (Math.random() * 2 - 1) * Math.pow(n / length, decay);
      }
    }
    return impulse;
  }

  // WAV export function
  function audioBufferToWav(buffer) {
    const length = buffer.length;
    const channels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    
    const arrayBuffer = new ArrayBuffer(44 + length * channels * 2);
    const view = new DataView(arrayBuffer);
    
    // WAV header
    function writeString(offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }
    
    writeString(0, 'RIFF');
    view.setUint32(4, 36 + length * channels * 2, true);
    writeString(8, 'WAVE');
    writeString(12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, channels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * channels * 2, true);
    view.setUint16(32, channels * 2, true);
    view.setUint16(34, 16, true);
    writeString(36, 'data');
    view.setUint32(40, length * channels * 2, true);
    
    // Convert float samples to 16-bit PCM
    const channelData = [];
    for (let c = 0; c < channels; c++) {
      channelData.push(buffer.getChannelData(c));
    }
    
    let offset = 44;
    for (let i = 0; i < length; i++) {
      for (let c = 0; c < channels; c++) {
        const sample = Math.max(-1, Math.min(1, channelData[c][i]));
        const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
        view.setInt16(offset, intSample, true);
        offset += 2;
      }
    }
    
    return new Blob([arrayBuffer], { type: 'audio/wav' });
  }

  // Secret unlock
  let secretClicks = 0;
  elements.freeTag.addEventListener('click', function() {
    secretClicks++;
    if (secretClicks >= 15) {
      elements.unlockWrap.style.display = 'flex';
      elements.freeTag.textContent = 'Extra features unlocked!';
      elements.freeTag.style.background = 'rgba(106,17,203,.2)';
    }
  });

  function setUnlockedRanges(unlocked) {
    if (unlocked) {
      elements.speed.min = '0.05';
      elements.speed.max = '4';
      elements.speed.step = '0.001';
      elements.pitch.min = '-24';
      elements.pitch.max = '24';
      elements.pitch.step = '0.05';
      elements.reverb.max = '300';
      elements.bass.min = '-24';
      elements.bass.max = '48';
      elements.gainSlider.min = '-48';
      elements.gainSlider.max = '48';
      elements.muffle.max = '200';
      elements.echo.max = '200';
    } else {
      elements.speed.min = '0.5';
      elements.speed.max = '1.5';
      elements.speed.step = '0.01';
      elements.pitch.min = '-12';
      elements.pitch.max = '12';
      elements.pitch.step = '0.1';
      elements.reverb.max = '100';
      elements.bass.min = '0';
      elements.bass.max = '18';
      elements.gainSlider.min = '-24';
      elements.gainSlider.max = '24';
      elements.muffle.max = '100';
      elements.echo.max = '100';
    }
    updateMuffleFilter();
    updateEchoEffect();
  }

  elements.unlockBox.addEventListener('change', function(e) {
    setUnlockedRanges(e.target.checked);
  });

  setUnlockedRanges(false);

  // Window resize handler for waveform
  new ResizeObserver(function() {
    drawWaveform(audioBuffer);
  }).observe(elements.wave);

  console.log('Audio Remix Tool initialized successfully!');

} catch (error) {
  console.error('Error initializing audio tool:', error);
  document.getElementById('status').textContent = 'Error: ' + error.message;
}
</script>
</body>
</html>
