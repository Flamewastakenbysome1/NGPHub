<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>NGP Hub ‚Äî Audio Editor (1.7)</title>

<link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500;700&display=swap" rel="stylesheet" />
<link rel="icon" href="/assets/ngp-logo.png" type="image/png">
<script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
<style>
  :root{
    --bg:#0e0e11; --card:#15151b; --ink:#ececf1; --muted:#b5b7c3;
    --brandA:#6a11cb; --brandB:#2575fc; --line:#3a66ff;
    --ring:0 0 0 .2rem rgba(37,117,252,.35);
    --radius:16px; --shadow:0 10px 30px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:linear-gradient(180deg,#0b0b0e,#121219 60%,#0d0d14);
    background-attachment:fixed;
    color:var(--ink); font-family:'Rubik',system-ui,-apple-system,Segoe UI,Roboto,Arial,Helvetica,sans-serif;
    -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility; scroll-behavior:smooth;
  }
  .wrap{max-width:1024px; margin:0 auto; padding:0 16px}

  header{position:sticky; top:0; z-index:50; backdrop-filter:saturate(140%) blur(10px);
    background:rgba(10,10,14,.6); border-bottom:1px solid rgba(255,255,255,.06)}
  .bar{display:flex; align-items:center; justify-content:space-between; padding:12px 0}
  .logo{display:flex; align-items:center; gap:10px; text-decoration:none; color:var(--ink)}
  .logo-mark{width:28px; height:28px; border-radius:10px; background:linear-gradient(135deg,var(--brandA),var(--brandB)); box-shadow:var(--shadow)}
  .logo-img{width:28px; height:28px; border-radius:10px; object-fit:contain; box-shadow:var(--shadow)}
  .logo h1{font-size:1.05rem; margin:0; letter-spacing:.3px}
  nav{display:flex; align-items:center; gap:6px; flex-wrap:wrap}
  nav a{color:var(--ink); text-decoration:none; font-weight:500; padding:8px 10px; border-radius:10px; opacity:.9}
  nav a:hover, nav a:focus-visible{background:rgba(255,255,255,.06); outline:none; box-shadow:var(--ring)}

  footer{border-top:1px solid rgba(255,255,255,.08); color:var(--muted); padding:24px 0 36px; text-align:center}

  main{padding:28px 0 40px}
  .grid{display:grid; grid-template-columns:320px 1fr; gap:24px}
  .panel{background:var(--card); border:1px solid rgba(255,255,255,.06); border-radius:var(--radius); box-shadow:var(--shadow); overflow:hidden}
  .panel h2{margin:0; padding:14px 16px; border-bottom:1px solid rgba(255,255,255,.06); font-size:1rem}
  .list{max-height:420px; overflow:auto}
  .fileRow{display:flex; align-items:center; justify-content:space-between; gap:8px; padding:12px 14px; border-bottom:1px solid rgba(255,255,255,.05)}
  .fileRow.muted{color:var(--muted)}
  .fileTitle{font-weight:600}
  .fileMeta{color:var(--muted); font-size:.85rem}
  .controls{padding:16px}
  .knob{margin:14px 0}
  .knob label{display:flex; align-items:center; justify-content:space-between; font-weight:600; margin-bottom:8px}
  .knob small{color:var(--muted); margin-left:8px; font-weight:400}
  input[type="range"]{width:100%}
  .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .btn{background:linear-gradient(135deg,var(--brandA),var(--brandB)); color:#fff; border:none; border-radius:12px; padding:10px 14px; font-weight:700; cursor:pointer; box-shadow:var(--shadow)}
  .btn:disabled{opacity:.5; cursor:not-allowed}
  .btnGhost{background:transparent; color:var(--ink); border:1px solid rgba(255,255,255,.2); border-radius:12px; padding:9px 12px; font-weight:600; cursor:pointer}
  .pill{background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12); padding:6px 10px; border-radius:999px; user-select:none; cursor:pointer}
  
  .wave-container{position:relative; height:140px}
  .wave{height:140px; background:repeating-linear-gradient(90deg,rgba(255,255,255,.06) 0 1px, transparent 1px 4px), radial-gradient(ellipse at center, rgba(106,17,203,.2), transparent 60%); position:relative}
  .progress-indicator{position:absolute; top:0; bottom:0; width:2px; background:var(--brandB); z-index:10; transform:translateX(-50%); opacity:.8; box-shadow: 0 0 8px rgba(37,117,252,.6)}
  
  .timeline{display:flex; justify-content:space-between; font-size:.85rem; color:var(--muted); padding:6px 10px 0}
  .playerBar{position:sticky; bottom:0; left:0; right:0; background:rgba(10,10,14,.8); backdrop-filter:saturate(140%) blur(10px); border-top:1px solid rgba(255,255,255,.08)}
  .playerInner{max-width:1024px; margin:0 auto; padding:10px 16px; display:flex; align-items:center; gap:10px}
  .play{width:42px; height:42px; border-radius:999px; display:grid; place-items:center; border:1px solid rgba(255,255,255,.25); background:rgba(255,255,255,.06); cursor:pointer}
  .time{min-width:64px; text-align:center; font-variant-numeric:tabular-nums}
  .grow{flex:1}
  .muted{color:var(--muted)}
  .tag{font-size:.75rem; padding:3px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.18); color:#cbd5ff; cursor:pointer}
  .unlockWrap{display:none; align-items:center; gap:8px}
  .unlockWrap label{font-size:.85rem; color:var(--muted)}

  /* Floating Gain (outside) */
  .gainFloat{
    position:fixed; right:10px; top:140px; z-index:60; display:flex; flex-direction:column; align-items:center; gap:6px;
    padding:10px 8px; border-radius:14px; background:rgba(21,21,27,.85); border:1px solid rgba(255,255,255,.09); box-shadow:var(--shadow);
    backdrop-filter: blur(8px) saturate(140%);
  }
  .gainFloat .cap{font-size:.7rem; color:var(--muted)}
  .gainFloat input[type="range"]{
    writing-mode: bt-lr; -webkit-appearance: slider-vertical; appearance: slider-vertical;
    width: 44px; height: 260px;
  }
  .gainBadge{font-size:.75rem; padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.2); background:rgba(255,255,255,.06)}

  /* Disclaimer and Note to self */
  .disclaimer{
    background:rgba(255,69,0,.1); border:1px solid rgba(255,69,0,.3); border-radius:12px; padding:12px;
    margin:16px 0; color:#ffe4e4; font-size:.85rem; line-height:1.4;
  }
  .disclaimer strong{color:#ff6b8c}

  .notetoself{
    background:rgba(0, 255, 136, 0.1); border:1px solid rgba(0, 255, 157, 0.3); border-radius:12px; padding:12px;
    margin:16px 0; color:#ebffde; font-size:.85rem; line-height:1.4;
  }
  .notetoself strong{color:#a5ffa1}

  /* Preset manager */
  .presetManager{margin:16px 0; padding:14px; background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.08); border-radius:12px}
  .presetManager h3{margin:0 0 10px; font-size:.9rem; color:var(--muted)}
  .presetList{display:flex; flex-wrap:wrap; gap:6px; margin:8px 0}
  .presetItem{display:flex; align-items:center; gap:4px; padding:4px 8px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); border-radius:8px; font-size:.85rem}
  .presetItem button{background:transparent; border:none; color:var(--muted); cursor:pointer; padding:2px 4px; font-size:.75rem}
  .presetItem button:hover{color:#ff6b6b}
  .presetActions{display:flex; gap:6px; margin-top:8px; flex-wrap:wrap}
  select{background:var(--card); color:var(--ink); border:1px solid rgba(255,255,255,.2); border-radius:8px; padding:8px 10px; font-family:inherit; cursor:pointer}

  /* Progress bar styling */
  .progress-bar{
    width:100%; height:4px; background:rgba(255,255,255,.1); border-radius:2px; margin:8px 0;
  }
  .progress-fill{
    height:100%; background:linear-gradient(90deg,var(--brandA),var(--brandB)); border-radius:2px;
    transition:width .1s ease; width:0%;
  }

  /* Queue inside Files panel */
  .queueList{overflow:auto}
  .queueRow{display:flex; align-items:center; gap:8px; padding:10px 14px; cursor:pointer; transition:background .15s}
  .queueRow:hover{background:rgba(255,255,255,.04)}
  .queueRow.active{background:rgba(37,117,252,.15); border-left:3px solid var(--brandB)}
  .queueRow.active .queueName{color:#fff}
  .queueIdx{min-width:22px; color:var(--muted); font-size:.8rem; text-align:center}
  .queueName{flex:1; font-weight:600; font-size:.9rem; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
  .queueDur{color:var(--muted); font-size:.82rem; min-width:42px; text-align:right}
  .queueDel{background:transparent; border:none; color:var(--muted); cursor:pointer; padding:2px 6px; border-radius:6px; font-size:.85rem}
  .queueDel:hover{color:#ff6b6b; background:rgba(255,107,107,.1)}
  .queueEmpty{padding:16px; color:var(--muted); font-size:.875rem; text-align:center}
  /* Prev/Next in player bar */
  .play.small{width:34px; height:34px; font-size:.8rem}

  @media (max-width:920px){ .grid{grid-template-columns:1fr} .gainFloat{display:none} }
  @media (prefers-reduced-motion: reduce){*{transition:none !important; animation:none !important}}
</style>
</head>
<body>
<header>
  <div class="wrap bar">
    <a class="logo" href="/">
      <img src="/assets/ngp-logo.png" alt="NGP Logo" class="logo-img" />
      <h1>NGP</h1>
    </a>
    <nav aria-label="Primary">
      <a href="/tools">Tools</a><a href="/discordservers/">Servers</a><a href="/projects">Projects</a>
      <a href="/docs/">Docs</a><a href="/roblox">Roblox</a><a href="/contact">Contact</a>
    </nav>
  </div>
</header>

<main>
  <div class="wrap">
    <!-- Disclaimer -->
    <div class="disclaimer">
      <strong>‚ö†Ô∏è Disclaimer:</strong> NGP is not responsible for any injuries, hearing damage, or other harm that may occur from using this audio editor tool. Please use reasonable volume levels and take breaks when using audio equipment. Use at your own risk.
    </div>

    <!-- Note -->
    <div class="notetoself">
      <strong>To the nerds who want more power:</strong> Inspect element on the page to make the sliders limits to your liking :O
    </div>

    <div class="row" style="margin-bottom:6px; justify-content:space-between;">
      <div class="row">
        <button id="addBtn" class="btnGhost">+ Add file</button>
        <button id="clearBtn" class="btnGhost">‚úï Clear</button>
      </div>

      <div style="display:flex; flex-direction:column; align-items:flex-end; gap:6px">
        <div class="unlockWrap" id="unlockWrap">
          <input type="checkbox" id="unlockBox" />
          <label for="unlockBox">Extra range</label>
        </div>
        <span class="tag" id="freeTag">No need to pay, straight from the browser!</span>
      </div>
    </div>

    <div class="grid">
      <!-- Files + Queue -->
      <section class="panel" aria-label="Files">
        <h2>Files</h2>
        <div class="albumControls" style="padding:10px 14px; display:flex; gap:8px; flex-wrap:wrap; align-items:center; border-bottom:1px solid rgba(255,255,255,.05)">
          <button class="btnGhost" id="shuffleBtn" style="font-size:.8rem;padding:5px 10px">üîÄ Shuffle</button>
          <button class="btnGhost" id="clearQueueBtn" style="font-size:.8rem;padding:5px 10px">‚úï Clear</button>
          <label style="display:flex;align-items:center;gap:6px;font-size:.85rem;color:var(--muted);cursor:pointer">
            <input type="checkbox" id="autoplayToggle" checked />
            Auto-advance
          </label>
          <label style="display:flex;align-items:center;gap:6px;font-size:.85rem;color:var(--muted);cursor:pointer">
            <input type="checkbox" id="repeatQueueToggle" />
            Repeat
          </label>
        </div>
        <div class="queueList" id="queueList" style="max-height:340px; overflow:auto">
          <div class="queueEmpty" id="queueEmpty">No songs yet. Click "+ Add file"!</div>
        </div>
      </section>

      <!-- Editor -->
      <section class="panel" aria-label="Editor">
        <h2 id="currentName">‚Äî</h2>
        <div class="wave-container">
          <div class="wave" id="wave"></div>
          <div class="progress-indicator" id="progressIndicator" style="left:0%"></div>
        </div>
        <div class="timeline"><span id="tStart">0:00</span><span id="tEnd">0:00</span></div>

        <div class="controls">
          <div class="row" style="gap:12px;">
            <span class="pill">Built-in Presets</span>
            <button class="btnGhost" data-preset="normal">Normal</button>
            <button class="btnGhost" data-preset="slowed">Slowed+Reverb</button>
            <button class="btnGhost" data-preset="nightcore">Nightcore</button>
            <button class="btnGhost" data-preset="perfection">Slowed to Perfection</button>
          </div>

          <div class="presetManager">
            <h3>Custom Presets</h3>
            <div class="presetList" id="customPresetList">
              <span class="muted" style="font-size:.85rem">No custom presets saved</span>
            </div>
            <div class="presetActions">
              <button class="btnGhost" id="savePresetBtn">üíæ Save Current</button>
              <button class="btnGhost" id="exportPresetsBtn">üì§ Export JSON</button>
              <button class="btnGhost" id="importPresetsBtn">üì• Import JSON</button>
            </div>
          </div>

          <div class="knob">
            <label>Speed <small id="speedLbl">(1.00√ó)</small></label>
            <input type="range" id="speed" min="0.5" max="1.5" step="0.01" value="1.0" />
            <div class="row" style="margin-top:6px;">
              <input type="checkbox" id="preserve" />
              <label for="preserve" class="muted">Keep original pitch when changing speed</label>
            </div>
          </div>

          <div class="knob">
            <label>Pitch <small id="pitchLbl">(0 semitones)</small></label>
            <input type="range" id="pitch" min="-12" max="12" step="0.1" value="0" />
            <div class="row" style="margin-top:4px;">
              <small class="muted">Note: Pitch shift is applied during export only (not in live preview)</small>
            </div>
          </div>

          <div class="knob">
            <label>Reverb <small id="reverbLbl">(0%)</small></label>
            <input type="range" id="reverb" min="0" max="100" step="1" value="0" />
          </div>

          <div class="knob">
            <label>Bass boost <small id="bassLbl">(0 dB)</small></label>
            <input type="range" id="bass" min="0" max="18" step="1" value="0" />
          </div>

          <div class="knob">
            <label>Muffle <small id="muffleLbl">(0%)</small></label>
            <input type="range" id="muffle" min="0" max="100" step="1" value="0" />
          </div>

          <div class="knob">
            <label>Echo <small id="echoLbl">(0%)</small></label>
            <input type="range" id="echo" min="0" max="100" step="1" value="0" />
          </div>

          <div class="knob">
            <label>Bitcrush <small id="bitcrushLbl">(0%)</small></label>
            <input type="range" id="bitcrush" min="0" max="100" step="1" value="0" />
          </div>

          <div class="row" style="margin-top:10px">
            <button id="downloadBtn" class="btn" disabled>Download Remix</button>
            <select id="exportFormat" disabled>
              <option value="wav">WAV</option>
              <option value="mp3">MP3</option>
            </select>
            <button id="trimBtn" class="btnGhost" disabled>Export selection</button>
            <span class="muted" id="status">Ready</span>
          </div>
          
          <div class="progress-bar" id="renderProgress" style="display:none">
            <div class="progress-fill" id="renderProgressFill"></div>
          </div>
        </div>
      </section>
    </div>


  </div>
</main>

<!-- Floating Gain -->
<aside class="gainFloat" aria-label="Output Gain">
  <span class="cap">+24</span>
  <input type="range" id="gainSlider" min="-24" max="24" step="1" value="0" aria-label="Gain (dB)" />
  <span class="cap">-24</span>
  <span class="gainBadge" id="gainLbl">Gain 0 dB</span>
</aside>

<div class="playerBar">
  <div class="playerInner">
    <button class="play small" id="prevBtn" aria-label="Previous" title="Previous song" style="opacity:0.6">‚èÆ</button>
    <button class="play" id="playBtn" aria-label="Play/Pause">‚ñ∂</button>
    <button class="play small" id="nextBtn" aria-label="Next" title="Next song" style="opacity:0.6">‚è≠</button>
    <button class="play" id="loopBtn" aria-label="Loop" title="Loop" style="font-size:0.8rem">üîÅ</button>
    <div class="time" id="curTime">0:00</div>
    <input class="grow" type="range" id="seek" min="0" max="1" step="0.0001" value="0" />
    <div class="time" id="durTime">0:00</div>
  </div>
</div>

<footer>
  <div class="wrap"><small>¬© <span id="year"></span> NGP</small></div>
</footer>

<input type="file" id="fileInput" accept="audio/*" hidden />
<input type="file" id="queueFileInput" accept="audio/*" multiple hidden />
<input type="file" id="presetImportInput" accept=".json" hidden />

<script>
try {
  // Set year
  document.getElementById('year').textContent = new Date().getFullYear();
  
  // Get elements
  const     elements = {
    addBtn: document.getElementById('addBtn'),
    clearBtn: document.getElementById('clearBtn'),
    fileInput: document.getElementById('fileInput'),
    playBtn: document.getElementById('playBtn'),
    loopBtn: document.getElementById('loopBtn'),
    seek: document.getElementById('seek'),
    curTime: document.getElementById('curTime'),
    durTime: document.getElementById('durTime'),
    tStart: document.getElementById('tStart'),
    tEnd: document.getElementById('tEnd'),
    wave: document.getElementById('wave'),
    status: document.getElementById('status'),
    downloadBtn: document.getElementById('downloadBtn'),
    trimBtn: document.getElementById('trimBtn'),
    speed: document.getElementById('speed'),
    reverb: document.getElementById('reverb'),
    bass: document.getElementById('bass'),
    pitch: document.getElementById('pitch'),
    speedLbl: document.getElementById('speedLbl'),
    reverbLbl: document.getElementById('reverbLbl'),
    bassLbl: document.getElementById('bassLbl'),
    pitchLbl: document.getElementById('pitchLbl'),
    muffle: document.getElementById('muffle'),
    muffleLbl: document.getElementById('muffleLbl'),
    echo: document.getElementById('echo'),
    echoLbl: document.getElementById('echoLbl'),
    bitcrush: document.getElementById('bitcrush'),
    bitcrushLbl: document.getElementById('bitcrushLbl'),
    preserve: document.getElementById('preserve'),
    currentName: document.getElementById('currentName'),
    gainSlider: document.getElementById('gainSlider'),
    gainLbl: document.getElementById('gainLbl'),
    freeTag: document.getElementById('freeTag'),
    unlockWrap: document.getElementById('unlockWrap'),
    unlockBox: document.getElementById('unlockBox'),
    progressIndicator: document.getElementById('progressIndicator'),
    renderProgress: document.getElementById('renderProgress'),
    renderProgressFill: document.getElementById('renderProgressFill'),
    exportFormat: document.getElementById('exportFormat'),
    savePresetBtn: document.getElementById('savePresetBtn'),
    exportPresetsBtn: document.getElementById('exportPresetsBtn'),
    importPresetsBtn: document.getElementById('importPresetsBtn'),
    customPresetList: document.getElementById('customPresetList'),
    presetImportInput: document.getElementById('presetImportInput'),
    // Album/Queue
    queueFileInput: document.getElementById('queueFileInput'),
    queueList: document.getElementById('queueList'),
    queueEmpty: document.getElementById('queueEmpty'),
    clearQueueBtn: document.getElementById('clearQueueBtn'),
    shuffleBtn: document.getElementById('shuffleBtn'),
    autoplayToggle: document.getElementById('autoplayToggle'),
    repeatQueueToggle: document.getElementById('repeatQueueToggle'),
    prevBtn: document.getElementById('prevBtn'),
    nextBtn: document.getElementById('nextBtn')
  };

  // Audio setup
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();
  let audioBuffer = null;
  let sourceNode = null;
  let isPlaying = false;
  let isLooping = false;
  let currentTime = 0;
  let startOffset = 0;
  let lastPlayTime = 0;
  let animationFrame = null;
  let selectionStart = null;
  let selectionEnd = null;

  // Audio nodes
  const nodes = {
    muffle: audioContext.createBiquadFilter(),
    convolver: audioContext.createConvolver(),
    reverbWet: audioContext.createGain(),
    reverbDry: audioContext.createGain(),
    reverbMix: audioContext.createGain(),
    bass: audioContext.createBiquadFilter(),
    dryGain: audioContext.createGain(),
    delay: audioContext.createDelay(2.0),
    feedback: audioContext.createGain(),
    echoWet: audioContext.createGain(),
    // Bitcrush chain
    bitcrushBypass: audioContext.createGain(),
    bitcrushWet: audioContext.createGain(),
    bitcrushHighpass: audioContext.createBiquadFilter(),
    bitcrushLowpass: audioContext.createBiquadFilter(),
    bitcrushCompressor: audioContext.createDynamicsCompressor(),
    bitcrushMono: audioContext.createGain(), // Mono merger
    bitcrushGain: audioContext.createGain(),
    bitcrushMix: audioContext.createGain(),
    master: audioContext.createGain()
  };

  // Setup audio nodes
  nodes.muffle.type = 'lowpass';
  nodes.muffle.frequency.value = 20000;
  nodes.muffle.Q.value = 0.7;
  nodes.reverbDry.gain.value = 1;  // Start with dry signal only
  nodes.reverbWet.gain.value = 0;  // No reverb
  nodes.bass.type = 'lowshelf';
  nodes.bass.frequency.value = 140;
  nodes.bass.gain.value = 0;
  nodes.dryGain.gain.value = 1;
  nodes.feedback.gain.value = 0;
  nodes.echoWet.gain.value = 0;
  nodes.master.gain.value = 1;

  // Bitcrush setup - Start fully bypassed for clean audio
  nodes.bitcrushBypass.gain.value = 1;
  nodes.bitcrushWet.gain.value = 0;
  nodes.bitcrushHighpass.type = 'highpass';
  nodes.bitcrushHighpass.frequency.value = 100;
  nodes.bitcrushHighpass.Q.value = 10; // Steep cutoff
  nodes.bitcrushLowpass.type = 'lowpass';
  nodes.bitcrushLowpass.frequency.value = 4000;
  nodes.bitcrushLowpass.Q.value = 10; // Steep cutoff
  nodes.bitcrushCompressor.threshold.value = -25;
  nodes.bitcrushCompressor.knee.value = 5;
  nodes.bitcrushCompressor.ratio.value = 6;
  nodes.bitcrushCompressor.attack.value = 0.03; // 30ms
  nodes.bitcrushCompressor.release.value = 0.15; // 150ms
  nodes.bitcrushGain.gain.value = 3; // Amplify to compensate
  nodes.bitcrushMix.gain.value = 1; // Unity gain output

  // Connect audio graph
  nodes.delay.connect(nodes.feedback);
  nodes.feedback.connect(nodes.delay);

  // Reverb dry/wet mix
  nodes.muffle.connect(nodes.reverbDry);
  nodes.muffle.connect(nodes.convolver);
  nodes.convolver.connect(nodes.reverbWet);
  nodes.reverbDry.connect(nodes.reverbMix);
  nodes.reverbWet.connect(nodes.reverbMix);

  nodes.reverbMix.connect(nodes.bass);
  nodes.bass.connect(nodes.dryGain);
  nodes.bass.connect(nodes.delay);
  nodes.delay.connect(nodes.echoWet);

  // Bitcrush chain - dry/wet mix
  nodes.dryGain.connect(nodes.bitcrushBypass);
  nodes.echoWet.connect(nodes.bitcrushBypass);
  nodes.dryGain.connect(nodes.bitcrushWet);
  nodes.echoWet.connect(nodes.bitcrushWet);

  // Bitcrush wet path: filter ‚Üí compress ‚Üí gain
  nodes.bitcrushWet.connect(nodes.bitcrushHighpass);
  nodes.bitcrushHighpass.connect(nodes.bitcrushLowpass);
  nodes.bitcrushLowpass.connect(nodes.bitcrushCompressor);
  nodes.bitcrushCompressor.connect(nodes.bitcrushGain);

  // Mix paths
  nodes.bitcrushBypass.connect(nodes.bitcrushMix);
  nodes.bitcrushGain.connect(nodes.bitcrushMix);
  nodes.bitcrushMix.connect(nodes.master);
  nodes.master.connect(audioContext.destination);

  // Helper functions
  function formatTime(seconds) {
    const mins = Math.floor(Math.max(0, seconds) / 60);
    const secs = Math.floor(Math.max(0, seconds) % 60);
    return mins + ':' + secs.toString().padStart(2, '0');
  }

  function dbToLinear(db) {
    return Math.pow(10, db / 20);
  }

  function setStatus(text) {
    elements.status.textContent = text;
  }

  function updateProgressIndicator() {
    if (!audioBuffer) return;
    const progress = currentTime / audioBuffer.duration;
    elements.progressIndicator.style.left = Math.min(100, Math.max(0, progress * 100)) + '%';
  }

  function createImpulseResponse(seconds, decay) {
    seconds = seconds || 1.5;
    decay = decay || 2.5;
    const sampleRate = audioContext.sampleRate;
    const length = Math.max(1, Math.floor(seconds * sampleRate));
    const impulse = audioContext.createBuffer(2, length, sampleRate);
    
    // Create a very short, almost dry impulse for default (no reverb)
    if (seconds < 0.01) {
      for (let channel = 0; channel < 2; channel++) {
        const channelData = impulse.getChannelData(channel);
        channelData[0] = 1; // Single impulse for dry signal
      }
    } else {
      for (let channel = 0; channel < 2; channel++) {
        const channelData = impulse.getChannelData(channel);
        for (let i = 0; i < length; i++) {
          const n = length - i;
          channelData[i] = (Math.random() * 2 - 1) * Math.pow(n / length, decay);
        }
      }
    }
    return impulse;
  }

  // Initialize reverb with proper dry signal
  nodes.convolver.buffer = createImpulseResponse(0.001, 0.1);

  // File handling
  // Note: createAudioSource is defined in the Album/Queue section below (queue-aware version)
  elements.addBtn.onclick = function() {
    elements.queueFileInput.click();
  };

  elements.fileInput.onchange = async function(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    setStatus('Loading file...');
    
    try {
      const arrayBuffer = await file.arrayBuffer();
      audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
      
      // Initialize all effects properly
      updateMuffleFilter();
      updateEchoEffect();
      updateBitcrushEffect();
      updateGain();
      
      createAudioSource();
      elements.currentName.textContent = file.name;
      drawWaveform(audioBuffer);
      
      elements.tStart.textContent = '0:00';
      elements.tEnd.textContent = formatTime(audioBuffer.duration);
      elements.durTime.textContent = formatTime(audioBuffer.duration);
      
      elements.seek.value = 0;
      elements.seek.max = audioBuffer.duration;
      currentTime = 0;
      updateProgressIndicator();
      
      elements.downloadBtn.disabled = false;
      elements.trimBtn.disabled = false;
      elements.exportFormat.disabled = false;
      setStatus('Ready');
      
    } catch (error) {
      console.error('Error loading file:', error);
      setStatus('Failed to load file');
    }
  };

  elements.clearBtn.onclick = function() {
    if (sourceNode) {
      try { sourceNode.stop(); } catch (e) {}
      sourceNode.disconnect();
    }
    
    sourceNode = null;
    audioBuffer = null;
    isPlaying = false;
    currentTime = 0;
    
    elements.currentName.textContent = '‚Äî';
    
    const canvas = elements.wave.querySelector('canvas');
    if (canvas) {
      const ctx2d = canvas.getContext('2d');
      ctx2d.clearRect(0, 0, canvas.width, canvas.height);
    }
    
    elements.seek.value = 0;
    elements.durTime.textContent = '0:00';
    elements.tEnd.textContent = '0:00';
    elements.curTime.textContent = '0:00';
    elements.playBtn.textContent = '‚ñ∂';
    elements.downloadBtn.disabled = true;
    updateProgressIndicator();
    
    if (animationFrame) {
      cancelAnimationFrame(animationFrame);
      animationFrame = null;
    }
    
    setStatus('Cleared');
  };

  // Waveform drawing
  function drawWaveform(buffer) {
    let canvas = elements.wave.querySelector('canvas');
    if (!canvas) {
      canvas = document.createElement('canvas');
      elements.wave.appendChild(canvas);
    }
    
    const rect = elements.wave.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    
    const ctx2d = canvas.getContext('2d');
    ctx2d.clearRect(0, 0, canvas.width, canvas.height);
    
    if (!buffer) return;
    
    const channelData = buffer.getChannelData(0);
    const samples = channelData.length;
    const step = Math.max(1, Math.floor(samples / canvas.width));
    const midHeight = canvas.height / 2;
    
    ctx2d.fillStyle = 'rgba(255, 255, 255, 0.8)';
    
    for (let x = 0; x < canvas.width; x++) {
      let min = 1;
      let max = -1;
      
      const start = x * step;
      const end = Math.min(start + step, samples);
      
      for (let i = start; i < end; i++) {
        const sample = channelData[i];
        if (sample < min) min = sample;
        if (sample > max) max = sample;
      }
      
      const height = Math.max(1, (max - min) * midHeight);
      const y = midHeight + min * midHeight;
      
      ctx2d.fillRect(x, y, 1, height);
    }

    // Make waveform clickable to seek
    canvas.style.cursor = 'pointer';
    canvas.onclick = function(e) {
      if (!audioBuffer) return;

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const percent = x / rect.width;
      const seekTime = percent * audioBuffer.duration;

      // Shift+click for selection
      if (e.shiftKey) {
        if (selectionStart === null) {
          selectionStart = seekTime;
          setStatus('Selection start: ' + formatTime(seekTime));
        } else {
          selectionEnd = seekTime;
          if (selectionStart > selectionEnd) {
            const temp = selectionStart;
            selectionStart = selectionEnd;
            selectionEnd = temp;
          }
          setStatus('Selection: ' + formatTime(selectionStart) + ' - ' + formatTime(selectionEnd));
          drawWaveform(audioBuffer); // Redraw with selection
        }
        return;
      }

      // Clear selection on normal click
      selectionStart = null;
      selectionEnd = null;

      currentTime = seekTime;
      elements.seek.value = seekTime;

      // If playing, restart from new position
      if (isPlaying) {
        try {
          sourceNode.stop();
          sourceNode.disconnect();
        } catch (e) {}

        // Small delay to prevent clicks/pops
        setTimeout(function() {
          if (isPlaying) {  // Check if still playing after timeout
            createAudioSource();
            startOffset = seekTime;
            sourceNode.start(0, startOffset);
            lastPlayTime = audioContext.currentTime;
            updateTimeDisplay();
          }
        }, 10);
      } else {
        elements.curTime.textContent = formatTime(currentTime);
        updateProgressIndicator();
      }

      drawWaveform(audioBuffer); // Redraw without selection
    };

    // Draw selection overlay
    if (buffer && selectionStart !== null && selectionEnd !== null) {
      const startX = (selectionStart / buffer.duration) * canvas.width;
      const endX = (selectionEnd / buffer.duration) * canvas.width;
      ctx2d.fillStyle = 'rgba(37, 117, 252, 0.3)';
      ctx2d.fillRect(startX, 0, endX - startX, canvas.height);
    }
  }

  // Playback controls
  function getCurrentPlaybackTime() {
    if (!audioBuffer) return 0;
    if (!isPlaying) return currentTime;

    const elapsed = (audioContext.currentTime - lastPlayTime) * sourceNode.playbackRate.value;
    let time = startOffset + elapsed;

    // Handle looping - wrap time around
    if (isLooping && time >= audioBuffer.duration) {
      time = time % audioBuffer.duration;
    } else {
      time = Math.min(audioBuffer.duration, time);
    }

    return time;
  }

  function updateTimeDisplay() {
    if (!audioBuffer) return;

    currentTime = getCurrentPlaybackTime();
    elements.curTime.textContent = formatTime(currentTime);
    elements.seek.value = currentTime;
    updateProgressIndicator();

    if (isPlaying && (currentTime < audioBuffer.duration || isLooping)) {
      animationFrame = requestAnimationFrame(updateTimeDisplay);
    }
  }

  elements.playBtn.onclick = function() {
    if (!audioBuffer) return;

    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }

    if (!isPlaying) {
      // Start playback
      createAudioSource();
      startOffset = currentTime;
      sourceNode.start(0, startOffset);
      lastPlayTime = audioContext.currentTime;
      isPlaying = true;
      elements.playBtn.textContent = '‚è∏';
      updateTimeDisplay();
    } else {
      // Pause playback
      try {
        sourceNode.stop();
        sourceNode.disconnect();
      } catch (e) {}
      currentTime = getCurrentPlaybackTime();
      isPlaying = false;
      elements.playBtn.textContent = '‚ñ∂';
      if (animationFrame) {
        cancelAnimationFrame(animationFrame);
        animationFrame = null;
      }
    }
  };

  // Space bar to play/pause
  document.addEventListener('keydown', function(e) {
    if (e.code === 'Space' && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA' && e.target.tagName !== 'BUTTON') {
      e.preventDefault();
      elements.playBtn.click();
    }
  });

  // Loop button
  elements.loopBtn.onclick = function() {
    isLooping = !isLooping;
    elements.loopBtn.style.opacity = isLooping ? '1' : '0.5';
    elements.loopBtn.style.background = isLooping ? 'rgba(37,117,252,0.3)' : 'rgba(255,255,255,.06)';

    // Update the current source node if playing
    if (sourceNode) {
      sourceNode.loop = isLooping;
    }
  };

  // Seek control
  elements.seek.oninput = function() {
    if (!audioBuffer) return;
    currentTime = parseFloat(elements.seek.value);
    elements.curTime.textContent = formatTime(currentTime);
    updateProgressIndicator();
  };

  elements.seek.onchange = function() {
    if (!audioBuffer) return;

    const wasPlaying = isPlaying;
    currentTime = parseFloat(elements.seek.value);

    // Stop current playback if playing
    if (isPlaying) {
      try {
        sourceNode.stop();
        sourceNode.disconnect();
      } catch (e) {}
      if (animationFrame) {
        cancelAnimationFrame(animationFrame);
        animationFrame = null;
      }
    }

    // Update display
    elements.curTime.textContent = formatTime(currentTime);
    updateProgressIndicator();

    // Restart if it was playing
    if (wasPlaying) {
      // Small delay to prevent audio artifacts
      setTimeout(function() {
        createAudioSource();
        startOffset = currentTime;
        sourceNode.start(0, startOffset);
        lastPlayTime = audioContext.currentTime;
        isPlaying = true;
        elements.playBtn.textContent = '‚è∏';
        updateTimeDisplay();
      }, 10);
    }
  };

  // Effect controls
  function updateMuffleFilter() {
    const muffleValue = parseInt(elements.muffle.value);
    const isUnlocked = elements.unlockBox && elements.unlockBox.checked;
    const maxFreq = 20000;
    const minFreq = isUnlocked ? 60 : 300;
    const range = Math.max(0, Math.min(isUnlocked ? 2 : 1, muffleValue / 100));
    
    const frequency = maxFreq * Math.pow(minFreq / maxFreq, range);
    nodes.muffle.frequency.value = Math.max(60, frequency);
    elements.muffleLbl.textContent = '(' + muffleValue + '%)';
  }

  function updateEchoEffect() {
    const echoValue = parseInt(elements.echo.value);
    const isUnlocked = elements.unlockBox && elements.unlockBox.checked;
    const range = Math.max(0, Math.min(isUnlocked ? 2 : 1, echoValue / 100));

    const delayTime = 0.08 + (isUnlocked ? 1.2 : 0.42) * range;
    const feedback = Math.min(0.95, (isUnlocked ? 0.95 : 0.85) * range);
    const wetLevel = Math.min(1.2, (isUnlocked ? 1.2 : 0.8) * range);

    nodes.delay.delayTime.value = Math.min(2.0, delayTime);
    nodes.feedback.gain.value = feedback;
    nodes.echoWet.gain.value = wetLevel;
    elements.echoLbl.textContent = '(' + echoValue + '%)';
  }

  function updateBitcrushEffect() {
    const bitcrushValue = parseInt(elements.bitcrush.value);
    elements.bitcrushLbl.textContent = '(' + bitcrushValue + '%)';

    const isUnlocked = elements.unlockBox && elements.unlockBox.checked;
    const maxValue = isUnlocked ? 200 : 100;
    const mix = Math.min(1, bitcrushValue / maxValue);

    // Crossfade between bypass (dry) and wet (bitcrushed) signal
    // Using equal power crossfade for smooth transition
    const dryGain = Math.cos(mix * Math.PI / 2);
    const wetGain = Math.sin(mix * Math.PI / 2);

    nodes.bitcrushBypass.gain.value = dryGain;
    nodes.bitcrushWet.gain.value = wetGain;
  }

  function syncActiveTrackSettings() {
    if (queueIndex >= 0 && queueIndex < queue.length) {
      queue[queueIndex].settings = {
        speed: parseFloat(elements.speed.value),
        pitch: parseFloat(elements.pitch.value),
        reverb: parseFloat(elements.reverb.value),
        bass: parseFloat(elements.bass.value),
        muffle: parseFloat(elements.muffle.value),
        echo: parseFloat(elements.echo.value),
        bitcrush: parseFloat(elements.bitcrush.value),
        preserve: elements.preserve.checked
      };
    }
  }

  elements.speed.oninput = function() {
    const speedValue = parseFloat(elements.speed.value);
    elements.speedLbl.textContent = '(' + speedValue.toFixed(2) + '√ó)';
    if (sourceNode) {
      sourceNode.playbackRate.value = speedValue;
    }
    syncActiveTrackSettings();
  };

  elements.pitch.oninput = function() {
    const pitchValue = parseFloat(elements.pitch.value);
    const roundedPitch = Math.round(pitchValue * 10) / 10;
    elements.pitchLbl.textContent = '(' + (roundedPitch >= 0 ? '+' : '') + roundedPitch + ' semitones)';
    syncActiveTrackSettings();
  };

  elements.preserve.onchange = function() {
    syncActiveTrackSettings();
  };

  elements.reverb.oninput = function() {
    const reverbValue = parseInt(elements.reverb.value);
    elements.reverbLbl.textContent = '(' + reverbValue + '%)';

    const isUnlocked = elements.unlockBox && elements.unlockBox.checked;
    const maxValue = isUnlocked ? 300 : 100;
    const mix = Math.min(1, reverbValue / maxValue);

    // Equal power crossfade for reverb
    nodes.reverbDry.gain.value = Math.cos(mix * Math.PI / 2);
    nodes.reverbWet.gain.value = Math.sin(mix * Math.PI / 2);

    // Update impulse response for the wet signal
    if (reverbValue > 0) {
      const reverbAmount = Math.max(0.001, reverbValue / 100);
      nodes.convolver.buffer = createImpulseResponse(1.8 * reverbAmount + 0.05, 3 * reverbAmount + 0.5);
    }
    syncActiveTrackSettings();
  };

  elements.bass.oninput = function() {
    const bassValue = parseInt(elements.bass.value);
    elements.bassLbl.textContent = '(' + bassValue + ' dB)';
    nodes.bass.gain.value = bassValue;
    syncActiveTrackSettings();
  };

  elements.muffle.oninput = function() { updateMuffleFilter(); syncActiveTrackSettings(); };
  elements.echo.oninput = function() { updateEchoEffect(); syncActiveTrackSettings(); };
  elements.bitcrush.oninput = function() { updateBitcrushEffect(); syncActiveTrackSettings(); };

  function updateGain() {
    const gainValue = parseInt(elements.gainSlider.value);
    nodes.master.gain.value = dbToLinear(gainValue);
    elements.gainLbl.textContent = 'Gain ' + (gainValue >= 0 ? '+' : '') + gainValue + ' dB';
  }
  
  elements.gainSlider.oninput = updateGain;

  // Initialize effects
  updateMuffleFilter();
  updateEchoEffect();
  updateBitcrushEffect();
  updateGain();

  // Presets
  document.querySelectorAll('[data-preset]').forEach(function(button) {
    button.onclick = function() {
      const preset = button.dataset.preset;

      if (preset === 'normal') {
        elements.speed.value = 1.0;
        elements.pitch.value = 0;
        elements.reverb.value = 0;
        elements.bass.value = 0;
        elements.muffle.value = 0;
        elements.echo.value = 0;
        elements.bitcrush.value = 0;
        elements.gainSlider.value = 0;
        elements.preserve.checked = true;
      } else if (preset === 'slowed') {
        elements.speed.value = 0.70;
        elements.pitch.value = 0;
        elements.reverb.value = 45;
        elements.bass.value = 2;
        elements.muffle.value = 10;
        elements.echo.value = 10;
        elements.bitcrush.value = 0;
        elements.preserve.checked = true;
      } else if (preset === 'nightcore') {
        elements.speed.value = 1.25;
        elements.pitch.value = 2;
        elements.reverb.value = 0;
        elements.bass.value = 0;
        elements.muffle.value = 0;
        elements.echo.value = 0;
        elements.bitcrush.value = 0;
        elements.preserve.checked = false;
      } else if (preset === 'perfection') {
        elements.speed.value = 0.83;
        elements.pitch.value = -1;
        elements.reverb.value = 26;
        elements.bass.value = 10;
        elements.muffle.value = 12;
        elements.echo.value = 8;
        elements.bitcrush.value = 0;
        elements.preserve.checked = true;
      }

      // Trigger all updates
      elements.speed.oninput();
      elements.pitch.oninput();
      elements.reverb.oninput();
      elements.bass.oninput();
      updateMuffleFilter();
      updateEchoEffect();
      updateBitcrushEffect();
      updateGain();
    };
  });

  // Download functionality - full version
  elements.downloadBtn.onclick = async function() {
    if (!audioBuffer) return;
    
    elements.downloadBtn.disabled = true;
    elements.renderProgress.style.display = 'block';
    setStatus('Preparing render...');
    
    try {
      const params = {
        speed: parseFloat(elements.speed.value),
        pitch: parseFloat(elements.pitch.value),
        reverb: parseInt(elements.reverb.value),
        bass: parseInt(elements.bass.value),
        muffle: parseInt(elements.muffle.value),
        echo: parseInt(elements.echo.value),
        bitcrush: parseInt(elements.bitcrush.value),
        gain: parseInt(elements.gainSlider.value),
        preservePitch: elements.preserve.checked,
        isUnlocked: elements.unlockBox && elements.unlockBox.checked
      };
      
      // Always use resampling - Web Audio API handles pitch preservation internally
      const renderedBuffer = await renderWithResampling(audioBuffer, params);
      
      setStatus('Creating download...');
      elements.renderProgressFill.style.width = '90%';

      const format = elements.exportFormat.value;
      let blob, extension;

      if (format === 'mp3') {
        setStatus('Encoding MP3...');
        blob = await audioBufferToMp3(renderedBuffer);
        extension = 'mp3';
      } else {
        blob = audioBufferToWav(renderedBuffer);
        extension = 'wav';
      }

      const url = URL.createObjectURL(blob);

      const filename = (elements.currentName.textContent || 'audio').replace(/\.[^.]+$/, '') + '_NGP-remix.' + extension;
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.style.display = 'none';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      URL.revokeObjectURL(url);
      
      elements.renderProgressFill.style.width = '100%';
      setStatus('Download complete!');
      
      setTimeout(function() {
        elements.renderProgress.style.display = 'none';
        elements.renderProgressFill.style.width = '0%';
        setStatus('Ready');
      }, 2000);
      
    } catch (error) {
      console.error('Render error:', error);
      setStatus('Render failed: ' + error.message);
      elements.renderProgress.style.display = 'none';
      elements.renderProgressFill.style.width = '0%';
    } finally {
      elements.downloadBtn.disabled = false;
    }
  };

  // Export selection functionality
  elements.trimBtn.onclick = async function() {
    if (!audioBuffer) return;

    if (selectionStart === null || selectionEnd === null) {
      alert('Please select a region first by Shift+clicking on the waveform twice');
      return;
    }

    elements.trimBtn.disabled = true;
    elements.renderProgress.style.display = 'block';
    setStatus('Preparing selection export...');

    try {
      const params = {
        speed: parseFloat(elements.speed.value),
        pitch: parseFloat(elements.pitch.value),
        reverb: parseInt(elements.reverb.value),
        bass: parseInt(elements.bass.value),
        muffle: parseInt(elements.muffle.value),
        echo: parseInt(elements.echo.value),
        bitcrush: parseInt(elements.bitcrush.value),
        gain: parseInt(elements.gainSlider.value),
        preservePitch: elements.preserve.checked,
        isUnlocked: elements.unlockBox && elements.unlockBox.checked,
        selectionStart: selectionStart,
        selectionEnd: selectionEnd
      };

      // Render the selection
      const renderedBuffer = await renderWithResampling(audioBuffer, params);

      setStatus('Creating download...');
      elements.renderProgressFill.style.width = '90%';

      const format = elements.exportFormat.value;
      let blob, extension;

      if (format === 'mp3') {
        setStatus('Encoding MP3...');
        blob = await audioBufferToMp3(renderedBuffer);
        extension = 'mp3';
      } else {
        blob = audioBufferToWav(renderedBuffer);
        extension = 'wav';
      }

      const url = URL.createObjectURL(blob);

      const filename = (elements.currentName.textContent || 'audio').replace(/\.[^.]+$/, '') + '_selection.' + extension;

      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.style.display = 'none';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);

      URL.revokeObjectURL(url);

      elements.renderProgressFill.style.width = '100%';
      setStatus('Selection exported!');

      setTimeout(function() {
        elements.renderProgress.style.display = 'none';
        elements.renderProgressFill.style.width = '0%';
        setStatus('Ready');
      }, 2000);

    } catch (error) {
      console.error('Export error:', error);
      setStatus('Export failed: ' + error.message);
      elements.renderProgress.style.display = 'none';
      elements.renderProgressFill.style.width = '0%';
    } finally {
      elements.trimBtn.disabled = false;
    }
  };

  // Rendering functions
  async function renderWithResampling(buffer, params) {
    setStatus('Rendering (resampling)...');
    elements.renderProgressFill.style.width = '20%';

    // Handle selection trimming
    let workBuffer = buffer;
    if (params.selectionStart !== undefined && params.selectionEnd !== undefined) {
      const startSample = Math.floor(params.selectionStart * buffer.sampleRate);
      const endSample = Math.floor(params.selectionEnd * buffer.sampleRate);
      const selectionLength = endSample - startSample;

      const trimmedBuffer = audioContext.createBuffer(
        buffer.numberOfChannels,
        selectionLength,
        buffer.sampleRate
      );

      for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
        const sourceData = buffer.getChannelData(ch);
        const destData = trimmedBuffer.getChannelData(ch);
        for (let i = 0; i < selectionLength; i++) {
          destData[i] = sourceData[startSample + i];
        }
      }

      workBuffer = trimmedBuffer;
    }

    const channels = workBuffer.numberOfChannels;
    const sampleRate = workBuffer.sampleRate;

    // Reworked pitch system:
    // - Speed: controls playback speed
    // - Pitch: always applied independently
    // - Preserve: determines if speed affects pitch

    const pitchShift = Math.pow(2, params.pitch / 12);  // Independent pitch shift

    let speedPlaybackRate, finalSampleRate;

    if (params.preservePitch) {
      // Preserve pitch mode: speed doesn't affect pitch
      // Apply speed WITHOUT affecting pitch, then apply pitch shift separately
      speedPlaybackRate = params.speed;
      finalSampleRate = Math.round(sampleRate * pitchShift);  // Pitch via sample rate
    } else {
      // Non-preserve mode: speed affects pitch naturally, then apply extra pitch on top
      speedPlaybackRate = params.speed * pitchShift;  // Both speed and pitch
      finalSampleRate = sampleRate;  // No sample rate change needed
    }

    // Create a buffer with pitch shift applied (if needed)
    let pitchShiftedBuffer = workBuffer;
    let finalWorkingSampleRate = sampleRate;

    if (params.preservePitch && params.pitch !== 0) {
      // Apply pitch shift by changing sample rate
      const tempCtx = new OfflineAudioContext(channels, workBuffer.length, finalSampleRate);
      const tempSource = tempCtx.createBufferSource();
      tempSource.buffer = workBuffer;
      tempSource.connect(tempCtx.destination);
      tempSource.start(0);
      pitchShiftedBuffer = await tempCtx.startRendering();
      finalWorkingSampleRate = finalSampleRate;
    }

    const outputLength = Math.max(1, Math.floor(pitchShiftedBuffer.length / speedPlaybackRate));
    const offlineCtx = new OfflineAudioContext(channels, outputLength, finalWorkingSampleRate);

    // Create source
    const source = offlineCtx.createBufferSource();
    source.buffer = pitchShiftedBuffer;
    source.playbackRate.value = params.preservePitch ? params.speed : speedPlaybackRate;
    
    elements.renderProgressFill.style.width = '40%';
    
    // Create effects chain - ALWAYS create all nodes to match live playback
    const muffle = offlineCtx.createBiquadFilter();
    muffle.type = 'lowpass';
    muffle.Q.value = 0.7;
    const maxFreq = 20000;
    const minFreq = params.isUnlocked ? 60 : 300;
    const muffleRange = Math.max(0, Math.min(params.isUnlocked ? 2 : 1, params.muffle / 100));
    muffle.frequency.value = Math.max(60, maxFreq * Math.pow(minFreq / maxFreq, muffleRange));

    // Reverb dry/wet mix - MUST be initialized before use
    const conv = offlineCtx.createConvolver();
    // Always create an impulse response (required for convolver to work)
    if (params.reverb > 0) {
      const reverbAmount = Math.max(0.001, params.reverb / 100);
      conv.buffer = createOfflineImpulseResponse(offlineCtx, 1.8 * reverbAmount + 0.05, 3 * reverbAmount + 0.5);
    } else {
      conv.buffer = createOfflineImpulseResponse(offlineCtx, 0.001, 0.1);
    }

    const reverbDry = offlineCtx.createGain();
    const reverbWet = offlineCtx.createGain();
    const reverbMix = offlineCtx.createGain();

    const reverbMaxValue = params.isUnlocked ? 300 : 100;
    const reverbMixAmount = Math.min(1, params.reverb / reverbMaxValue);
    reverbDry.gain.value = Math.cos(reverbMixAmount * Math.PI / 2);
    reverbWet.gain.value = Math.sin(reverbMixAmount * Math.PI / 2);

    const bassEQ = offlineCtx.createBiquadFilter();
    bassEQ.type = 'lowshelf';
    bassEQ.frequency.value = 140;
    bassEQ.gain.value = params.bass;

    const dryGain = offlineCtx.createGain();
    dryGain.gain.value = 1;
    
    // Echo
    const delay = offlineCtx.createDelay(2.0);
    const feedback = offlineCtx.createGain();
    const echoWet = offlineCtx.createGain();
    
    const echoRange = Math.max(0, Math.min(params.isUnlocked ? 2 : 1, params.echo / 100));
    const delayTime = 0.08 + (params.isUnlocked ? 1.2 : 0.42) * echoRange;
    const feedbackAmount = Math.min(0.95, (params.isUnlocked ? 0.95 : 0.85) * echoRange);
    const wetLevel = Math.min(1.2, (params.isUnlocked ? 1.2 : 0.8) * echoRange);
    
    delay.delayTime.value = Math.min(2.0, delayTime);
    feedback.gain.value = feedbackAmount;
    echoWet.gain.value = wetLevel;

    // Bitcrush chain
    const maxValue = params.isUnlocked ? 200 : 100;
    const bitcrushMix = Math.min(1, params.bitcrush / maxValue);
    const dryGainValue = Math.cos(bitcrushMix * Math.PI / 2);
    const wetGainValue = Math.sin(bitcrushMix * Math.PI / 2);

    const bitcrushBypass = offlineCtx.createGain();
    const bitcrushWet = offlineCtx.createGain();
    bitcrushBypass.gain.value = dryGainValue;
    bitcrushWet.gain.value = wetGainValue;

    const bitcrushHighpass = offlineCtx.createBiquadFilter();
    bitcrushHighpass.type = 'highpass';
    bitcrushHighpass.frequency.value = 100;
    bitcrushHighpass.Q.value = 10;

    const bitcrushLowpass = offlineCtx.createBiquadFilter();
    bitcrushLowpass.type = 'lowpass';
    bitcrushLowpass.frequency.value = 4000;
    bitcrushLowpass.Q.value = 10;

    const bitcrushCompressor = offlineCtx.createDynamicsCompressor();
    bitcrushCompressor.threshold.value = -25;
    bitcrushCompressor.knee.value = 5;
    bitcrushCompressor.ratio.value = 6;
    bitcrushCompressor.attack.value = 0.03;
    bitcrushCompressor.release.value = 0.15;

    const bitcrushGain = offlineCtx.createGain();
    bitcrushGain.gain.value = 3;

    const bitcrushMixer = offlineCtx.createGain();

    const master = offlineCtx.createGain();
    master.gain.value = dbToLinear(params.gain);

    elements.renderProgressFill.style.width = '60%';

    // Connect graph - SAME AS LIVE PLAYBACK
    source.connect(muffle);
    muffle.connect(reverbDry);
    muffle.connect(conv);
    conv.connect(reverbWet);
    reverbDry.connect(reverbMix);
    reverbWet.connect(reverbMix);
    reverbMix.connect(bassEQ);
    bassEQ.connect(dryGain);
    bassEQ.connect(delay);
    delay.connect(feedback);
    feedback.connect(delay);
    delay.connect(echoWet);

    // Bitcrush paths
    dryGain.connect(bitcrushBypass);
    echoWet.connect(bitcrushBypass);
    dryGain.connect(bitcrushWet);
    echoWet.connect(bitcrushWet);

    bitcrushWet.connect(bitcrushHighpass);
    bitcrushHighpass.connect(bitcrushLowpass);
    bitcrushLowpass.connect(bitcrushCompressor);
    bitcrushCompressor.connect(bitcrushGain);

    bitcrushBypass.connect(bitcrushMixer);
    bitcrushGain.connect(bitcrushMixer);
    bitcrushMixer.connect(master);
    master.connect(offlineCtx.destination);
    
    source.start(0);
    
    elements.renderProgressFill.style.width = '80%';
    return await offlineCtx.startRendering();
  }

  async function renderWithTimeStretching(buffer, params) {
    setStatus('Rendering (time-stretch)...');
    elements.renderProgressFill.style.width = '10%';
    
    // When preserving pitch, we need to handle speed and pitch separately
    const channels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const inputLength = buffer.length;
    
    // First apply speed change with time-stretching to preserve pitch
    const speedStretchedLength = Math.max(1, Math.floor(inputLength / params.speed));
    
    const frameSize = Math.max(512, Math.floor(0.05 * sampleRate));
    const hopInput = Math.floor(frameSize * 0.25);
    const hopOutput = Math.max(1, Math.floor(hopInput / params.speed));
    
    const window = createHannWindow(frameSize);
    
    elements.renderProgressFill.style.width = '20%';
    
    // Time-stretch each channel
    const stretchedChannels = [];
    for (let c = 0; c < channels; c++) {
      const inputData = buffer.getChannelData(c);
      const outputData = new Float32Array(speedStretchedLength);
      
      let inputPos = 0;
      let outputPos = 0;
      
      while (inputPos + frameSize < inputLength && outputPos + frameSize < speedStretchedLength) {
        for (let i = 0; i < frameSize; i++) {
          if (outputPos + i < speedStretchedLength) {
            outputData[outputPos + i] += inputData[inputPos + i] * window[i];
          }
        }
        inputPos += hopInput;
        outputPos += hopOutput;
      }
      
      stretchedChannels.push(outputData);
    }
    
    elements.renderProgressFill.style.width = '40%';
    
    // Create buffer with time-stretched audio
    const stretchedBuffer = audioContext.createBuffer(channels, speedStretchedLength, sampleRate);
    for (let c = 0; c < channels; c++) {
      stretchedBuffer.getChannelData(c).set(stretchedChannels[c]);
    }
    
    elements.renderProgressFill.style.width = '50%';
    
    // Now apply pitch shift and effects using offline context
    const pitchMultiplier = Math.pow(2, params.pitch / 12);
    const finalLength = Math.max(1, Math.floor(speedStretchedLength / pitchMultiplier));
    
    const offlineCtx = new OfflineAudioContext(channels, finalLength, sampleRate);
    const source = offlineCtx.createBufferSource();
    source.buffer = stretchedBuffer;
    source.playbackRate.value = pitchMultiplier; // Apply pitch shift
    
    // Apply effects - ALWAYS create all nodes to match live playback
    const muffle = offlineCtx.createBiquadFilter();
    muffle.type = 'lowpass';
    muffle.Q.value = 0.7;
    const maxFreq = 20000;
    const minFreq = params.isUnlocked ? 60 : 300;
    const muffleRange = Math.max(0, Math.min(params.isUnlocked ? 2 : 1, params.muffle / 100));
    muffle.frequency.value = Math.max(60, maxFreq * Math.pow(minFreq / maxFreq, muffleRange));

    // Reverb dry/wet mix - MUST be initialized before use
    const conv = offlineCtx.createConvolver();
    // Always create an impulse response (required for convolver to work)
    if (params.reverb > 0) {
      const reverbAmount = Math.max(0.001, params.reverb / 100);
      conv.buffer = createOfflineImpulseResponse(offlineCtx, 1.8 * reverbAmount + 0.05, 3 * reverbAmount + 0.5);
    } else {
      conv.buffer = createOfflineImpulseResponse(offlineCtx, 0.001, 0.1);
    }

    const reverbDry = offlineCtx.createGain();
    const reverbWet = offlineCtx.createGain();
    const reverbMix = offlineCtx.createGain();

    const reverbMaxValue = params.isUnlocked ? 300 : 100;
    const reverbMixAmount = Math.min(1, params.reverb / reverbMaxValue);
    reverbDry.gain.value = Math.cos(reverbMixAmount * Math.PI / 2);
    reverbWet.gain.value = Math.sin(reverbMixAmount * Math.PI / 2);

    const bassEQ = offlineCtx.createBiquadFilter();
    bassEQ.type = 'lowshelf';
    bassEQ.frequency.value = 140;
    bassEQ.gain.value = params.bass;

    const dryGain = offlineCtx.createGain();
    const delay = offlineCtx.createDelay(2.0);
    const feedback = offlineCtx.createGain();
    const echoWet = offlineCtx.createGain();
    
    const echoRange = Math.max(0, Math.min(params.isUnlocked ? 2 : 1, params.echo / 100));
    delay.delayTime.value = Math.min(2.0, 0.08 + (params.isUnlocked ? 1.2 : 0.42) * echoRange);
    feedback.gain.value = Math.min(0.95, (params.isUnlocked ? 0.95 : 0.85) * echoRange);
    echoWet.gain.value = Math.min(1.2, (params.isUnlocked ? 1.2 : 0.8) * echoRange);

    // Bitcrush chain
    const maxValue = params.isUnlocked ? 200 : 100;
    const bitcrushMix = Math.min(1, params.bitcrush / maxValue);
    const dryGainValue = Math.cos(bitcrushMix * Math.PI / 2);
    const wetGainValue = Math.sin(bitcrushMix * Math.PI / 2);

    const bitcrushBypass = offlineCtx.createGain();
    const bitcrushWet = offlineCtx.createGain();
    bitcrushBypass.gain.value = dryGainValue;
    bitcrushWet.gain.value = wetGainValue;

    const bitcrushHighpass = offlineCtx.createBiquadFilter();
    bitcrushHighpass.type = 'highpass';
    bitcrushHighpass.frequency.value = 100;
    bitcrushHighpass.Q.value = 10;

    const bitcrushLowpass = offlineCtx.createBiquadFilter();
    bitcrushLowpass.type = 'lowpass';
    bitcrushLowpass.frequency.value = 4000;
    bitcrushLowpass.Q.value = 10;

    const bitcrushCompressor = offlineCtx.createDynamicsCompressor();
    bitcrushCompressor.threshold.value = -25;
    bitcrushCompressor.knee.value = 5;
    bitcrushCompressor.ratio.value = 6;
    bitcrushCompressor.attack.value = 0.03;
    bitcrushCompressor.release.value = 0.15;

    const bitcrushGain = offlineCtx.createGain();
    bitcrushGain.gain.value = 3;

    const bitcrushMixer = offlineCtx.createGain();

    const master = offlineCtx.createGain();
    master.gain.value = dbToLinear(params.gain);

    elements.renderProgressFill.style.width = '70%';

    // Connect - SAME AS LIVE PLAYBACK
    source.connect(muffle);
    muffle.connect(reverbDry);
    muffle.connect(conv);
    conv.connect(reverbWet);
    reverbDry.connect(reverbMix);
    reverbWet.connect(reverbMix);
    reverbMix.connect(bassEQ);
    bassEQ.connect(dryGain);
    bassEQ.connect(delay);
    delay.connect(feedback);
    feedback.connect(delay);
    delay.connect(echoWet);

    // Bitcrush paths
    dryGain.connect(bitcrushBypass);
    echoWet.connect(bitcrushBypass);
    dryGain.connect(bitcrushWet);
    echoWet.connect(bitcrushWet);

    bitcrushWet.connect(bitcrushHighpass);
    bitcrushHighpass.connect(bitcrushLowpass);
    bitcrushLowpass.connect(bitcrushCompressor);
    bitcrushCompressor.connect(bitcrushGain);

    bitcrushBypass.connect(bitcrushMixer);
    bitcrushGain.connect(bitcrushMixer);
    bitcrushMixer.connect(master);
    master.connect(offlineCtx.destination);
    
    source.start(0);
    
    elements.renderProgressFill.style.width = '90%';
    return await offlineCtx.startRendering();
  }

  function createHannWindow(size) {
    const window = new Float32Array(size);
    for (let i = 0; i < size; i++) {
      window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (size - 1)));
    }
    return window;
  }

  function createOfflineImpulseResponse(offlineCtx, seconds, decay) {
    seconds = seconds || 1.5;
    decay = decay || 2.5;
    const sampleRate = offlineCtx.sampleRate;
    const length = Math.max(1, Math.floor(seconds * sampleRate));
    const impulse = offlineCtx.createBuffer(2, length, sampleRate);

    // Create a very short, almost dry impulse for default (no reverb)
    if (seconds < 0.01) {
      for (let channel = 0; channel < 2; channel++) {
        const channelData = impulse.getChannelData(channel);
        channelData[0] = 1; // Single impulse for dry signal
      }
    } else {
      for (let channel = 0; channel < 2; channel++) {
        const channelData = impulse.getChannelData(channel);
        for (let i = 0; i < length; i++) {
          const n = length - i;
          channelData[i] = (Math.random() * 2 - 1) * Math.pow(n / length, decay);
        }
      }
    }
    return impulse;
  }

  // WAV export function
  function audioBufferToWav(buffer) {
    const length = buffer.length;
    const channels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    
    const arrayBuffer = new ArrayBuffer(44 + length * channels * 2);
    const view = new DataView(arrayBuffer);
    
    // WAV header
    function writeString(offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }
    
    writeString(0, 'RIFF');
    view.setUint32(4, 36 + length * channels * 2, true);
    writeString(8, 'WAVE');
    writeString(12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, channels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * channels * 2, true);
    view.setUint16(32, channels * 2, true);
    view.setUint16(34, 16, true);
    writeString(36, 'data');
    view.setUint32(40, length * channels * 2, true);
    
    // Convert float samples to 16-bit PCM
    const channelData = [];
    for (let c = 0; c < channels; c++) {
      channelData.push(buffer.getChannelData(c));
    }
    
    let offset = 44;
    for (let i = 0; i < length; i++) {
      for (let c = 0; c < channels; c++) {
        const sample = Math.max(-1, Math.min(1, channelData[c][i]));
        const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
        view.setInt16(offset, intSample, true);
        offset += 2;
      }
    }
    
    return new Blob([arrayBuffer], { type: 'audio/wav' });
  }

  // MP3 export function
  async function audioBufferToMp3(buffer) {
    const channels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const kbps = 192;

    const mp3encoder = new lamejs.Mp3Encoder(channels, sampleRate, kbps);
    const sampleBlockSize = 1152;

    const mp3Data = [];

    // Convert float to 16-bit PCM
    const left = new Int16Array(buffer.length);
    const right = channels > 1 ? new Int16Array(buffer.length) : null;

    const leftData = buffer.getChannelData(0);
    const rightData = channels > 1 ? buffer.getChannelData(1) : null;

    for (let i = 0; i < buffer.length; i++) {
      left[i] = Math.max(-1, Math.min(1, leftData[i])) * 0x7FFF;
      if (right) {
        right[i] = Math.max(-1, Math.min(1, rightData[i])) * 0x7FFF;
      }
    }

    // Encode in blocks
    for (let i = 0; i < buffer.length; i += sampleBlockSize) {
      const leftChunk = left.subarray(i, i + sampleBlockSize);
      const rightChunk = right ? right.subarray(i, i + sampleBlockSize) : null;

      const mp3buf = mp3encoder.encodeBuffer(leftChunk, rightChunk);
      if (mp3buf.length > 0) {
        mp3Data.push(mp3buf);
      }
    }

    // Finish encoding
    const mp3buf = mp3encoder.flush();
    if (mp3buf.length > 0) {
      mp3Data.push(mp3buf);
    }

    return new Blob(mp3Data, { type: 'audio/mp3' });
  }

  // Secret unlock
  let secretClicks = 0;
  elements.freeTag.addEventListener('click', function() {
    secretClicks++;
    if (secretClicks >= 15) {
      elements.unlockWrap.style.display = 'flex';
      elements.freeTag.textContent = 'Extra features unlocked!';
      elements.freeTag.style.background = 'rgba(106,17,203,.2)';
    }
  });

  function setUnlockedRanges(unlocked) {
    if (unlocked) {
      elements.speed.min = '0.05';
      elements.speed.max = '4';
      elements.speed.step = '0.001';
      elements.pitch.min = '-24';
      elements.pitch.max = '24';
      elements.pitch.step = '0.05';
      elements.reverb.max = '300';
      elements.bass.min = '-24';
      elements.bass.max = '48';
      elements.gainSlider.min = '-48';
      elements.gainSlider.max = '48';
      elements.muffle.max = '200';
      elements.echo.max = '200';
      elements.bitcrush.max = '200';
    } else {
      elements.speed.min = '0.5';
      elements.speed.max = '1.5';
      elements.speed.step = '0.01';
      elements.pitch.min = '-12';
      elements.pitch.max = '12';
      elements.pitch.step = '0.1';
      elements.reverb.max = '100';
      elements.bass.min = '0';
      elements.bass.max = '18';
      elements.gainSlider.min = '-24';
      elements.gainSlider.max = '24';
      elements.muffle.max = '100';
      elements.echo.max = '100';
      elements.bitcrush.max = '100';
    }
    updateMuffleFilter();
    updateEchoEffect();
    updateBitcrushEffect();
  }

  elements.unlockBox.addEventListener('change', function(e) {
    setUnlockedRanges(e.target.checked);
  });

  setUnlockedRanges(false);

  // Window resize handler for waveform
  new ResizeObserver(function() {
    drawWaveform(audioBuffer);
  }).observe(elements.wave);

  // Custom Preset Management System
  let customPresets = [];

  function loadPresetsFromStorage() {
    try {
      const stored = localStorage.getItem('ngp-audio-presets');
      if (stored) {
        customPresets = JSON.parse(stored);
        renderPresetList();
      }
    } catch (error) {
      console.error('Failed to load presets:', error);
    }
  }

  function savePresetsToStorage() {
    try {
      localStorage.setItem('ngp-audio-presets', JSON.stringify(customPresets));
    } catch (error) {
      console.error('Failed to save presets:', error);
    }
  }

  function getCurrentPresetValues() {
    return {
      speed: parseFloat(elements.speed.value),
      pitch: parseFloat(elements.pitch.value),
      reverb: parseInt(elements.reverb.value),
      bass: parseInt(elements.bass.value),
      muffle: parseInt(elements.muffle.value),
      echo: parseInt(elements.echo.value),
      bitcrush: parseInt(elements.bitcrush.value),
      gain: parseInt(elements.gainSlider.value),
      preserve: elements.preserve.checked
    };
  }

  function applyPreset(preset) {
    elements.speed.value = preset.speed;
    elements.pitch.value = preset.pitch;
    elements.reverb.value = preset.reverb;
    elements.bass.value = preset.bass;
    elements.muffle.value = preset.muffle;
    elements.echo.value = preset.echo;
    elements.bitcrush.value = preset.bitcrush || 0;
    elements.gainSlider.value = preset.gain || 0;
    elements.preserve.checked = preset.preserve;

    // Trigger all updates
    elements.speed.oninput();
    elements.pitch.oninput();
    elements.reverb.oninput();
    elements.bass.oninput();
    updateMuffleFilter();
    updateEchoEffect();
    updateBitcrushEffect();
    updateGain();
  }

  function renderPresetList() {
    if (customPresets.length === 0) {
      elements.customPresetList.innerHTML = '<span class="muted" style="font-size:.85rem">No custom presets saved</span>';
      return;
    }

    elements.customPresetList.innerHTML = '';
    customPresets.forEach(function(preset, index) {
      const item = document.createElement('div');
      item.className = 'presetItem';
      item.innerHTML = '<span>' + preset.name + '</span>' +
                       '<button onclick="loadCustomPreset(' + index + ')" title="Load">‚ñ∂</button>' +
                       '<button onclick="deleteCustomPreset(' + index + ')" title="Delete">‚úï</button>';
      elements.customPresetList.appendChild(item);
    });
  }

  window.loadCustomPreset = function(index) {
    if (customPresets[index]) {
      applyPreset(customPresets[index]);
      setStatus('Loaded preset: ' + customPresets[index].name);
    }
  };

  window.deleteCustomPreset = function(index) {
    if (confirm('Delete preset "' + customPresets[index].name + '"?')) {
      customPresets.splice(index, 1);
      savePresetsToStorage();
      renderPresetList();
      setStatus('Preset deleted');
    }
  };

  elements.savePresetBtn.onclick = function() {
    const name = prompt('Enter preset name:');
    if (!name) return;

    const preset = getCurrentPresetValues();
    preset.name = name;

    customPresets.push(preset);
    savePresetsToStorage();
    renderPresetList();
    setStatus('Preset saved: ' + name);
  };

  elements.exportPresetsBtn.onclick = function() {
    if (customPresets.length === 0) {
      alert('No presets to export');
      return;
    }

    const json = JSON.stringify(customPresets, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = 'ngp-audio-presets.json';
    a.click();

    URL.revokeObjectURL(url);
    setStatus('Presets exported');
  };

  elements.importPresetsBtn.onclick = function() {
    elements.presetImportInput.click();
  };

  elements.presetImportInput.onchange = async function(e) {
    const file = e.target.files[0];
    if (!file) return;

    try {
      const text = await file.text();
      const imported = JSON.parse(text);

      if (!Array.isArray(imported)) {
        throw new Error('Invalid preset file format');
      }

      const merge = customPresets.length > 0 && confirm('Merge with existing presets? (Cancel to replace)');

      if (merge) {
        customPresets = customPresets.concat(imported);
      } else {
        customPresets = imported;
      }

      savePresetsToStorage();
      renderPresetList();
      setStatus('Imported ' + imported.length + ' preset(s)');

    } catch (error) {
      console.error('Import error:', error);
      alert('Failed to import presets: ' + error.message);
    }

    e.target.value = '';
  };

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // ALBUM / QUEUE SYSTEM
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  let queue = [];          // [{name, arrayBuffer, duration, settings:{speed,pitch,reverb,bass,muffle,echo,bitcrush,preserve}}]
  let queueIndex = -1;     // currently active index (-1 = none)

  function defaultSettings() {
    return {
      speed: parseFloat(elements.speed.value),
      pitch: parseFloat(elements.pitch.value),
      reverb: parseFloat(elements.reverb.value),
      bass: parseFloat(elements.bass.value),
      muffle: parseFloat(elements.muffle.value),
      echo: parseFloat(elements.echo.value),
      bitcrush: parseFloat(elements.bitcrush.value),
      preserve: elements.preserve.checked
    };
  }

  function applyTrackSettings(s) {
    elements.speed.value = s.speed;
    elements.pitch.value = s.pitch;
    elements.reverb.value = s.reverb;
    elements.bass.value = s.bass;
    elements.muffle.value = s.muffle;
    elements.echo.value = s.echo;
    elements.bitcrush.value = s.bitcrush;
    elements.preserve.checked = s.preserve;
    // Fire all input events to update labels + audio
    ['speed','pitch','reverb','bass','muffle','echo','bitcrush'].forEach(function(id) {
      document.getElementById(id).dispatchEvent(new Event('input'));
    });
  }

  function renderQueue() {
    if (queue.length === 0) {
      elements.queueList.innerHTML = '<div class="queueEmpty" id="queueEmpty">No songs yet. Click "+ Add file"!</div>';
      elements.prevBtn.style.opacity = '0.3';
      elements.nextBtn.style.opacity = '0.3';
      return;
    }

    elements.queueList.innerHTML = '';
    queue.forEach(function(track, i) {
      const row = document.createElement('div');
      row.className = 'queueRow' + (i === queueIndex ? ' active' : '');
      row.innerHTML =
        '<span class="queueIdx">' + (i === queueIndex ? '‚ñ∂' : (i + 1)) + '</span>' +
        '<span class="queueName" title="' + track.name + '">' + track.name + '</span>' +
        '<span class="queueDur">' + formatTime(track.duration) + '</span>' +
        '<button class="queueDel" onclick="removeFromQueue(' + i + ')" title="Remove">‚úï</button>';
      row.addEventListener('click', function(e) {
        if (e.target.classList.contains('queueDel')) return;
        loadQueueTrack(i);
      });
      elements.queueList.appendChild(row);
    });

    // Scroll active item into view
    const activeRow = elements.queueList.querySelector('.active');
    if (activeRow) activeRow.scrollIntoView({ block: 'nearest' });

    elements.prevBtn.style.opacity = queueIndex > 0 ? '1' : '0.3';
    elements.nextBtn.style.opacity = (queueIndex < queue.length - 1 || elements.repeatQueueToggle.checked) ? '1' : '0.3';
  }

  async function loadQueueTrack(index) {
    if (index < 0 || index >= queue.length) return;

    // Stop current playback
    if (sourceNode) {
      try { sourceNode.stop(); } catch (e) {}
      sourceNode.disconnect();
    }
    if (animationFrame) {
      cancelAnimationFrame(animationFrame);
      animationFrame = null;
    }
    isPlaying = false;
    elements.playBtn.textContent = '‚ñ∂';
    currentTime = 0;

    const track = queue[index];
    queueIndex = index;

    setStatus('Loading: ' + track.name);

    try {
      // Clone the buffer so it can be decoded again
      const bufferCopy = track.arrayBuffer.slice(0);
      audioBuffer = await audioContext.decodeAudioData(bufferCopy);

      // Apply this track's per-file settings
      applyTrackSettings(track.settings);

      updateMuffleFilter();
      updateEchoEffect();
      updateBitcrushEffect();
      updateGain();

      createAudioSource();
      elements.currentName.textContent = track.name;
      drawWaveform(audioBuffer);

      elements.tStart.textContent = '0:00';
      elements.tEnd.textContent = formatTime(audioBuffer.duration);
      elements.durTime.textContent = formatTime(audioBuffer.duration);

      elements.seek.value = 0;
      elements.seek.max = audioBuffer.duration;
      updateProgressIndicator();

      elements.downloadBtn.disabled = false;
      elements.trimBtn.disabled = false;
      elements.exportFormat.disabled = false;

      setStatus('Ready ‚Äî ' + track.name);
      renderQueue();

      // Auto-play
      if (audioContext.state === 'suspended') audioContext.resume();
      createAudioSource();
      startOffset = 0;
      sourceNode.start(0, 0);
      lastPlayTime = audioContext.currentTime;
      isPlaying = true;
      elements.playBtn.textContent = '‚è∏';
      updateTimeDisplay();

    } catch (err) {
      console.error('Queue load error:', err);
      setStatus('Failed to load: ' + track.name);
    }
  }

  // Hook into existing onended to auto-advance
  function createAudioSource() {
    if (!audioBuffer) return;

    if (sourceNode) {
      try { sourceNode.stop(); } catch (e) {}
      sourceNode.disconnect();
    }

    sourceNode = audioContext.createBufferSource();
    sourceNode.buffer = audioBuffer;
    sourceNode.loop = isLooping;

    const speedMultiplier = parseFloat(elements.speed.value);
    sourceNode.playbackRate.value = speedMultiplier;

    sourceNode.connect(nodes.muffle);

    sourceNode.onended = function() {
      if (!isLooping) {
        if (isPlaying && elements.autoplayToggle.checked && queue.length > 0 && queueIndex >= 0) {
          // Auto-advance
          let nextIdx = queueIndex + 1;
          if (nextIdx >= queue.length) {
            if (elements.repeatQueueToggle.checked) {
              nextIdx = 0;
            } else {
              isPlaying = false;
              elements.playBtn.textContent = '‚ñ∂';
              if (animationFrame) { cancelAnimationFrame(animationFrame); animationFrame = null; }
              setStatus('Queue finished');
              return;
            }
          }
          loadQueueTrack(nextIdx);
        } else if (isPlaying) {
          isPlaying = false;
          elements.playBtn.textContent = '‚ñ∂';
          if (animationFrame) { cancelAnimationFrame(animationFrame); animationFrame = null; }
        }
      }
    };
  }

  window.removeFromQueue = function(i) {
    queue.splice(i, 1);
    if (queueIndex === i) {
      queueIndex = -1;
    } else if (queueIndex > i) {
      queueIndex--;
    }
    renderQueue();
    setStatus('Removed from queue');
  };

  elements.queueFileInput.onchange = async function(e) {
    const files = Array.from(e.target.files);
    if (!files.length) return;

    setStatus('Adding ' + files.length + ' song(s) to queue...');

    for (const file of files) {
      try {
        const arrayBuffer = await file.arrayBuffer();
        // Decode just to get duration, then store raw buffer
        const tempCtx = new OfflineAudioContext(1, 1, 44100);
        const tempBuf = await audioContext.decodeAudioData(arrayBuffer.slice(0));
        queue.push({ name: file.name, arrayBuffer: arrayBuffer, duration: tempBuf.duration, settings: defaultSettings() });
      } catch (err) {
        console.warn('Could not read:', file.name, err);
      }
    }

    renderQueue();
    setStatus(files.length + ' song(s) added to queue');

    // If nothing is currently loaded, auto-load the first track
    if (!audioBuffer && queue.length > 0 && queueIndex === -1) {
      loadQueueTrack(0);
    }

    e.target.value = '';
  };

  elements.clearQueueBtn.onclick = function() {
    if (queue.length === 0) return;
    if (!confirm('Clear the entire queue?')) return;
    queue = [];
    queueIndex = -1;
    renderQueue();
    setStatus('Queue cleared');
  };

  elements.shuffleBtn.onclick = function() {
    if (queue.length < 2) return;
    // Fisher-Yates shuffle
    for (let i = queue.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [queue[i], queue[j]] = [queue[j], queue[i]];
    }
    // Reset index to currently playing song (find it by name match if active)
    queueIndex = -1;
    renderQueue();
    setStatus('Queue shuffled!');
  };


  elements.prevBtn.onclick = function() {
    if (queue.length === 0) return;
    const prevIdx = queueIndex > 0 ? queueIndex - 1 : (elements.repeatQueueToggle.checked ? queue.length - 1 : 0);
    loadQueueTrack(prevIdx);
  };

  elements.nextBtn.onclick = function() {
    if (queue.length === 0) return;
    let nextIdx = queueIndex + 1;
    if (nextIdx >= queue.length) {
      if (elements.repeatQueueToggle.checked) nextIdx = 0;
      else return;
    }
    loadQueueTrack(nextIdx);
  };

  // When user loads a file via the normal "Add file" button, add to queue too
  const _origFileChange = elements.fileInput.onchange;
  elements.fileInput.onchange = async function(e) {
    await _origFileChange.call(this, e);
    // Also push to queue so next/prev works
    const file = e.target.files[0];
    if (file && audioBuffer) {
      // Re-read to get a fresh arraybuffer for the queue
      const ab = await file.arrayBuffer();
      queue.push({ name: file.name, arrayBuffer: ab, duration: audioBuffer.duration, settings: defaultSettings() });
      queueIndex = queue.length - 1;
      renderQueue();
    }
  };

  // Initial render
  renderQueue();

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // END ALBUM / QUEUE SYSTEM
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  // Load presets on init
  loadPresetsFromStorage();

  console.log('Audio Editor initialized successfully!');

} catch (error) {
  console.error('Error initializing audio tool:', error);
  document.getElementById('status').textContent = 'Error: ' + error.message;
}
</script>
</body>
</html>
