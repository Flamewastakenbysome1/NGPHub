<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>NGP Hub ‚Äî Audio Remix (Beta)</title>

<link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500;700&display=swap" rel="stylesheet" />
<link rel="icon" href="/assets/ngp-logo.png" type="image/png">
<style>
  :root{
    --bg:#0e0e11; --card:#15151b; --ink:#ececf1; --muted:#b5b7c3;
    --brandA:#6a11cb; --brandB:#2575fc; --line:#3a66ff;
    --ring:0 0 0 .2rem rgba(37,117,252,.35);
    --radius:16px; --shadow:0 10px 30px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:linear-gradient(180deg,#0b0b0e,#121219 60%,#0d0d14);
    color:var(--ink); font-family:'Rubik',system-ui,-apple-system,Segoe UI,Roboto,Arial,Helvetica,sans-serif;
    -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility; scroll-behavior:smooth;
  }
  .wrap{max-width:1024px; margin:0 auto; padding:0 16px}

  header{position:sticky; top:0; z-index:50; backdrop-filter:saturate(140%) blur(10px);
    background:rgba(10,10,14,.6); border-bottom:1px solid rgba(255,255,255,.06)}
  .bar{display:flex; align-items:center; justify-content:space-between; padding:12px 0}
  .logo{display:flex; align-items:center; gap:10px; text-decoration:none; color:var(--ink)}
  .logo-mark{width:28px; height:28px; border-radius:10px; background:linear-gradient(135deg,var(--brandA),var(--brandB)); box-shadow:var(--shadow)}
  .logo-img{width:28px; height:28px; border-radius:10px; object-fit:contain; box-shadow:var(--shadow)}
  .logo h1{font-size:1.05rem; margin:0; letter-spacing:.3px}
  nav{display:flex; align-items:center; gap:6px; flex-wrap:wrap}
  nav a{color:var(--ink); text-decoration:none; font-weight:500; padding:8px 10px; border-radius:10px; opacity:.9}
  nav a:hover, nav a:focus-visible{background:rgba(255,255,255,.06); outline:none; box-shadow:var(--ring)}

  footer{border-top:1px solid rgba(255,255,255,.08); color:var(--muted); padding:24px 0 36px; text-align:center}

  main{padding:28px 0 40px}
  .grid{display:grid; grid-template-columns:320px 1fr; gap:24px}
  .panel{background:var(--card); border:1px solid rgba(255,255,255,.06); border-radius:var(--radius); box-shadow:var(--shadow); overflow:hidden}
  .panel h2{margin:0; padding:14px 16px; border-bottom:1px solid rgba(255,255,255,.06); font-size:1rem}
  .list{max-height:420px; overflow:auto}
  .fileRow{display:flex; align-items:center; justify-content:space-between; gap:8px; padding:12px 14px; border-bottom:1px solid rgba(255,255,255,.05)}
  .fileRow.muted{color:var(--muted)}
  .fileTitle{font-weight:600}
  .fileMeta{color:var(--muted); font-size:.85rem}
  .controls{padding:16px}
  .knob{margin:14px 0}
  .knob label{display:flex; align-items:center; justify-content:space-between; font-weight:600; margin-bottom:8px}
  .knob small{color:var(--muted); margin-left:8px; font-weight:400}
  input[type="range"]{width:100%}
  .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .btn{background:linear-gradient(135deg,var(--brandA),var(--brandB)); color:#fff; border:none; border-radius:12px; padding:10px 14px; font-weight:700; cursor:pointer; box-shadow:var(--shadow)}
  .btn:disabled{opacity:.5; cursor:not-allowed}
  .btnGhost{background:transparent; color:var(--ink); border:1px solid rgba(255,255,255,.2); border-radius:12px; padding:9px 12px; font-weight:600; cursor:pointer}
  .pill{background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12); padding:6px 10px; border-radius:999px; user-select:none; cursor:pointer}
  
  .wave-container{position:relative; height:140px}
  .wave{height:140px; background:repeating-linear-gradient(90deg,rgba(255,255,255,.06) 0 1px, transparent 1px 4px), radial-gradient(ellipse at center, rgba(106,17,203,.2), transparent 60%); position:relative}
  .progress-indicator{position:absolute; top:0; bottom:0; width:2px; background:var(--brandB); z-index:10; transform:translateX(-50%); opacity:.8; box-shadow: 0 0 8px rgba(37,117,252,.6)}
  
  .timeline{display:flex; justify-content:space-between; font-size:.85rem; color:var(--muted); padding:6px 10px 0}
  .playerBar{position:sticky; bottom:0; left:0; right:0; background:rgba(10,10,14,.8); backdrop-filter:saturate(140%) blur(10px); border-top:1px solid rgba(255,255,255,.08)}
  .playerInner{max-width:1024px; margin:0 auto; padding:10px 16px; display:flex; align-items:center; gap:10px}
  .play{width:42px; height:42px; border-radius:999px; display:grid; place-items:center; border:1px solid rgba(255,255,255,.25); background:rgba(255,255,255,.06); cursor:pointer}
  .time{min-width:64px; text-align:center; font-variant-numeric:tabular-nums}
  .grow{flex:1}
  .muted{color:var(--muted)}
  .tag{font-size:.75rem; padding:3px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.18); color:#cbd5ff; cursor:pointer}
  .unlockWrap{display:none; align-items:center; gap:8px}
  .unlockWrap label{font-size:.85rem; color:var(--muted)}

  /* Floating Gain (outside) */
  .gainFloat{
    position:fixed; right:10px; top:140px; z-index:60; display:flex; flex-direction:column; align-items:center; gap:6px;
    padding:10px 8px; border-radius:14px; background:rgba(21,21,27,.85); border:1px solid rgba(255,255,255,.09); box-shadow:var(--shadow);
    backdrop-filter: blur(8px) saturate(140%);
  }
  .gainFloat .cap{font-size:.7rem; color:var(--muted)}
  .gainFloat input[type="range"]{
    writing-mode: bt-lr; -webkit-appearance: slider-vertical; appearance: slider-vertical;
    width: 44px; height: 260px;
  }
  .gainBadge{font-size:.75rem; padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.2); background:rgba(255,255,255,.06)}

  /* Disclaimer */
  .disclaimer{
    background:rgba(255,69,0,.1); border:1px solid rgba(255,69,0,.3); border-radius:12px; padding:12px;
    margin:16px 0; color:#ffb3b3; font-size:.85rem; line-height:1.4;
  }
  .disclaimer strong{color:#ff6b6b}

  /* Progress bar styling */
  .progress-bar{
    width:100%; height:4px; background:rgba(255,255,255,.1); border-radius:2px; margin:8px 0;
  }
  .progress-fill{
    height:100%; background:linear-gradient(90deg,var(--brandA),var(--brandB)); border-radius:2px;
    transition:width .1s ease; width:0%;
  }

  @media (max-width:920px){ .grid{grid-template-columns:1fr} .gainFloat{display:none} }
  @media (prefers-reduced-motion: reduce){*{transition:none !important; animation:none !important}}
</style>
</head>
<body>
<header>
  <div class="wrap bar">
    <a class="logo" href="/">
      <img src="/assets/ngp-logo.png" alt="NGP Logo" class="logo-img" />
      <h1>NGP</h1>
    </a>
    <nav aria-label="Primary">
      <a href="/tools">Tools</a><a href="/discordservers/">Servers</a><a href="/projects">Projects</a>
      <a href="/docs/">Docs</a><a href="/roblox">Roblox</a><a href="/contact">Contact</a>
    </nav>
  </div>
</header>

<main>
  <div class="wrap">
    <!-- Disclaimer -->
    <div class="disclaimer">
      <strong>‚ö†Ô∏è Disclaimer:</strong> NGP is not responsible for any injuries, hearing damage, or other harm that may occur from using this audio remix tool. Please use reasonable volume levels and take breaks when using audio equipment. Use at your own risk.
    </div>

    <div class="row" style="margin-bottom:6px; justify-content:space-between;">
      <div class="row">
        <button id="addBtn" class="btnGhost">+ Add file</button>
        <button id="clearBtn" class="btnGhost">‚úï Clear</button>
      </div>

      <div style="display:flex; flex-direction:column; align-items:flex-end; gap:6px">
        <div class="unlockWrap" id="unlockWrap">
          <input type="checkbox" id="unlockBox" />
          <label for="unlockBox">Extra range</label>
        </div>
        <span class="tag" id="freeTag">No need to pay, straight from the browser!</span>
      </div>
    </div>

    <div class="grid">
      <!-- Files -->
      <section class="panel" aria-label="Files">
        <h2>Files</h2>
        <div class="list" id="fileList">
          <div class="fileRow muted">No file yet. Click "Add file".</div>
        </div>
      </section>

      <!-- Editor -->
      <section class="panel" aria-label="Editor">
        <h2 id="currentName">‚Äî</h2>
        <div class="wave-container">
          <div class="wave" id="wave"></div>
          <div class="progress-indicator" id="progressIndicator" style="left:0%"></div>
        </div>
        <div class="timeline"><span id="tStart">0:00</span><span id="tEnd">0:00</span></div>

        <div class="controls">
          <div class="row" style="gap:12px;">
            <span class="pill">Presets</span>
            <button class="btnGhost" data-preset="slowed">Slowed+Reverb</button>
            <button class="btnGhost" data-preset="nightcore">Nightcore</button>
            <button class="btnGhost" data-preset="perfection">Slowed to Perfection</button>
          </div>

          <div class="knob">
            <label>Speed <small id="speedLbl">(1.00√ó)</small></label>
            <input type="range" id="speed" min="0.5" max="1.5" step="0.01" value="1.0" />
            <div class="row" style="margin-top:6px;">
              <input type="checkbox" id="preserve" />
              <label for="preserve" class="muted">Keep original pitch when changing speed</label>
            </div>
          </div>

          <div class="knob">
            <label>Pitch <small id="pitchLbl">(0 semitones)</small></label>
            <input type="range" id="pitch" min="-12" max="12" step="0.1" value="0" />
            <div class="row" style="margin-top:4px;">
              <small class="muted">Note: Pitch changes only apply to downloaded files, not live preview</small>
            </div>
          </div>

          <div class="knob">
            <label>Reverb <small id="reverbLbl">(0%)</small></label>
            <input type="range" id="reverb" min="0" max="100" step="1" value="0" />
          </div>

          <div class="knob">
            <label>Bass Boost <small id="bassLbl">(0 dB)</small></label>
            <input type="range" id="bass" min="0" max="18" step="0.5" value="0" />
          </div>

          <div class="knob">
            <label>Muffle <small id="muffleLbl">(0%)</small></label>
            <input type="range" id="muffle" min="0" max="100" step="1" value="0" />
          </div>

          <div class="knob">
            <label>Echo <small id="echoLbl">(0%)</small></label>
            <input type="range" id="echo" min="0" max="100" step="1" value="0" />
          </div>

          <div class="row" style="margin-top:8px;">
            <button id="exportBtn" class="btn">‚¨á Download</button>
            <button id="resetBtn" class="btnGhost">Reset all</button>
          </div>

          <div class="progress-bar" id="renderProgress" style="display:none">
            <div class="progress-fill" id="renderProgressFill"></div>
          </div>
          <div id="status" class="muted" style="margin-top:6px; font-size:.85rem"></div>
        </div>
      </section>
    </div>
  </div>
</main>

<!-- Floating Gain -->
<aside class="gainFloat">
  <div class="cap">GAIN</div>
  <input type="range" id="gainSlider" min="-24" max="24" step="0.5" value="0" />
  <div class="gainBadge" id="gainBadge">0 dB</div>
</aside>

<!-- Playback bar -->
<div class="playerBar">
  <div class="playerInner">
    <div class="play" id="playBtn" aria-label="Play/Pause">‚ñ∂</div>
    <div class="time" id="timeDisplay">0:00</div>
    <div class="grow"></div>
    <div class="muted" style="font-size:.85rem">Volume:</div>
    <input type="range" id="volume" min="0" max="100" step="1" value="70" style="width:120px" />
    <span class="muted" id="volumeDisplay">70%</span>
  </div>
</div>

<footer>
  <div class="wrap">
    <p>NGP Hub ¬© 2025 ‚Äî Audio Remix (Beta) ‚Äî All processing happens in your browser üîí</p>
  </div>
</footer>

<script>
try {
  const elements = {
    addBtn: document.getElementById('addBtn'),
    clearBtn: document.getElementById('clearBtn'),
    fileList: document.getElementById('fileList'),
    currentName: document.getElementById('currentName'),
    wave: document.getElementById('wave'),
    progressIndicator: document.getElementById('progressIndicator'),
    tStart: document.getElementById('tStart'),
    tEnd: document.getElementById('tEnd'),
    speed: document.getElementById('speed'),
    speedLbl: document.getElementById('speedLbl'),
    preserve: document.getElementById('preserve'),
    pitch: document.getElementById('pitch'),
    pitchLbl: document.getElementById('pitchLbl'),
    reverb: document.getElementById('reverb'),
    reverbLbl: document.getElementById('reverbLbl'),
    bass: document.getElementById('bass'),
    bassLbl: document.getElementById('bassLbl'),
    muffle: document.getElementById('muffle'),
    muffleLbl: document.getElementById('muffleLbl'),
    echo: document.getElementById('echo'),
    echoLbl: document.getElementById('echoLbl'),
    gainSlider: document.getElementById('gainSlider'),
    gainBadge: document.getElementById('gainBadge'),
    exportBtn: document.getElementById('exportBtn'),
    resetBtn: document.getElementById('resetBtn'),
    playBtn: document.getElementById('playBtn'),
    timeDisplay: document.getElementById('timeDisplay'),
    volume: document.getElementById('volume'),
    volumeDisplay: document.getElementById('volumeDisplay'),
    status: document.getElementById('status'),
    renderProgress: document.getElementById('renderProgress'),
    renderProgressFill: document.getElementById('renderProgressFill'),
    freeTag: document.getElementById('freeTag'),
    unlockWrap: document.getElementById('unlockWrap'),
    unlockBox: document.getElementById('unlockBox')
  };

  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  let audioBuffer = null;
  let sourceNode = null;
  let gainNode = null;
  let filterNode = null;
  let delayNode = null;
  let feedbackNode = null;
  let echoWetNode = null;
  let isPlaying = false;
  let startTime = 0;
  let pauseTime = 0;
  let currentFile = null;
  let animationFrameId = null;

  let fileInput = document.createElement('input');
  fileInput.type = 'file';
  fileInput.accept = 'audio/*';
  fileInput.multiple = true;

  const files = [];

  // Add file button
  elements.addBtn.addEventListener('click', () => fileInput.click());

  fileInput.addEventListener('change', async function(e) {
    const newFiles = Array.from(e.target.files);
    for (let f of newFiles) {
      if (!files.find(x => x.name === f.name && x.size === f.size)) {
        files.push(f);
      }
    }
    renderFileList();
    if (!currentFile && files.length > 0) {
      await loadFile(files[0]);
    }
    fileInput.value = '';
  });

  // Clear button
  elements.clearBtn.addEventListener('click', function() {
    stop();
    files.length = 0;
    currentFile = null;
    audioBuffer = null;
    renderFileList();
    elements.currentName.textContent = '‚Äî';
    elements.tEnd.textContent = '0:00';
    clearWaveform();
  });

  function renderFileList() {
    if (files.length === 0) {
      elements.fileList.innerHTML = '<div class="fileRow muted">No file yet. Click "Add file".</div>';
      return;
    }
    elements.fileList.innerHTML = files.map((f, i) => {
      const size = (f.size / 1024 / 1024).toFixed(2) + ' MB';
      const active = currentFile === f ? ' style="background:rgba(255,255,255,.04)"' : '';
      return `<div class="fileRow" data-index="${i}"${active}>
        <div><div class="fileTitle">${escapeHtml(f.name)}</div><div class="fileMeta">${size}</div></div>
        <button class="btnGhost" style="padding:6px 10px" onclick="selectFile(${i})">Load</button>
      </div>`;
    }).join('');
  }

  window.selectFile = async function(index) {
    const f = files[index];
    if (f) await loadFile(f);
  };

  async function loadFile(file) {
    stop();
    try {
      elements.status.textContent = 'Loading...';
      currentFile = file;
      renderFileList();
      elements.currentName.textContent = file.name;

      const arrayBuffer = await file.arrayBuffer();
      audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);

      drawWaveform(audioBuffer);
      elements.tEnd.textContent = formatTime(audioBuffer.duration);
      elements.status.textContent = 'Ready';
    } catch (err) {
      console.error('Load error:', err);
      elements.status.textContent = 'Error loading file';
    }
  }

  function escapeHtml(text) {
    const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
    return text.replace(/[&<>"']/g, m => map[m]);
  }

  function formatTime(seconds) {
    const m = Math.floor(seconds / 60);
    const s = Math.floor(seconds % 60);
    return m + ':' + (s < 10 ? '0' : '') + s;
  }

  function drawWaveform(buffer) {
    if (!buffer) {
      clearWaveform();
      return;
    }
    const canvas = document.createElement('canvas');
    const rect = elements.wave.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    const ctx = canvas.getContext('2d');

    const data = buffer.getChannelData(0);
    const step = Math.ceil(data.length / canvas.width);
    const amp = canvas.height / 2;

    ctx.fillStyle = 'rgba(106,17,203,0.15)';
    ctx.strokeStyle = 'rgba(37,117,252,0.7)';
    ctx.lineWidth = 1.5;

    ctx.beginPath();
    ctx.moveTo(0, amp);
    for (let i = 0; i < canvas.width; i++) {
      let min = 1.0;
      let max = -1.0;
      for (let j = 0; j < step; j++) {
        const datum = data[i * step + j] || 0;
        if (datum < min) min = datum;
        if (datum > max) max = datum;
      }
      const yMin = (1 + min) * amp;
      const yMax = (1 + max) * amp;
      if (i === 0) {
        ctx.moveTo(i, yMin);
      }
      ctx.lineTo(i, yMin);
      ctx.lineTo(i, yMax);
    }
    ctx.lineTo(canvas.width, amp);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    elements.wave.innerHTML = '';
    elements.wave.appendChild(canvas);
  }

  function clearWaveform() {
    elements.wave.innerHTML = '';
  }

  // Playback controls
  elements.playBtn.addEventListener('click', togglePlayback);

  function togglePlayback() {
    if (!audioBuffer) return;
    if (isPlaying) {
      pause();
    } else {
      play();
    }
  }

  function play() {
    if (audioCtx.state === 'suspended') {
      audioCtx.resume();
    }

    const speed = parseFloat(elements.speed.value);
    const preservePitch = elements.preserve.checked;

    sourceNode = audioCtx.createBufferSource();
    sourceNode.buffer = audioBuffer;
    sourceNode.playbackRate.value = speed;
    if (typeof sourceNode.preservesPitch !== 'undefined') {
      sourceNode.preservesPitch = preservePitch;
    } else if (typeof sourceNode.detune !== 'undefined' && !preservePitch) {
      // Fallback
    }

    gainNode = audioCtx.createGain();
    gainNode.gain.value = parseFloat(elements.volume.value) / 100;

    filterNode = audioCtx.createBiquadFilter();
    filterNode.type = 'lowpass';
    updateMuffleFilter();

    delayNode = audioCtx.createDelay(2.0);
    feedbackNode = audioCtx.createGain();
    echoWetNode = audioCtx.createGain();
    updateEchoEffect();

    sourceNode.connect(filterNode);
    filterNode.connect(gainNode);
    filterNode.connect(delayNode);
    delayNode.connect(feedbackNode);
    feedbackNode.connect(delayNode);
    delayNode.connect(echoWetNode);
    gainNode.connect(audioCtx.destination);
    echoWetNode.connect(audioCtx.destination);

    sourceNode.onended = () => {
      if (isPlaying) stop();
    };

    startTime = audioCtx.currentTime - pauseTime;
    sourceNode.start(0, pauseTime);
    isPlaying = true;
    elements.playBtn.textContent = '‚è∏';
    updateProgressLoop();
  }

  function pause() {
    if (sourceNode) {
      sourceNode.stop();
      sourceNode = null;
    }
    pauseTime = audioCtx.currentTime - startTime;
    isPlaying = false;
    elements.playBtn.textContent = '‚ñ∂';
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
    }
  }

  function stop() {
    if (sourceNode) {
      sourceNode.stop();
      sourceNode = null;
    }
    isPlaying = false;
    pauseTime = 0;
    startTime = 0;
    elements.playBtn.textContent = '‚ñ∂';
    elements.timeDisplay.textContent = '0:00';
    elements.progressIndicator.style.left = '0%';
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
    }
  }

  function updateProgressLoop() {
    if (!isPlaying || !audioBuffer) return;
    const elapsed = audioCtx.currentTime - startTime;
    const duration = audioBuffer.duration;
    const progress = Math.min(elapsed / duration, 1);
    elements.progressIndicator.style.left = (progress * 100) + '%';
    elements.timeDisplay.textContent = formatTime(elapsed);
    animationFrameId = requestAnimationFrame(updateProgressLoop);
  }

  // Volume
  elements.volume.addEventListener('input', function() {
    elements.volumeDisplay.textContent = this.value + '%';
    if (gainNode) {
      gainNode.gain.value = parseFloat(this.value) / 100;
    }
  });

  // Muffle filter
  function updateMuffleFilter() {
    if (!filterNode) return;
    const muffleVal = parseFloat(elements.muffle.value);
    const unlocked = elements.unlockBox.checked;
    const maxMuffle = unlocked ? 200 : 100;
    const freq = Math.max(100, 20000 - (muffleVal / maxMuffle) * 19900);
    filterNode.frequency.value = freq;
  }

  elements.muffle.addEventListener('input', function() {
    elements.muffleLbl.textContent = `(${this.value}%)`;
    updateMuffleFilter();
  });

  // Echo effect
  function updateEchoEffect() {
    if (!delayNode || !feedbackNode || !echoWetNode) return;
    const echoVal = parseFloat(elements.echo.value);
    const unlocked = elements.unlockBox.checked;
    const maxEcho = unlocked ? 200 : 100;
    const echoRange = Math.max(0, Math.min(unlocked ? 2 : 1, echoVal / maxEcho));
    delayNode.delayTime.value = Math.min(2.0, 0.08 + (unlocked ? 1.2 : 0.42) * echoRange);
    feedbackNode.gain.value = Math.min(0.95, (unlocked ? 0.95 : 0.85) * echoRange);
    echoWetNode.gain.value = Math.min(1.2, (unlocked ? 1.2 : 0.8) * echoRange);
  }

  elements.echo.addEventListener('input', function() {
    elements.echoLbl.textContent = `(${this.value}%)`;
    updateEchoEffect();
  });

  // Other sliders
  elements.speed.addEventListener('input', function() {
    elements.speedLbl.textContent = `(${parseFloat(this.value).toFixed(2)}√ó)`;
    if (isPlaying && sourceNode) {
      sourceNode.playbackRate.value = parseFloat(this.value);
    }
  });

  elements.pitch.addEventListener('input', function() {
    elements.pitchLbl.textContent = `(${parseFloat(this.value).toFixed(1)} semitones)`;
  });

  elements.reverb.addEventListener('input', function() {
    elements.reverbLbl.textContent = `(${this.value}%)`;
  });

  elements.bass.addEventListener('input', function() {
    elements.bassLbl.textContent = `(${parseFloat(this.value).toFixed(1)} dB)`;
  });

  elements.gainSlider.addEventListener('input', function() {
    elements.gainBadge.textContent = `${parseFloat(this.value).toFixed(1)} dB`;
  });

  elements.preserve.addEventListener('change', function() {
    if (isPlaying && sourceNode && typeof sourceNode.preservesPitch !== 'undefined') {
      sourceNode.preservesPitch = this.checked;
    }
  });

  // Reset button
  elements.resetBtn.addEventListener('click', function() {
    elements.speed.value = 1.0;
    elements.pitch.value = 0;
    elements.reverb.value = 0;
    elements.bass.value = 0;
    elements.muffle.value = 0;
    elements.echo.value = 0;
    elements.gainSlider.value = 0;
    elements.preserve.checked = false;
    elements.speedLbl.textContent = '(1.00√ó)';
    elements.pitchLbl.textContent = '(0 semitones)';
    elements.reverbLbl.textContent = '(0%)';
    elements.bassLbl.textContent = '(0 dB)';
    elements.muffleLbl.textContent = '(0%)';
    elements.echoLbl.textContent = '(0%)';
    elements.gainBadge.textContent = '0 dB';
    updateMuffleFilter();
    updateEchoEffect();
  });

  // Presets
  document.querySelectorAll('[data-preset]').forEach(btn => {
    btn.addEventListener('click', function() {
      const preset = this.dataset.preset;
      if (preset === 'slowed') {
        elements.speed.value = 0.8;
        elements.reverb.value = 45;
        elements.bass.value = 6;
        elements.muffle.value = 0;
        elements.echo.value = 0;
        elements.pitch.value = 0;
      } else if (preset === 'nightcore') {
        elements.speed.value = 1.25;
        elements.pitch.value = 3;
        elements.reverb.value = 10;
        elements.bass.value = 2;
        elements.muffle.value = 0;
        elements.echo.value = 0;
      } else if (preset === 'perfection') {
        elements.speed.value = 0.75;
        elements.reverb.value = 60;
        elements.bass.value = 8;
        elements.muffle.value = 15;
        elements.echo.value = 20;
        elements.pitch.value = -2;
      }
      elements.speedLbl.textContent = `(${parseFloat(elements.speed.value).toFixed(2)}√ó)`;
      elements.pitchLbl.textContent = `(${parseFloat(elements.pitch.value).toFixed(1)} semitones)`;
      elements.reverbLbl.textContent = `(${elements.reverb.value}%)`;
      elements.bassLbl.textContent = `(${parseFloat(elements.bass.value).toFixed(1)} dB)`;
      elements.muffleLbl.textContent = `(${elements.muffle.value}%)`;
      elements.echoLbl.textContent = `(${elements.echo.value}%)`;
      updateMuffleFilter();
      updateEchoEffect();
    });
  });

  // Export
  elements.exportBtn.addEventListener('click', async function() {
    if (!audioBuffer) {
      alert('No audio loaded');
      return;
    }

    stop();
    elements.exportBtn.disabled = true;
    elements.status.textContent = 'Rendering...';
    elements.renderProgress.style.display = 'block';
    elements.renderProgressFill.style.width = '0%';

    try {
      const params = {
        speed: parseFloat(elements.speed.value),
        pitch: parseFloat(elements.pitch.value),
        reverb: parseFloat(elements.reverb.value),
        bass: parseFloat(elements.bass.value),
        muffle: parseFloat(elements.muffle.value),
        echo: parseFloat(elements.echo.value),
        gain: parseFloat(elements.gainSlider.value),
        isUnlocked: elements.unlockBox.checked
      };

      const processed = await processAudioOffline(audioBuffer, params);
      elements.renderProgressFill.style.width = '100%';

      const wav = audioBufferToWav(processed);
      const url = URL.createObjectURL(wav);
      const a = document.createElement('a');
      a.href = url;
      a.download = (currentFile ? currentFile.name.replace(/\.[^/.]+$/, '') : 'audio') + '_remixed.wav';
      a.click();
      URL.revokeObjectURL(url);

      elements.status.textContent = 'Download started!';
    } catch (err) {
      console.error('Export error:', err);
      elements.status.textContent = 'Error: ' + err.message;
    } finally {
      elements.exportBtn.disabled = false;
      setTimeout(() => {
        elements.renderProgress.style.display = 'none';
      }, 1500);
    }
  });

  function dbToLinear(db) {
    return Math.pow(10, db / 20);
  }

  async function processAudioOffline(buffer, params) {
    elements.renderProgressFill.style.width = '10%';
    
    let finalRate = buffer.sampleRate;
    let finalBuffer = buffer;

    // Pitch shifting using resampling
    if (params.pitch !== 0) {
      const pitchFactor = Math.pow(2, params.pitch / 12);
      finalRate = Math.round(buffer.sampleRate * pitchFactor);
      
      const tempCtx = new OfflineAudioContext(buffer.numberOfChannels, buffer.length, finalRate);
      const tempSource = tempCtx.createBufferSource();
      tempSource.buffer = buffer;
      tempSource.connect(tempCtx.destination);
      tempSource.start(0);
      finalBuffer = await tempCtx.startRendering();
      
      elements.renderProgressFill.style.width = '30%';
    }

    // Speed changing
    const newLength = Math.floor(finalBuffer.length / params.speed);
    const newDuration = newLength / finalBuffer.sampleRate;
    
    const offlineCtx = new OfflineAudioContext(
      finalBuffer.numberOfChannels,
      newLength,
      finalBuffer.sampleRate
    );

    const source = offlineCtx.createBufferSource();
    source.buffer = finalBuffer;
    source.playbackRate.value = params.speed;
    
    elements.renderProgressFill.style.width = '50%';
    
    // Create nodes - only the ones we need
    let currentNode = source;
    
    // Muffle filter - ONLY if muffle > 0
    let muffle = null;
    if (params.muffle > 0) {
      muffle = offlineCtx.createBiquadFilter();
      muffle.type = 'lowpass';
      muffle.frequency.value = Math.max(100, 20000 - (params.muffle / 100) * 19900);
      currentNode.connect(muffle);
      currentNode = muffle;
    }
    
    // Reverb - ONLY if reverb > 0
    let conv = null;
    if (params.reverb > 0) {
      conv = offlineCtx.createConvolver();
      const reverbAmount = Math.max(0.001, params.reverb / 100);
      conv.buffer = createOfflineImpulseResponse(offlineCtx, 1.8 * reverbAmount + 0.05, 3 * reverbAmount + 0.5);
      currentNode.connect(conv);
      currentNode = conv;
    }
    
    // Bass EQ - ONLY if bass > 0
    let bassEQ = null;
    if (params.bass > 0) {
      bassEQ = offlineCtx.createBiquadFilter();
      bassEQ.type = 'lowshelf';
      bassEQ.frequency.value = 140;
      bassEQ.gain.value = params.bass;
      currentNode.connect(bassEQ);
      currentNode = bassEQ;
    }
    
    // Echo effect - ONLY if echo > 0
    let dryGain = offlineCtx.createGain();
    dryGain.gain.value = 1.0;
    
    currentNode.connect(dryGain);
    
    let delay = null;
    let feedback = null;
    let echoWet = null;
    
    if (params.echo > 0) {
      delay = offlineCtx.createDelay(2.0);
      feedback = offlineCtx.createGain();
      echoWet = offlineCtx.createGain();
      
      const echoRange = Math.max(0, Math.min(params.isUnlocked ? 2 : 1, params.echo / 100));
      delay.delayTime.value = Math.min(2.0, 0.08 + (params.isUnlocked ? 1.2 : 0.42) * echoRange);
      feedback.gain.value = Math.min(0.95, (params.isUnlocked ? 0.95 : 0.85) * echoRange);
      echoWet.gain.value = Math.min(1.2, (params.isUnlocked ? 1.2 : 0.8) * echoRange);
      
      currentNode.connect(delay);
      delay.connect(feedback);
      feedback.connect(delay);
      delay.connect(echoWet);
    }
    
    // Master gain
    const master = offlineCtx.createGain();
    master.gain.value = dbToLinear(params.gain);
    
    elements.renderProgressFill.style.width = '70%';
    
    // Connect to master
    dryGain.connect(master);
    if (echoWet) {
      echoWet.connect(master);
    }
    master.connect(offlineCtx.destination);
    
    source.start(0);
    
    elements.renderProgressFill.style.width = '90%';
    return await offlineCtx.startRendering();
  }

  function createHannWindow(size) {
    const window = new Float32Array(size);
    for (let i = 0; i < size; i++) {
      window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (size - 1)));
    }
    return window;
  }

  function createOfflineImpulseResponse(offlineCtx, seconds, decay) {
    seconds = seconds || 1.5;
    decay = decay || 2.5;
    const sampleRate = offlineCtx.sampleRate;
    const length = Math.max(1, Math.floor(seconds * sampleRate));
    const impulse = offlineCtx.createBuffer(2, length, sampleRate);
    
    for (let channel = 0; channel < 2; channel++) {
      const channelData = impulse.getChannelData(channel);
      for (let i = 0; i < length; i++) {
        const n = length - i;
        channelData[i] = (Math.random() * 2 - 1) * Math.pow(n / length, decay);
      }
    }
    return impulse;
  }

  // WAV export function
  function audioBufferToWav(buffer) {
    const length = buffer.length;
    const channels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    
    const arrayBuffer = new ArrayBuffer(44 + length * channels * 2);
    const view = new DataView(arrayBuffer);
    
    // WAV header
    function writeString(offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }
    
    writeString(0, 'RIFF');
    view.setUint32(4, 36 + length * channels * 2, true);
    writeString(8, 'WAVE');
    writeString(12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, channels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * channels * 2, true);
    view.setUint16(32, channels * 2, true);
    view.setUint16(34, 16, true);
    writeString(36, 'data');
    view.setUint32(40, length * channels * 2, true);
    
    // Convert float samples to 16-bit PCM
    const channelData = [];
    for (let c = 0; c < channels; c++) {
      channelData.push(buffer.getChannelData(c));
    }
    
    let offset = 44;
    for (let i = 0; i < length; i++) {
      for (let c = 0; c < channels; c++) {
        const sample = Math.max(-1, Math.min(1, channelData[c][i]));
        const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
        view.setInt16(offset, intSample, true);
        offset += 2;
      }
    }
    
    return new Blob([arrayBuffer], { type: 'audio/wav' });
  }

  // Secret unlock
  let secretClicks = 0;
  elements.freeTag.addEventListener('click', function() {
    secretClicks++;
    if (secretClicks >= 15) {
      elements.unlockWrap.style.display = 'flex';
      elements.freeTag.textContent = 'Extra features unlocked!';
      elements.freeTag.style.background = 'rgba(106,17,203,.2)';
    }
  });

  function setUnlockedRanges(unlocked) {
    if (unlocked) {
      elements.speed.min = '0.05';
      elements.speed.max = '4';
      elements.speed.step = '0.001';
      elements.pitch.min = '-24';
      elements.pitch.max = '24';
      elements.pitch.step = '0.05';
      elements.reverb.max = '300';
      elements.bass.min = '-24';
      elements.bass.max = '48';
      elements.gainSlider.min = '-48';
      elements.gainSlider.max = '48';
      elements.muffle.max = '200';
      elements.echo.max = '200';
    } else {
      elements.speed.min = '0.5';
      elements.speed.max = '1.5';
      elements.speed.step = '0.01';
      elements.pitch.min = '-12';
      elements.pitch.max = '12';
      elements.pitch.step = '0.1';
      elements.reverb.max = '100';
      elements.bass.min = '0';
      elements.bass.max = '18';
      elements.gainSlider.min = '-24';
      elements.gainSlider.max = '24';
      elements.muffle.max = '100';
      elements.echo.max = '100';
    }
    updateMuffleFilter();
    updateEchoEffect();
  }

  elements.unlockBox.addEventListener('change', function(e) {
    setUnlockedRanges(e.target.checked);
  });

  setUnlockedRanges(false);

  // Window resize handler for waveform
  new ResizeObserver(function() {
    drawWaveform(audioBuffer);
  }).observe(elements.wave);

  console.log('Audio Remix Tool initialized successfully!');

} catch (error) {
  console.error('Error initializing audio tool:', error);
  document.getElementById('status').textContent = 'Error: ' + error.message;
}
</script>
</body>
</html>
