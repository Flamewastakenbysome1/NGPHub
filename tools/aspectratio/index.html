<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pixel Grid Simulator with Microscope Vision</title>
  <style>
    body {
      background: #1a1a1a;
      color: #eee;
      font-family: monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      padding: 10px;
      user-select: none;
    }
    h2 { margin: 10px 0; font-size: 1.2em; }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; margin: 10px 0; align-items: center; }
    button, select { background: #333; color: #fff; border: 1px solid #555; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.9em; }
    input[type="number"] { width: 60px; background: #333; color: #fff; border: 1px solid #555; padding: 4px; }
    input[type="file"] { display: none; }
    #microscopeToggle.active { background: #33a; border-color: #88f; box-shadow: 0 0 8px #55f; }
    #container { border: 3px solid #000; background: #000; border-radius: 10px; position: relative; }
    canvas { background: #000; display: block; cursor: grab; }
    .info { color: #888; font-size: 0.85em; margin: 5px 0; }
  </style>
</head>
<body>
  <h2>Pixel Grid with Microscope Vision</h2>
  <div class="controls">
    <label>W: <input id="w" type="number" value="12" min="1" max="2000"></label>
    <label>H: <input id="h" type="number" value="8" min="1" max="2000"></label>
    <label>Size: <input id="pxsize" type="number" value="40" min="2" max="200"></label>
    <button onclick="drawGrid()">Draw</button>
    <label><input type="file" id="imgInput" accept="image/*"><button onclick="document.getElementById('imgInput').click()">Load Image</button></label>
    <select id="layoutChoice"><option value="lcd">LCD</option><option value="oled">OLED</option><option value="spectral">Spectral</option></select>
    <button id="microscopeToggle" onclick="toggleMicroscope()">ðŸ”¬ Microscope</button>
  </div>
  <div class="info" id="info">FPS: -- | Pixels: --</div>
  <div id="container"><canvas id="canvas" width="800" height="600"></canvas></div>
  
  <script>
    let W=12, H=8, pxSize=40, zoom=1, offX=0, offY=0, isPan=false, startPan={x:0,y:0}, startOff={x:0,y:0};
    let layout="lcd", microMode=false, imgPix=null, imgLoaded=false;
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let fps=0, lastT=0, frames=0;

    function resize() {
      canvas.width = Math.min(window.innerWidth-40, 1200);
      canvas.height = Math.min(window.innerHeight-200, 700);
      draw();
    }
    window.addEventListener('resize', resize);

    function drawGrid() {
      W = Math.max(1, parseInt(document.getElementById('w').value)||12);
      H = Math.max(1, parseInt(document.getElementById('h').value)||8);
      pxSize = Math.max(2, parseInt(document.getElementById('pxsize').value)||40);
      zoom=1; offX=offY=0; imgPix=null; imgLoaded=false;
      draw();
    }

    document.getElementById('layoutChoice').addEventListener('change', e => {
      layout = e.target.value;
      draw();
    });

    function toggleMicroscope() {
      microMode = !microMode;
      const btn = document.getElementById('microscopeToggle');
      if(microMode) {
        btn.classList.add('active');
        btn.textContent = 'ðŸ”¬ ON';
      } else {
        btn.classList.remove('active');
        btn.textContent = 'ðŸ”¬ Microscope';
      }
      draw();
    }

    function draw() {
      const now = performance.now();
      if(now - lastT >= 1000) {
        fps = Math.round(frames * 1000 / (now - lastT));
        frames = 0;
        lastT = now;
      }
      frames++;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      const size = pxSize * zoom;
      const xStart = Math.max(0, Math.floor(-offX / size));
      const yStart = Math.max(0, Math.floor(-offY / size));
      const xEnd = Math.min(W, Math.ceil((canvas.width - offX) / size));
      const yEnd = Math.min(H, Math.ceil((canvas.height - offY) / size));
      
      for(let y = yStart; y < yEnd; y++) {
        for(let x = xStart; x < xEnd; x++) {
          const px = offX + x * size;
          const py = offY + y * size;
          let r=255, g=255, b=255, a=255;
          if(imgLoaded && imgPix && imgPix[y] && imgPix[y][x]) {
            ({r,g,b,a} = imgPix[y][x]);
          }
          
          ctx.fillStyle = "#000";
          ctx.fillRect(px, py, size, size);
          
          if(layout === "lcd") {
            const x0 = Math.round(px);
            const x1 = Math.round(px + size/3);
            const x2 = Math.round(px + 2*size/3);
            const x3 = Math.round(px + size);
            
            ctx.fillStyle = `rgba(${r},0,0,${a/255})`;
            ctx.fillRect(x0, py, x1-x0, size);
            ctx.fillStyle = `rgba(0,${g},0,${a/255})`;
            ctx.fillRect(x1, py, x2-x1, size);
            ctx.fillStyle = `rgba(0,0,${b},${a/255})`;
            ctx.fillRect(x2, py, x3-x2, size);
            
            if(microMode && size > 5) {
              ctx.save();
              ctx.globalCompositeOperation = 'lighter';
              
              const rg = ctx.createRadialGradient(x0+(x1-x0)/2, py+size/2, 0, x0+(x1-x0)/2, py+size/2, size*0.7);
              rg.addColorStop(0, `rgba(${r},0,0,0.4)`);
              rg.addColorStop(1, 'rgba(255,0,0,0)');
              ctx.fillStyle = rg;
              ctx.fillRect(x0-size*0.3, py-size*0.3, (x1-x0)+size*0.6, size+size*0.6);
              
              const gg = ctx.createRadialGradient(x1+(x2-x1)/2, py+size/2, 0, x1+(x2-x1)/2, py+size/2, size*0.7);
              gg.addColorStop(0, `rgba(0,${g},0,0.4)`);
              gg.addColorStop(1, 'rgba(0,255,0,0)');
              ctx.fillStyle = gg;
              ctx.fillRect(x1-size*0.3, py-size*0.3, (x2-x1)+size*0.6, size+size*0.6);
              
              const bg = ctx.createRadialGradient(x2+(x3-x2)/2, py+size/2, 0, x2+(x3-x2)/2, py+size/2, size*0.7);
              bg.addColorStop(0, `rgba(0,0,${b},0.4)`);
              bg.addColorStop(1, 'rgba(0,0,255,0)');
              ctx.fillStyle = bg;
              ctx.fillRect(x2-size*0.3, py-size*0.3, (x3-x2)+size*0.6, size+size*0.6);
              
              ctx.restore();
            }
          } else if(layout === "oled") {
            const oddRow = y % 2;
            const rad = size/4.5;
            const dotY = py + size*0.5;
            
            if(oddRow === 0) {
              const rx = px + size*0.25;
              const gx = px + size*0.75;
              
              ctx.beginPath();
              ctx.arc(rx, dotY, rad, 0, 2*Math.PI);
              ctx.fillStyle = `rgba(${r},0,0,${a/255})`;
              ctx.fill();
              
              ctx.beginPath();
              ctx.arc(gx, dotY, rad, 0, 2*Math.PI);
              ctx.fillStyle = `rgba(0,${g},0,${a/255})`;
              ctx.fill();
              
              if(microMode && size > 5) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                const rg = ctx.createRadialGradient(rx, dotY, 0, rx, dotY, rad*2);
                rg.addColorStop(0, `rgba(${r},0,0,0.5)`);
                rg.addColorStop(1, 'rgba(255,0,0,0)');
                ctx.fillStyle = rg;
                ctx.fillRect(rx-rad*2, dotY-rad*2, rad*4, rad*4);
                
                const gg = ctx.createRadialGradient(gx, dotY, 0, gx, dotY, rad*2);
                gg.addColorStop(0, `rgba(0,${g},0,0.5)`);
                gg.addColorStop(1, 'rgba(0,255,0,0)');
                ctx.fillStyle = gg;
                ctx.fillRect(gx-rad*2, dotY-rad*2, rad*4, rad*4);
                ctx.restore();
              }
            } else {
              const gx = px + size*0.25;
              const bx = px + size*0.75;
              
              ctx.beginPath();
              ctx.arc(gx, dotY, rad, 0, 2*Math.PI);
              ctx.fillStyle = `rgba(0,${g},0,${a/255})`;
              ctx.fill();
              
              ctx.beginPath();
              ctx.arc(bx, dotY, rad, 0, 2*Math.PI);
              ctx.fillStyle = `rgba(0,0,${b},${a/255})`;
              ctx.fill();
              
              if(microMode && size > 5) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                const gg = ctx.createRadialGradient(gx, dotY, 0, gx, dotY, rad*2);
                gg.addColorStop(0, `rgba(0,${g},0,0.5)`);
                gg.addColorStop(1, 'rgba(0,255,0,0)');
                ctx.fillStyle = gg;
                ctx.fillRect(gx-rad*2, dotY-rad*2, rad*4, rad*4);
                
                const bg = ctx.createRadialGradient(bx, dotY, 0, bx, dotY, rad*2);
                bg.addColorStop(0, `rgba(0,0,${b},0.5)`);
                bg.addColorStop(1, 'rgba(0,0,255,0)');
                ctx.fillStyle = bg;
                ctx.fillRect(bx-rad*2, dotY-rad*2, rad*4, rad*4);
                ctx.restore();
              }
            }
          } else if(layout === "spectral") {
            const colors = [[255,0,0], [255,128,0], [255,255,0], [0,255,0], [0,255,255], [0,0,255], [128,0,255]];
            r/=255; g/=255; b/=255;
            const levels = [r, Math.max(r,g)*0.8, (r+g)/2, g, (g+b)/2, b, Math.max(b,r)*0.7];
            
            for(let i=0; i<colors.length; i++) {
              const alpha = levels[i] * (a/255);
              ctx.fillStyle = `rgba(${colors[i][0]},${colors[i][1]},${colors[i][2]},${alpha})`;
              const y0 = py + Math.round(i*size/colors.length);
              const y1 = py + Math.round((i+1)*size/colors.length);
              ctx.fillRect(px, y0, size, y1-y0);
              
              if(microMode && size > 5) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                const sg = ctx.createRadialGradient(px+size/2, (y0+y1)/2, 0, px+size/2, (y0+y1)/2, size*0.6);
                sg.addColorStop(0, `rgba(${colors[i][0]},${colors[i][1]},${colors[i][2]},${alpha*0.5})`);
                sg.addColorStop(1, `rgba(${colors[i][0]},${colors[i][1]},${colors[i][2]},0)`);
                ctx.fillStyle = sg;
                ctx.fillRect(px-size*0.3, y0-size*0.3, size+size*0.6, (y1-y0)+size*0.6);
                ctx.restore();
              }
            }
          }
          
          if(size > 4) {
            ctx.strokeStyle = "#000";
            ctx.lineWidth = Math.max(1, zoom*2);
            ctx.strokeRect(Math.round(px), Math.round(py), Math.round(size), Math.round(size));
          }
        }
      }
      
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.strokeRect(offX, offY, W*pxSize*zoom, H*pxSize*zoom);
      
      document.getElementById('info').textContent = `FPS: ${fps} | Pixels: ${(xEnd-xStart)*(yEnd-yStart)} | ${microMode?'Microscope ON':'Normal'}`;
    }

    canvas.addEventListener('wheel', e => {
      e.preventDefault();
      const mx = e.offsetX, my = e.offsetY;
      const oldZoom = zoom;
      zoom = e.deltaY < 0 ? Math.min(32, zoom*1.1) : Math.max(0.01, zoom*0.9);
      offX = mx - ((mx - offX) * (zoom / oldZoom));
      offY = my - ((my - offY) * (zoom / oldZoom));
      draw();
    }, {passive: false});

    canvas.addEventListener('mousedown', e => {
      isPan = true;
      startPan = {x: e.clientX, y: e.clientY};
      startOff = {x: offX, y: offY};
      canvas.style.cursor = "grabbing";
    });

    window.addEventListener('mousemove', e => {
      if(!isPan) return;
      offX = startOff.x + (e.clientX - startPan.x);
      offY = startOff.y + (e.clientY - startPan.y);
      draw();
    });

    window.addEventListener('mouseup', () => {
      isPan = false;
      canvas.style.cursor = "grab";
    });

    document.getElementById('imgInput').addEventListener('change', function(e) {
      if(!e.target.files.length) return;
      const file = e.target.files[0];
      const img = new Image();
      const reader = new FileReader();
      reader.onload = function(ev) {
        img.onload = function() {
          W = img.width;
          H = img.height;
          document.getElementById('w').value = W;
          document.getElementById('h').value = H;
          
          const tmp = document.createElement('canvas');
          tmp.width = W;
          tmp.height = H;
          const tmpCtx = tmp.getContext('2d');
          tmpCtx.drawImage(img, 0, 0);
          const data = tmpCtx.getImageData(0, 0, W, H);
          
          imgPix = [];
          for(let y=0; y<H; y++) {
            imgPix[y] = [];
            for(let x=0; x<W; x++) {
              const i = (y*W + x)*4;
              imgPix[y][x] = {r: data.data[i], g: data.data[i+1], b: data.data[i+2], a: data.data[i+3]};
            }
          }
          imgLoaded = true;
          zoom = 0.5;
          offX = offY = 0;
          draw();
        }
        img.src = ev.target.result;
      }
      reader.readAsDataURL(file);
    });

    resize();
    drawGrid();
    setInterval(draw, 16);
  </script>
</body>
</html>
