<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ULTIMATE TIC TAC TOE ONLINE üî•</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            color: white;
            overflow-x: hidden;
            padding-bottom: 50px;
        }

        body.rainbow-mode {
            animation: rainbowBG 10s linear infinite;
        }

        @keyframes rainbowBG {
            0% { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
            25% { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
            50% { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
            75% { background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); }
            100% { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        }

        .container {
            max-width: 100%;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            text-align: center;
            font-size: 1.5em;
            margin: 10px 0 5px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .online-status {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 6px 12px;
            margin-bottom: 8px;
            font-size: 0.7em;
            flex-wrap: wrap;
            justify-content: center;
        }

        .online-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .spectator-count {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #ffd700;
        }

        .bank-balance {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #43e97b;
            font-weight: bold;
            cursor: pointer;
        }

        .bank-balance:active {
            opacity: 0.7;
        }

        .online-dot {
            width: 8px;
            height: 8px;
            background: #43e97b;
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .global-rank {
            font-weight: bold;
            color: #ffd700;
        }

        .player-stats {
            display: flex;
            gap: 8px;
            width: 95%;
            max-width: 400px;
            margin-bottom: 8px;
        }

        .stat-card {
            flex: 1;
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 6px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.65em;
            opacity: 0.8;
        }

        .stat-value {
            font-size: 1.2em;
            font-weight: bold;
            margin-top: 2px;
        }

        .difficulty-selector {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 8px;
            margin-bottom: 8px;
            width: 95%;
            max-width: 400px;
        }

        .difficulty-label {
            font-size: 0.85em;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .difficulty-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
        }

        .difficulty-btn {
            padding: 5px;
            border: none;
            border-radius: 6px;
            font-size: 0.7em;
            font-weight: bold;
            cursor: pointer;
            background: rgba(255,255,255,0.2);
            color: white;
        }

        .difficulty-btn.active {
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .score-board {
            display: flex;
            justify-content: space-around;
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 6px;
            margin-bottom: 8px;
            width: 95%;
            max-width: 400px;
        }

        .score-item {
            text-align: center;
        }

        .score-label {
            font-size: 0.7em;
            opacity: 0.8;
        }

        .score-value {
            font-size: 1.3em;
            font-weight: bold;
        }

        .game-wrapper {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 10px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            width: 95%;
            max-width: 400px;
        }

        .status {
            text-align: center;
            font-size: 1em;
            margin-bottom: 8px;
            font-weight: bold;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mega-board {
            display: grid;
            grid-template-columns: repeat(3, 115px);
            grid-template-rows: repeat(3, 115px);
            gap: 5px;
            background: rgba(0,0,0,0.2);
            padding: 5px;
            border-radius: 12px;
            justify-content: center;
        }

        .mini-board {
            width: 115px;
            height: 115px;
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            padding: 3px;
            display: grid;
            grid-template-columns: repeat(3, 35px);
            grid-template-rows: repeat(3, 35px);
            gap: 2px;
            position: relative;
            justify-content: center;
            align-content: center;
        }

        .mini-board.active {
            background: rgba(106, 17, 203, 0.4);
            border-color: #6a11cb;
            border-width: 3px;
            box-shadow: 0 0 25px rgba(106, 17, 203, 0.8);
        }

        .mini-board.won {
            pointer-events: none;
        }

        .mini-board.won::after {
            content: attr(data-winner);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            font-weight: bold;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.7);
            z-index: 10;
        }

        .mini-board.won.x-won::after {
            color: #ff6b6b;
        }

        .mini-board.won.o-won::after {
            color: #4ecdc4;
        }

        .mini-board.won .cell {
            opacity: 0.2;
        }

        .cell {
            width: 35px;
            height: 35px;
            background: rgba(255,255,255,0.25);
            border: 1px solid rgba(255,255,255,0.4);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3em;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
        }

        .mini-board.active .cell:not(.taken) {
            background: rgba(255,255,255,0.35);
        }

        .cell:active:not(.taken) {
            background: rgba(255,255,255,0.6);
        }

        .cell.taken {
            cursor: not-allowed;
        }

        .cell.x {
            color: #ff6b6b;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
        }

        .cell.o {
            color: #4ecdc4;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
        }

        .cell.last-move {
            border: 2px solid #4ecdc4;
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.8);
        }

        .cell.ai-move {
            animation: aiFlash 0.6s ease-out;
        }

        .cell.hint {
            border: 2px solid #ffd700 !important;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8) !important;
            animation: hintPulse 1s ease-in-out infinite;
        }

        @keyframes hintPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        @keyframes aiFlash {
            0%, 100% { background: rgba(255,255,255,0.25); }
            50% { background: rgba(78, 205, 196, 0.7); }
        }

        .button-row {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }

        .reset-btn, .leaderboard-btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 10px;
            font-size: 0.9em;
            font-weight: bold;
            cursor: pointer;
            color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .reset-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .leaderboard-btn {
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
        }

        .chat-feed {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 8px;
            margin-bottom: 8px;
            width: 95%;
            max-width: 400px;
            max-height: 80px;
            overflow-y: auto;
            font-size: 0.7em;
        }

        .chat-message {
            margin-bottom: 4px;
            opacity: 0.9;
        }

        .chat-player {
            color: #4ecdc4;
            font-weight: bold;
        }

        .leaderboard-modal, .cheat-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .leaderboard-modal.show, .cheat-menu.show {
            display: flex;
        }

        .bank-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .bank-modal.show {
            display: flex;
        }

        .tournament-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .tournament-modal.show {
            display: flex;
        }

        .tournament-card {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .tournament-card:active {
            transform: scale(0.98);
            background: rgba(255,255,255,0.25);
        }

        .tournament-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .tournament-name {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .tournament-details {
            font-size: 0.85em;
            opacity: 0.9;
            margin-bottom: 5px;
        }

        .tournament-bet {
            color: #ff6b6b;
            font-weight: bold;
        }

        .tournament-win {
            color: #43e97b;
            font-weight: bold;
        }

        .transaction {
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 8px;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
        }

        .transaction.positive {
            border-left: 3px solid #43e97b;
        }

        .transaction.negative {
            border-left: 3px solid #ff6b6b;
        }

        .donation-popup {
            position: fixed;
            font-size: 0.9em;
            background: rgba(67, 233, 123, 0.9);
            padding: 8px 12px;
            border-radius: 8px;
            pointer-events: none;
            z-index: 997;
            font-weight: bold;
            animation: donationFloat 2s ease-out forwards;
        }

        @keyframes donationFloat {
            0% {
                transform: translateY(0) scale(0.8);
                opacity: 0;
            }
            20% {
                opacity: 1;
                transform: translateY(-10px) scale(1);
            }
            100% {
                transform: translateY(-100px) scale(0.9);
                opacity: 0;
            }
        }

        .money-won-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            z-index: 1001;
            text-align: center;
            transition: transform 0.3s ease;
            max-width: 90%;
        }

        .money-won-popup.show {
            transform: translate(-50%, -50%) scale(1);
        }

        .money-won-amount {
            font-size: 3em;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.3);
            margin-bottom: 10px;
        }

        .money-won-label {
            font-size: 1.2em;
            color: white;
            opacity: 0.9;
        }

        .modal-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            padding: 20px;
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }

        .close-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 8px;
            padding: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            margin-top: 15px;
        }

        .leaderboard-entry {
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .leaderboard-entry.you {
            background: rgba(255, 215, 0, 0.3);
            border: 2px solid #ffd700;
        }

        .rank {
            font-size: 1.2em;
            font-weight: bold;
            width: 30px;
        }

        .rank.gold { color: #ffd700; }
        .rank.silver { color: #c0c0c0; }
        .rank.bronze { color: #cd7f32; }

        .player-name {
            flex: 1;
            font-weight: bold;
        }

        .streak {
            color: #43e97b;
            font-weight: bold;
        }

        .cheat-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 8px;
            padding: 12px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .cheat-btn:active {
            background: rgba(255,255,255,0.3);
        }

        .achievement-popup {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            transform: translateX(400px);
            transition: transform 0.5s ease;
            z-index: 999;
            max-width: 250px;
        }

        .achievement-popup.show {
            transform: translateX(0);
        }

        .achievement-title {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 5px;
        }

        .achievement-desc {
            font-size: 0.85em;
        }

        .emote-popup {
            position: fixed;
            font-size: 3em;
            pointer-events: none;
            z-index: 998;
            animation: emoteFloat 2s ease-out forwards;
        }

        @keyframes emoteFloat {
            0% {
                transform: translateY(0) scale(0.5);
                opacity: 0;
            }
            20% {
                opacity: 1;
                transform: translateY(-20px) scale(1.2);
            }
            100% {
                transform: translateY(-150px) scale(1);
                opacity: 0;
            }
        }

        #particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .confetti {
            position: fixed;
            width: 8px;
            height: 8px;
            position: absolute;
            animation: confettiFall 3s linear forwards;
        }

        @keyframes confettiFall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }

        .cheat-indicator {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(255, 0, 0, 0.8);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.7em;
            font-weight: bold;
            display: none;
        }

        .cheat-indicator.show {
            display: block;
        }

        /* Responsive Design - Mobile First */

        /* iPhone 12 and similar (390x844) - Already optimized above */
        @media (max-width: 390px) {
            h1 {
                font-size: 1.3em;
            }

            .mega-board {
                grid-template-columns: repeat(3, 100px);
                grid-template-rows: repeat(3, 100px);
                gap: 4px;
                padding: 4px;
            }

            .mini-board {
                width: 100px;
                height: 100px;
                padding: 2px;
                grid-template-columns: repeat(3, 30px);
                grid-template-rows: repeat(3, 30px);
                gap: 2px;
            }

            .cell {
                width: 30px;
                height: 30px;
                font-size: 1.1em;
            }
        }

        /* Tablets (768px - 1024px) */
        @media (min-width: 768px) {
            body {
                padding: 20px;
            }

            h1 {
                font-size: 2.2em;
                margin: 15px 0 10px 0;
            }

            .online-status {
                font-size: 0.9em;
                padding: 10px 20px;
                margin-bottom: 15px;
            }

            .player-stats {
                max-width: 600px;
                gap: 15px;
                margin-bottom: 15px;
            }

            .stat-label {
                font-size: 0.8em;
            }

            .stat-value {
                font-size: 1.5em;
            }

            .chat-feed {
                max-width: 600px;
                max-height: 120px;
                font-size: 0.85em;
                margin-bottom: 15px;
            }

            .difficulty-selector {
                max-width: 600px;
                padding: 12px;
                margin-bottom: 15px;
            }

            .difficulty-label {
                font-size: 1em;
            }

            .difficulty-buttons {
                gap: 8px;
            }

            .difficulty-btn {
                padding: 10px;
                font-size: 0.85em;
            }

            .score-board {
                max-width: 600px;
                padding: 12px;
                margin-bottom: 15px;
            }

            .score-label {
                font-size: 0.85em;
            }

            .score-value {
                font-size: 1.6em;
            }

            .game-wrapper {
                max-width: 600px;
                padding: 20px;
            }

            .status {
                font-size: 1.2em;
                margin-bottom: 15px;
            }

            .mega-board {
                grid-template-columns: repeat(3, 180px);
                grid-template-rows: repeat(3, 180px);
                gap: 8px;
                padding: 8px;
            }

            .mini-board {
                width: 180px;
                height: 180px;
                padding: 5px;
                grid-template-columns: repeat(3, 55px);
                grid-template-rows: repeat(3, 55px);
                gap: 3px;
            }

            .cell {
                width: 55px;
                height: 55px;
                font-size: 1.8em;
            }

            .mini-board.won::after {
                font-size: 4.5em;
            }

            .reset-btn, .leaderboard-btn {
                padding: 14px;
                font-size: 1em;
            }

            .achievement-popup {
                max-width: 350px;
            }
        }

        /* Desktop (1025px and up, including 1920x1080) */
        @media (min-width: 1025px) {
            body {
                padding: 30px;
            }

            h1 {
                font-size: 2.8em;
                margin: 20px 0 15px 0;
            }

            .online-status {
                font-size: 1em;
                padding: 12px 25px;
                margin-bottom: 20px;
            }

            .online-dot {
                width: 10px;
                height: 10px;
            }

            .player-stats {
                max-width: 700px;
                gap: 20px;
                margin-bottom: 20px;
            }

            .stat-card {
                padding: 12px;
            }

            .stat-label {
                font-size: 0.9em;
            }

            .stat-value {
                font-size: 1.8em;
            }

            .chat-feed {
                max-width: 700px;
                max-height: 150px;
                font-size: 0.9em;
                padding: 12px;
                margin-bottom: 20px;
            }

            .difficulty-selector {
                max-width: 700px;
                padding: 15px;
                margin-bottom: 20px;
            }

            .difficulty-label {
                font-size: 1.1em;
                margin-bottom: 8px;
            }

            .difficulty-buttons {
                gap: 10px;
            }

            .difficulty-btn {
                padding: 12px;
                font-size: 0.95em;
            }

            .difficulty-btn:hover {
                background: rgba(255,255,255,0.3);
                transform: scale(1.02);
                transition: all 0.2s;
            }

            .score-board {
                max-width: 700px;
                padding: 15px;
                margin-bottom: 20px;
            }

            .score-label {
                font-size: 0.9em;
            }

            .score-value {
                font-size: 2em;
            }

            .game-wrapper {
                max-width: 700px;
                padding: 25px;
            }

            .status {
                font-size: 1.4em;
                margin-bottom: 20px;
                height: 35px;
            }

            .mega-board {
                grid-template-columns: repeat(3, 210px);
                grid-template-rows: repeat(3, 210px);
                gap: 10px;
                padding: 10px;
            }

            .mini-board {
                width: 210px;
                height: 210px;
                padding: 6px;
                grid-template-columns: repeat(3, 64px);
                grid-template-rows: repeat(3, 64px);
                gap: 4px;
                border-radius: 10px;
            }

            .mini-board.active {
                border-width: 4px;
                box-shadow: 0 0 35px rgba(106, 17, 203, 0.9);
            }

            .cell {
                width: 64px;
                height: 64px;
                font-size: 2.2em;
                border-radius: 6px;
            }

            .cell:hover:not(.taken) {
                background: rgba(255,255,255,0.45);
                transform: scale(1.05);
                transition: all 0.15s;
            }

            .mini-board.won::after {
                font-size: 5.5em;
            }

            .button-row {
                gap: 10px;
                margin-top: 15px;
            }

            .reset-btn, .leaderboard-btn {
                padding: 16px;
                font-size: 1.1em;
            }

            .reset-btn:hover, .leaderboard-btn:hover {
                transform: scale(1.03);
                transition: all 0.2s;
            }

            .achievement-popup {
                top: 30px;
                right: 30px;
                max-width: 400px;
                padding: 20px;
            }

            .achievement-title {
                font-size: 1.3em;
            }

            .achievement-desc {
                font-size: 1em;
            }

            .modal-content {
                max-width: 550px;
                padding: 30px;
            }

            .modal-header {
                font-size: 1.6em;
            }

            .cheat-btn {
                padding: 14px;
                font-size: 1em;
            }

            .cheat-btn:hover {
                background: rgba(255,255,255,0.35);
                transform: scale(1.02);
                transition: all 0.2s;
            }

            .close-btn:hover {
                background: rgba(255,255,255,0.3);
                transition: all 0.2s;
            }

            .leaderboard-entry {
                padding: 14px;
                margin-bottom: 10px;
            }

            .tournament-card {
                padding: 20px;
                margin-bottom: 12px;
            }

            .tournament-card:hover:not(.locked) {
                transform: scale(1.02);
                background: rgba(255,255,255,0.25);
                transition: all 0.2s;
            }
        }

        /* Large Desktop (1920px and up) */
        @media (min-width: 1920px) {
            h1 {
                font-size: 3.2em;
            }

            .mega-board {
                grid-template-columns: repeat(3, 240px);
                grid-template-rows: repeat(3, 240px);
                gap: 12px;
                padding: 12px;
            }

            .mini-board {
                width: 240px;
                height: 240px;
                padding: 7px;
                grid-template-columns: repeat(3, 73px);
                grid-template-rows: repeat(3, 73px);
                gap: 5px;
            }

            .cell {
                width: 73px;
                height: 73px;
                font-size: 2.5em;
            }

            .mini-board.won::after {
                font-size: 6.5em;
            }

            .game-wrapper {
                max-width: 800px;
            }

            .player-stats,
            .chat-feed,
            .difficulty-selector,
            .score-board {
                max-width: 800px;
            }
        }
    </style>
</head>
<body>
    <canvas id="particles"></canvas>
    <div class="cheat-indicator" id="cheatIndicator">CHEATS ACTIVE üîì</div>
    
    <div class="money-won-popup" id="moneyWonPopup">
        <div class="money-won-amount" id="moneyWonAmount">+$5,000</div>
        <div class="money-won-label">üéâ YOU WON! üéâ</div>
    </div>
    
    <div class="achievement-popup" id="achievementPopup">
        <div class="achievement-title">üèÜ Achievement Unlocked!</div>
        <div class="achievement-desc" id="achievementDesc">First Win!</div>
    </div>

    <div class="container">
        <h1 id="title" onclick="secretTap()">‚ö° ULTIMATE TIC TAC TOE ONLINE ‚ö°</h1>
        
        <div class="online-status">
            <div class="online-indicator">
                <div class="online-dot"></div>
                <span id="playersOnline">1,337</span> online
            </div>
            <div class="spectator-count">
                üëÅÔ∏è <span id="spectators">0</span> watching
            </div>
            <div class="bank-balance" onclick="showBank()">
                üí∞ $<span id="bankBalance">100</span>
            </div>
            <div class="bank-balance" onclick="showShop()" style="background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%); cursor: pointer;">
                üõí SHOP
            </div>
            <div class="global-rank">
                Rank #<span id="globalRank">9,999</span>
            </div>
        </div>

        <div class="player-stats">
            <div class="stat-card">
                <div class="stat-label">Win Streak</div>
                <div class="stat-value" id="winStreak">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Best Streak</div>
                <div class="stat-value" id="bestStreak">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Total Wins</div>
                <div class="stat-value" id="totalWins">0</div>
            </div>
        </div>

        <div class="chat-feed" id="chatFeed">
            <div class="chat-message"><span class="chat-player">Pro_Gamer_2024</span>: gg ez</div>
            <div class="chat-message"><span class="chat-player">xXShadowXx</span>: anyone wanna 1v1?</div>
        </div>

        <div class="difficulty-selector">
            <div class="difficulty-label">Select Opponent:</div>
            <div class="difficulty-buttons">
                <button class="difficulty-btn" data-difficulty="baby">üçº Baby</button>
                <button class="difficulty-btn" data-difficulty="easy">üòä Easy</button>
                <button class="difficulty-btn active" data-difficulty="medium">üß† Normal</button>
                <button class="difficulty-btn" data-difficulty="hard">‚ö° Pro</button>
                <button class="difficulty-btn" data-difficulty="expert">üî• Expert</button>
                <button class="difficulty-btn" data-difficulty="impossible">üíÄ Legend</button>
                <button class="difficulty-btn" data-difficulty="nightmare">üëπ Nightmare</button>
                <button class="difficulty-btn" data-difficulty="godlike">üëë GODLIKE</button>
                <button class="difficulty-btn" data-difficulty="yoadish">üò∫ Yoad-ish</button>
            </div>
        </div>

        <div class="score-board">
            <div class="score-item">
                <div class="score-label">You (X)</div>
                <div class="score-value" id="playerScore">0</div>
            </div>
            <div class="score-item">
                <div class="score-label">Ties</div>
                <div class="score-value" id="tieScore">0</div>
            </div>
            <div class="score-item">
                <div class="score-label">AI (O)</div>
                <div class="score-value" id="aiScore">0</div>
            </div>
        </div>

        <div class="game-wrapper">
            <div class="status" id="status">Finding opponent... üîç</div>
            <div class="mega-board" id="megaBoard"></div>
            <div class="button-row">
                <button class="reset-btn" id="resetBtn">Quick Match üéÆ</button>
                <button class="leaderboard-btn" style="background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);" onclick="showTournaments()">Tournaments üèÜ</button>
                <button class="leaderboard-btn" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);" onclick="showSpectatorMode()">Watch Live üì∫</button>
            </div>
        </div>
    </div>

    <!-- Leaderboard Modal -->
    <div class="leaderboard-modal" id="leaderboardModal">
        <div class="modal-content">
            <div class="modal-header">üèÜ GLOBAL LEADERBOARD üèÜ</div>
            <div id="leaderboardList"></div>
            <button class="close-btn" onclick="closeLeaderboard()">Close</button>
        </div>
    </div>

    <!-- Cheat Menu -->
    <div class="cheat-menu" id="cheatMenu">
        <div class="modal-content">
            <div class="modal-header">üîì DEVELOPER MENU üîì</div>
            <button class="cheat-btn" onclick="instantWin()">‚ö° Instant Win</button>
            <button class="cheat-btn" onclick="toggleHints()">üí° Show Hints (<span id="hintStatus">OFF</span>)</button>
            <button class="cheat-btn" onclick="toggleAutoPlay()">ü§ñ Auto-Play (<span id="autoPlayStatus">OFF</span>)</button>
            <button class="cheat-btn" onclick="togglePlayAnywhere()">üéØ Play Anywhere (<span id="playAnywhereStatus">OFF</span>)</button>
            <button class="cheat-btn" onclick="toggleOverwriteMoves()">‚úèÔ∏è Overwrite Moves (<span id="overwriteStatus">OFF</span>)</button>
            <button class="cheat-btn" onclick="toggleInstantBoardWin()">‚ö° Instant Board Win (<span id="instantBoardWinStatus">OFF</span>)</button>
            <button class="cheat-btn" onclick="toggleRainbow()">üåà Rainbow Mode (<span id="rainbowStatus">OFF</span>)</button>
            <button class="cheat-btn" onclick="boostOnlinePlayers()">üìà +10K Online Players</button>
            <button class="cheat-btn" onclick="addWinStreak()">üìà +10 Win Streak</button>
            <button class="cheat-btn" onclick="addMoney()">üí∞ +$1000</button>
            <button class="cheat-btn" onclick="maxStats()">üìä Max All Stats</button>
            <button class="cheat-btn" onclick="showAchievements()" style="background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);">üèÜ View Achievements</button>
            <button class="close-btn" onclick="closeCheatMenu()">Close</button>
        </div>
    </div>

    <!-- Bank Modal -->
    <div class="bank-modal" id="bankModal">
        <div class="modal-content">
            <div class="modal-header">üí∞ YOUR BANK üí∞</div>
            <div style="text-align: center; font-size: 2em; font-weight: bold; margin: 20px 0; color: #43e97b;">
                $<span id="bankBalanceModal">100</span>
            </div>
            <div style="margin-bottom: 15px;">
                <div style="font-weight: bold; margin-bottom: 8px;">Recent Transactions:</div>
                <div id="transactionHistory" style="max-height: 200px; overflow-y: auto;"></div>
            </div>
            <div style="text-align: center; margin: 15px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                <div style="font-weight: bold; color: #f093fb;">üîÑ Rebirth Level: <span id="rebirthLevelDisplay">0</span></div>
                <div style="font-size: 0.85em; opacity: 0.9; margin-top: 5px;">Income Multiplier: <span id="rebirthMultDisplay">1.0</span>x | Tax Rate: <span id="taxRateDisplay">25</span>%</div>
            </div>
            <button class="cheat-btn" onclick="dailyBonus()">üéÅ Daily Bonus ($400)</button>
            <button class="cheat-btn" onclick="performRebirth()" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">üîÑ REBIRTH ($1,000,000)</button>
            <button class="close-btn" onclick="closeBank()">Close</button>
        </div>
    </div>

    <!-- Tournament Modal -->
    <div class="tournament-modal" id="tournamentModal">
        <div class="modal-content">
            <div class="modal-header">üèÜ SELECT TOURNAMENT üèÜ</div>
            <div id="tournamentList"></div>
            <button class="cheat-btn" onclick="showCustomTournament()">‚ûï Create Custom Tournament</button>
            <button class="close-btn" onclick="closeTournaments()">Close</button>
        </div>
    </div>

    <!-- Custom Tournament Modal -->
    <div class="tournament-modal" id="customTournamentModal">
        <div class="modal-content">
            <div class="modal-header">‚ûï CREATE YOUR TOURNAMENT ‚ûï</div>
            
            <div style="background: rgba(255,255,255,0.2); padding: 10px; border-radius: 8px; margin-bottom: 15px; font-size: 0.85em;">
                ‚ö†Ô∏è <strong>How it works:</strong><br>
                1. You PAY the Entry Fee NOW<br>
                2. If you WIN ‚Üí Get the Prize<br>
                3. If you LOSE ‚Üí Lose your Entry Fee üò≠<br>
                4. If you TIE ‚Üí Get your money back
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">Tournament Name:</label>
                <input type="text" id="customName" placeholder="My Epic Tournament" style="width: 100%; padding: 8px; border-radius: 8px; border: none; font-size: 1em;">
                <div style="font-size: 0.75em; opacity: 0.7; margin-top: 3px;">What do you want to call it?</div>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">üí∏ Entry Fee (You pay THIS now!):</label>
                <input type="number" id="customBet" placeholder="100" min="1" style="width: 100%; padding: 8px; border-radius: 8px; border: none; font-size: 1em;">
                <div style="font-size: 0.75em; opacity: 0.7; margin-top: 3px;">How much $ you risk. Lose = You lose this!</div>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">üèÜ Prize Multiplier (How much you can win!):</label>
                <input type="number" id="customMultiplier" placeholder="5" min="1" step="0.5" style="width: 100%; padding: 8px; border-radius: 8px; border: none; font-size: 1em;">
                <div style="font-size: 0.85em; margin-top: 5px; background: rgba(67,233,123,0.3); padding: 8px; border-radius: 5px;">
                    <strong>Prize = Entry Fee √ó Multiplier</strong><br>
                    Example: $100 √ó 5 = <strong>$500 prize!</strong>
                </div>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">üéÆ AI Difficulty:</label>
                <select id="customDifficulty" style="width: 100%; padding: 8px; border-radius: 8px; border: none; font-size: 1em;">
                    <option value="baby">üçº Baby (Super easy)</option>
                    <option value="easy">üòä Easy (Easy to beat)</option>
                    <option value="medium" selected>üß† Normal (Fair fight)</option>
                    <option value="hard">‚ö° Pro (Pretty hard)</option>
                    <option value="expert">üî• Expert (Very hard!)</option>
                    <option value="impossible">üíÄ Legend (Nearly unbeatable!)</option>
                    <option value="nightmare">üëπ Nightmare (Insanely hard!)</option>
                    <option value="godlike">üëë GODLIKE (IMPOSSIBLE!)</option>
                </select>
                <div style="font-size: 0.75em; opacity: 0.7; margin-top: 3px;">Higher difficulty = Harder to win! GODLIKE = PREPARE TO LOSE!</div>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; font-weight: bold;">üëÅÔ∏è Fake Viewers (Just for fun!):</label>
                <input type="number" id="customViewers" placeholder="1000" min="0" style="width: 100%; padding: 8px; border-radius: 8px; border: none; font-size: 1em;">
                <div style="font-size: 0.75em; opacity: 0.7; margin-top: 3px;">More viewers = More chat spam & donations! Try 500,000!</div>
            </div>
            
            <div id="customPreview" style="background: rgba(255,215,0,0.2); padding: 12px; border-radius: 8px; margin-bottom: 15px; font-weight: bold; text-align: center;">
                Preview: Pay $100 ‚Üí Win $500
            </div>
            
            <button class="cheat-btn" style="background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);" onclick="createCustomTournament()">üéÆ START (Pay Entry Fee Now!)</button>
            <button class="close-btn" onclick="closeCustomTournament()">Cancel</button>
        </div>
    </div>

    <!-- Achievements Modal -->
    <div class="leaderboard-modal" id="achievementsModal">
        <div class="modal-content">
            <div class="modal-header">üèÜ ACHIEVEMENTS üèÜ</div>
            <div id="achievementsList"></div>
            <button class="close-btn" onclick="closeAchievements()">Close</button>
        </div>
    </div>

    <!-- Shop Modal -->
    <div class="leaderboard-modal" id="shopModal">
        <div class="modal-content">
            <div class="modal-header">üõí SHOP üõí</div>
            <div style="font-size: 0.9em; margin-bottom: 15px; opacity: 0.9;">
                üí∞ Your Balance: $<span id="shopBalance">0</span>
            </div>
            <div id="shopList"></div>
            <button class="close-btn" onclick="closeShop()">Close</button>
        </div>
    </div>

    <!-- Spectator Mode Modal -->
    <div class="leaderboard-modal" id="spectatorModal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">üì∫ WATCH LIVE TOURNAMENTS üì∫</div>

            <div id="liveMatchesList" style="margin-bottom: 20px;">
                <!-- Live matches will be populated here -->
            </div>

            <div id="spectatorView" style="display: none;">
                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <div style="font-size: 1.2em; font-weight: bold;">
                            <span id="specPlayer1Name">Player1</span> (<span id="specPlayer1Score">0</span>)
                        </div>
                        <div style="font-size: 1em; opacity: 0.8;">
                            <span id="specTournamentName">Tournament</span> | <span id="specViewers">0</span> viewers
                        </div>
                        <div style="font-size: 1.2em; font-weight: bold;">
                            (<span id="specPlayer2Score">0</span>) <span id="specPlayer2Name">Player2</span>
                        </div>
                    </div>

                    <!-- Betting Section -->
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <button class="cheat-btn" style="flex: 1;" onclick="placeBet('player1')">
                            üí∞ Bet on <span id="betPlayer1Name">Player1</span> (<span id="betPlayer1Odds">2.0</span>x)
                        </button>
                        <input type="number" id="betAmount" placeholder="Bet $" value="100" style="width: 100px; padding: 8px; border-radius: 5px; border: none; background: rgba(255,255,255,0.2); color: white; text-align: center;" />
                        <button class="cheat-btn" style="flex: 1;" onclick="placeBet('player2')">
                            üí∞ Bet on <span id="betPlayer2Name">Player2</span> (<span id="betPlayer2Odds">2.0</span>x)
                        </button>
                    </div>
                    <div id="currentBetDisplay" style="text-align: center; font-size: 0.9em; opacity: 0.8; margin-bottom: 10px;"></div>

                    <!-- Mini Board Display (simplified) -->
                    <div id="spectatorBoard" style="text-align: center; font-size: 1.5em; margin: 15px 0;">
                        üéÆ Match in progress...
                    </div>

                    <!-- Donation Section -->
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button class="cheat-btn" style="flex: 1; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);" onclick="donateToPlayer('player1')">
                            üíù Donate $50 to <span id="donatePlayer1Name">Player1</span>
                        </button>
                        <button class="cheat-btn" style="flex: 1; background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);" onclick="donateToPlayer('player2')">
                            üíù Donate $50 to <span id="donatePlayer2Name">Player2</span>
                        </button>
                    </div>
                </div>

                <!-- Spectator Chat -->
                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px;">
                    <div style="font-weight: bold; margin-bottom: 10px;">üí¨ Live Chat</div>
                    <div id="spectatorChatFeed" style="max-height: 200px; overflow-y: auto; margin-bottom: 10px; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px;">
                        <!-- Chat messages will appear here -->
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="spectatorChatInput" placeholder="Type a message..." style="flex: 1; padding: 10px; border-radius: 5px; border: none; background: rgba(255,255,255,0.2); color: white;" onkeypress="if(event.key==='Enter') sendSpectatorMessage()" />
                        <button class="cheat-btn" onclick="sendSpectatorMessage()">Send</button>
                    </div>
                </div>

                <button class="cheat-btn" onclick="leaveSpectator()" style="margin-top: 15px; width: 100%;">‚óÄ Back to Live Matches</button>
            </div>

            <button class="close-btn" onclick="closeSpectator()">Close</button>
        </div>
    </div>

    <script>
        // Sound effects (using Web Audio API)
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            switch(type) {
                case 'click':
                    oscillator.frequency.value = 800;
                    gainNode.gain.value = 0.1;
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.1);
                    break;
                case 'win':
                    oscillator.frequency.value = 1000;
                    gainNode.gain.value = 0.2;
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.3);
                    break;
                case 'lose':
                    oscillator.frequency.value = 200;
                    gainNode.gain.value = 0.2;
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.5);
                    break;
                case 'whale':
                    // Epic whale sound - ascending tones
                    oscillator.frequency.value = 600;
                    gainNode.gain.value = 0.25;
                    oscillator.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.5);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.7);
                    break;
            }
        }

        // Konami code listener (type "yoad" to open cheat menu)
        let konamiCode = '';
        let tapCount = 0;
        let tapTimeout = null;

        function secretTap() {
            tapCount++;
            
            if (tapTimeout) clearTimeout(tapTimeout);
            
            if (tapCount >= 5) {
                document.getElementById('cheatMenu').classList.add('show');
                playSound('win');
                tapCount = 0;
            }
            
            tapTimeout = setTimeout(() => {
                tapCount = 0;
            }, 2000);
        }

        document.addEventListener('keydown', (e) => {
            konamiCode += e.key.toLowerCase();
            if (konamiCode.includes('yoad')) {
                document.getElementById('cheatMenu').classList.add('show');
                konamiCode = '';
            }
            if (konamiCode.length > 10) konamiCode = konamiCode.slice(-10);
        });

        // Particle system
        const canvas = document.getElementById('particles');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const particles = [];
        const particleCount = 50;

        class Particle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.vx = (Math.random() - 0.5) * 1;
                this.vy = (Math.random() - 0.5) * 1;
                this.size = Math.random() * 3 + 1;
                this.opacity = Math.random() * 0.4 + 0.1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
                if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
            }

            draw() {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        for (let i = 0; i < particleCount; i++) {
            particles.push(new Particle());
        }

        function animateParticles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach(p => {
                p.update();
                p.draw();
            });
            requestAnimationFrame(animateParticles);
        }
        animateParticles();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Game state
        let miniBoards = Array(9).fill(null).map(() => ['', '', '', '', '', '', '', '', '']);
        let megaBoard = ['', '', '', '', '', '', '', '', ''];
        let currentPlayer = 'X';
        let activeBoard = null;
        let gameActive = true;
        let difficulty = 'medium';
        let scores = { player: 0, ai: 0, tie: 0 };
        let winStreak = 0;
        let bestStreak = 0;
        let totalWins = 0;
        let globalRank = 9999;
        let autoPlayEnabled = false;
        let cheatsActive = false;
        let hintsEnabled = false;
        let playAnywhereEnabled = false;
        let overwriteMovesEnabled = false;
        let instantBoardWinEnabled = false;
        let spectators = 0;
        let moveCount = 0;
        let gameStartTime = 0;
        let achievements = JSON.parse(localStorage.getItem('tttAchievements')) || [];
        let purchasedItems = JSON.parse(localStorage.getItem('tttPurchased')) || [];
        let richWhaleActive = false;
        let richWhaleInterval = null;
        let bankBalance = parseInt(localStorage.getItem('tttBalance')) || 800;
        let transactions = JSON.parse(localStorage.getItem('tttTransactions')) || [];
        let lastDailyBonus = localStorage.getItem('tttLastDaily') || '';
        let currentBet = 0;
        let currentTournament = null;
        let taxRate = 0.25; // 25% tax on all income (brutal!)
        let rebirthLevel = parseInt(localStorage.getItem('tttRebirth')) || 0;
        let rebirthMultiplier = 1 + (rebirthLevel * 0.5); // +50% per rebirth!
        let targetSpectators = 0;
        let spectatorInterval = null;

        const tournaments = [
            { name: 'Casual Match üéÆ', bet: 40, win: 120, difficulty: 'easy', viewers: 20, locked: false, unlockAt: 0 },
            { name: 'Beginner Bracket', bet: 80, win: 240, difficulty: 'medium', viewers: 75, locked: false, unlockAt: 0 },
            { name: 'Amateur League', bet: 200, win: 600, difficulty: 'medium', viewers: 200, locked: false, unlockAt: 0 },
            { name: 'Pro Circuit ‚ö°', bet: 400, win: 1200, difficulty: 'hard', viewers: 500, locked: false, unlockAt: 0 },
            { name: 'Elite Tournament', bet: 800, win: 2800, difficulty: 'hard', viewers: 1000, locked: false, unlockAt: 0 },
            { name: 'Master Series üî•', bet: 1600, win: 6000, difficulty: 'expert', viewers: 2500, locked: false, unlockAt: 0 },
            { name: 'Grand Championship', bet: 2800, win: 12000, difficulty: 'expert', viewers: 5000, locked: false, unlockAt: 0 },
            { name: 'LEGEND ULTIMATE üíÄ', bet: 4000, win: 24000, difficulty: 'impossible', viewers: 10000, locked: false, unlockAt: 0 },
            { name: 'NIGHTMARE GAUNTLET üëπ', bet: 8000, win: 60000, difficulty: 'nightmare', viewers: 25000, locked: false, unlockAt: 0 },
            { name: 'GODLIKE ARENA üëë', bet: 20000, win: 160000, difficulty: 'godlike', viewers: 75000, locked: true, unlockAt: 40000 },
            { name: 'WHALE WARS üêã', bet: 40000, win: 400000, difficulty: 'godlike', viewers: 150000, locked: true, unlockAt: 120000 },
            { name: 'THE FINAL BOSS üíé', bet: 80000, win: 800000, difficulty: 'godlike', viewers: 500000, locked: true, unlockAt: 400000 },
            { name: 'YOAD üò∫', bet: 1000000, win: 50000000, difficulty: 'yoadish', viewers: 10000000, locked: true, unlockAt: 5000000 }
        ];

        const winConditions = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8],
            [0, 3, 6], [1, 4, 7], [2, 5, 8],
            [0, 4, 8], [2, 4, 6]
        ];

        const allAchievements = [
            { id: 'first_win', name: 'üéâ First Win', desc: 'Win your first game', check: () => totalWins >= 1 },
            { id: 'on_fire', name: 'üî• On Fire', desc: 'Win 3 games in a row', check: () => bestStreak >= 3 },
            { id: 'unstoppable', name: '‚ö° Unstoppable', desc: 'Win 5 games in a row', check: () => bestStreak >= 5 },
            { id: 'legend', name: 'üëë Legend Status', desc: 'Win 10 games in a row', check: () => bestStreak >= 10 },
            { id: 'millionaire', name: 'üí∞ Millionaire', desc: 'Earn $1,000 total', check: () => bankBalance >= 1000 },
            { id: 'whale', name: 'üêã High Roller', desc: 'Earn $10,000 total', check: () => bankBalance >= 10000 },
            { id: 'bigwig', name: 'üíé Big Money', desc: 'Earn $50,000 total', check: () => bankBalance >= 50000 },
            { id: 'beat_expert', name: 'üî• Expert Slayer', desc: 'Beat Expert difficulty', check: () => false },
            { id: 'beat_impossible', name: 'üíÄ Legend Killer', desc: 'Beat Legend difficulty', check: () => false },
            { id: 'beat_nightmare', name: 'üëπ Nightmare Conqueror', desc: 'Beat Nightmare difficulty', check: () => false },
            { id: 'beat_godlike', name: 'üëë Godslayer', desc: 'Beat GODLIKE difficulty', check: () => false },
            { id: 'beat_yoad', name: 'üò∫ YOAD DEFEATER', desc: 'Beat YOAD-ISH difficulty', check: () => false },
            { id: 'board_master', name: 'üéØ Board Master', desc: 'Win 10 mini boards in one game', check: () => false },
            { id: 'fast_win', name: '‚ö° Speed Demon', desc: 'Win in under 30 seconds', check: () => false },
            { id: 'tournament_winner', name: 'üèÜ Tournament Champion', desc: 'Win any tournament', check: () => false },
            { id: 'whale_wars_winner', name: 'üêã Whale Wars Victor', desc: 'Win the Whale Wars tournament', check: () => false },
            { id: 'final_boss_winner', name: 'üíé Final Boss Defeated', desc: 'Win The Final Boss tournament', check: () => false },
            { id: 'yoad_legend', name: 'üò∫ YOAD LEGEND', desc: 'Win the YOAD tournament', check: () => false },
            { id: 'cheater', name: 'üîì Script Kiddie', desc: 'Enable any cheat', check: () => cheatsActive },
            { id: 'donation_hunter', name: 'üí∏ Donation Magnet', desc: 'Receive 50 donations in one game', check: () => false }
        ];

        const shopItems = [
            { id: 'vip_badge', name: 'üëë VIP Badge', desc: 'Show off in chat with a VIP tag', price: 8000, category: 'cosmetic' },
            { id: 'diamond_badge', name: 'üíé Diamond Badge', desc: 'Ultra rare diamond status', price: 40000, category: 'cosmetic' },
            { id: 'whale_badge', name: 'üêã Whale Badge', desc: 'Flex your wealth!', price: 200000, category: 'cosmetic' },
            { id: 'godlike_badge', name: 'üëπ GODLIKE Badge', desc: 'The ultimate flex', price: 800000, category: 'cosmetic' },
            { id: 'double_donations', name: 'üí∞ 2x Donations', desc: 'Double all donation amounts!', price: 80000, category: 'modifier' },
            { id: 'streak_protection', name: 'üõ°Ô∏è Streak Protection', desc: 'Next loss won\'t reset streak', price: 120000, category: 'modifier' },
            { id: 'guaranteed_whale', name: 'üêã Whale Magnet', desc: 'Always spawn whales in big tournaments', price: 400000, category: 'modifier' },
            { id: 'rainbow_board', name: 'üåà Rainbow Board', desc: 'Permanent rainbow mode!', price: 60000, category: 'cosmetic' },
            { id: 'golden_x', name: '‚≠ê Golden X', desc: 'Your moves are golden!', price: 160000, category: 'cosmetic' },
            { id: 'instant_rank_1', name: 'üèÜ Instant Rank #1', desc: 'Become #1 on leaderboard', price: 2000000, category: 'flex' },
            { id: 'money_printer', name: 'üñ®Ô∏è Money Printer', desc: 'Passive $800/minute income', price: 4000000, category: 'modifier' },
            { id: 'god_mode', name: '‚ö° GOD MODE', desc: 'Can\'t lose. Literally.', price: 8000000, category: 'modifier' }
        ];

        const playerNames = [
            // Original gamer names
            'xXDarkLordXx', 'Pro_Gamer_420', 'NoobMaster69', 'ShadowNinja',
            'Epic_Fail', 'TryHard_2024', 'MLG_Pro', 'GG_EZ', 'Flame_Thrower',
            'Ice_Breaker', 'Thunder_Strike', 'Toxic_Player', 'Silent_Killer',
            'Rage_Quitter', 'Bot_Destroyer', 'Clutch_Master', 'Sniper_Elite',
            'Speed_Demon', 'Lag_Wizard', 'Camping_King', 'Spawn_Killer',

            // Baldi's Basics
            'Baldi', 'Principal_of_Thing', 'Playtime', 'Its_A_Bully', 'Gotta_Sweep',
            'First_Prize', 'Filename2', 'Arts_Crafters', 'Cloudy_Copter', 'Beans',

            // Dexter's Lab
            'Dexter', 'Dee_Dee', 'Mandark', 'Mom_Dexter', 'Dad_Dexter', 'Monkey',
            'Agent_Honeydew', 'Major_Glory', 'Krunk', 'Val_Hallen',

            // More gaming references
            'Steve_Minecraft', 'Creeper_Aww_Man', 'Diamond_Miner', 'Herobrine',
            'Ender_Dragon', 'Notch', 'Dream_Stan', 'Technoblade_Fan', 'Philza',
            'Sans_Undertale', 'Papyrus', 'Flowey_The_Flower', 'Frisk', 'Chara',
            'Toriel_Mom', 'Undyne', 'Alphys', 'Mettaton', 'Asgore',

            // Roblox
            'Builderman', 'Roblox_Noob', 'Bacon_Hair', 'Guest_12345', 'Oof_Sound',
            'Bloxy_Awards', 'Robux_Collector', 'Flamingo_Fan', 'Albertsstuff',

            // FNaF
            'Freddy_Fazbear', 'Bonnie_Bunny', 'Chica', 'Foxy', 'Golden_Freddy',
            'Purple_Guy', 'Phone_Guy', 'Springtrap', 'Puppet', 'Balloon_Boy',

            // Sonic (SEGA)
            'Sonic_Speed', 'Tails', 'Knuckles', 'Shadow_Hedgehog', 'Dr_Eggman',
            'Amy_Rose', 'Rouge', 'Silver', 'Blaze', 'Metal_Sonic',

            // Other gaming icons
            'Gordon_Freeman', 'Chell', 'Glados', 'Wheatley', 'Cave_Johnson',
            'Heavy_TF2', 'Scout', 'Medic', 'Spy', 'Engineer',
            'Portal_Master', 'Companion_Cube', 'Turret', 'Atlas', 'P_Body',

            // Among Us
            'Red_Sus', 'Blue_Crewmate', 'Imposter', 'Emergency_Meeting', 'Cyan',
            'Pink', 'White_Sus', 'I_Saw_Black', 'Electrical', 'Medbay_Scan',

            // Fortnite
            'Jonesy', 'Peely', 'Fishstick', 'Midas', 'Drift', 'Raptor',
            'Victory_Royale', 'Cranking_90s', 'Default_Skin', 'OG_Player',

            // League/Valorant
            'Yasuo_Main', 'Teemo_Satan', 'Jett_Dash', 'Sage_Heal', 'Phoenix',
            'Reyna', 'Sova_Arrow', 'Yoru', 'Neon', 'Chamber',

            // Classic memes
            'Doge', 'Pepe', 'Shrek', 'Shaggy', 'Big_Chungus', 'Ugandan_Knuckles',
            'Harambe', 'Grumpy_Cat', 'Nyan_Cat', 'Keyboard_Cat', 'Success_Kid',

            // Twitch/YouTube
            'PewDiePie', 'MrBeast', 'KSI', 'Logan_Paul', 'xQc', 'Ninja_Fortnite',
            'Pokimane', 'Valkyrae', 'Sykkuno', 'Corpse_Husband', 'Dream_Speedrun',

            // Random internet culture
            '69420_Funny', 'Big_Brain_Time', 'No_U', 'UNO_Reverse', 'STONKS',
            'Press_F', 'Bruh_Moment', 'Yeet', 'Dab', 'Ratio', 'Based',
            'Cringe', 'Sigma_Male', 'Chad', 'Virgin', 'Gigachad',

            // More gamer tags
            'Headshot_Only', 'Carry_Me_Plz', 'AFK_Player', 'Keyboard_Warrior',
            'Mouse_Broken', 'Wifi_Died', 'Mom_Called', 'Bathroom_Break',
            'Pizza_Delivery', 'Cat_On_Keyboard', 'Dog_Barking', 'Baby_Crying',

            // Competitive
            'Top_500', 'Grandmaster', 'Diamond_Peak', 'Plat_Stuck', 'Gold_Forever',
            'Silver_Hell', 'Bronze_King', 'Unranked_God', 'Smurf_Account',

            // Anime references
            'Naruto_Kun', 'Sasuke', 'Goku', 'Vegeta', 'Luffy', 'Zoro',
            'Light_Yagami', 'L', 'All_Might', 'Deku', 'Eren_Yeager',

            // Misc games
            'Master_Chief', 'Doom_Slayer', 'Kratos', 'Ezio', 'Cloud_Strife',
            'Lara_Croft', 'Nathan_Drake', 'Geralt', 'Witcher', 'Arthur_Morgan',
            'Joel', 'Ellie', 'Aloy', 'Spyro', 'Crash_Bandicoot', 'Pac_Man'
        ];

        const chatMessages = [
            'gg ez',
            'lag!!!',
            'lucky shot',
            'rematch?',
            'noob team',
            'carried'
        ];

        const suspiciousMessages = [
            'bro how did you win that fast???',
            'wait that move was insane',
            'are you cheating??',
            'sus...',
            'reported',
            'impossible win wtf',
            'no way you saw that coming',
            'admin check this player',
            'hacker confirmed',
            'this guy is different üíÄ'
        ];

        const rageQuitMessages = [
            'has left the match',
            'rage quit lmao',
            'couldnt handle the heat',
            'disconnected',
            'gave up',
            'uninstalling rn'
        ];

        const emotes = ['üî•', 'üíÄ', 'üòÇ', 'üëë', 'üí™', '‚ö°', 'üéØ', 'üëÄ', 'ü§Ø', 'üíØ'];

        function spawnEmote(emote) {
            const popup = document.createElement('div');
            popup.className = 'emote-popup';
            popup.textContent = emote;
            popup.style.left = (Math.random() * (window.innerWidth - 100)) + 'px';
            popup.style.top = (window.innerHeight * 0.3) + 'px';
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 2000);
        }

        function updateSpectators() {
            // First update the total online count
            updateOnlineCount();

            // Calculate target spectator count based on game state
            if (gameActive) {
                if (currentTournament) {
                    // Tournament mode - use tournament viewer count
                    const baseViewers = currentTournament.viewers;
                    const variance = Math.floor(Math.random() * (baseViewers * 0.1)); // +/- 10%
                    targetSpectators = baseViewers + variance;
                } else {
                    // Quick match mode - low viewers
                    const baseSpectators = Math.floor(Math.random() * 5);
                    const streakBonus = Math.floor(winStreak * 2);
                    targetSpectators = Math.min(baseSpectators + streakBonus, 50);

                    if (cheatsActive) targetSpectators += Math.floor(Math.random() * 10) + 5;
                }
            } else {
                targetSpectators = Math.max(0, targetSpectators - Math.floor(Math.random() * 10));
            }

            // IMPORTANT: Ensure spectators never exceed total online count
            // Spectators are a SUBSET of online players, not additional to them
            // If we need more spectators, we increase the total online count
            if (targetSpectators > targetOnline) {
                // Increase online count to accommodate spectators
                // Online = spectators + (20-50% more players doing other things)
                const extraPlayersPercent = 0.2 + (Math.random() * 0.3); // 20-50% more
                targetOnline = Math.floor(targetSpectators * (1 + extraPlayersPercent));
            }

            // Start smooth animation to target
            animateSpectatorCount();
        }

        function animateSpectatorCount() {
            // Clear any existing animation
            if (spectatorInterval) clearInterval(spectatorInterval);
            
            const startCount = spectators;
            const targetCount = targetSpectators;
            const difference = targetCount - startCount;
            
            if (difference === 0) {
                document.getElementById('spectators').textContent = spectators.toLocaleString();
                return;
            }
            
            // Duration: 20-50 SECONDS for viewers to join
            const duration = 20000 + Math.floor(Math.random() * 30000); // 20-50 seconds
            const steps = 100; // 100 animation steps
            const stepValue = difference / steps;
            const intervalTime = duration / steps;
            
            let currentStep = 0;
            
            spectatorInterval = setInterval(() => {
                currentStep++;
                spectators = Math.round(startCount + (stepValue * currentStep));
                
                // Add some random variance during counting
                const variance = Math.floor(Math.random() * Math.max(1, Math.abs(difference) * 0.02));
                const displayCount = spectators + (Math.random() > 0.5 ? variance : -variance);
                
                document.getElementById('spectators').textContent = Math.max(0, displayCount).toLocaleString();
                
                if (currentStep >= steps) {
                    clearInterval(spectatorInterval);
                    spectators = targetCount;
                    document.getElementById('spectators').textContent = spectators.toLocaleString();
                }
            }, intervalTime);
        }

        function reactiveChat(type, data = {}) {
            const player = playerNames[Math.floor(Math.random() * playerNames.length)];
            let message = '';

            switch(type) {
                case 'fast_win':
                    message = suspiciousMessages[Math.floor(Math.random() * suspiciousMessages.length)];
                    setTimeout(() => spawnEmote('ü§Ø'), 500);
                    break;
                case 'cheat_detected':
                    message = suspiciousMessages[Math.floor(Math.random() * suspiciousMessages.length)];
                    setTimeout(() => spawnEmote('üëÄ'), 300);
                    break;
                case 'big_streak':
                    message = `this guy is on ${data.streak} win streak wtf`;
                    setTimeout(() => spawnEmote('üî•'), 500);
                    break;
                case 'instant_win':
                    message = 'WAIT WHAT JUST HAPPENED???';
                    setTimeout(() => spawnEmote('üíÄ'), 300);
                    break;
                case 'rage_quit':
                    const opponent = 'AI_Bot_' + Math.floor(Math.random() * 1000);
                    message = `${opponent} ${rageQuitMessages[Math.floor(Math.random() * rageQuitMessages.length)]}`;
                    setTimeout(() => spawnEmote('üòÇ'), 500);
                    break;
                case 'spectator_join':
                    message = 'joined to spectate';
                    break;
                case 'normal_win':
                    message = 'gg wp';
                    setTimeout(() => spawnEmote('üëë'), 500);
                    break;
                case 'comeback':
                    message = 'WHAT A COMEBACK!';
                    setTimeout(() => spawnEmote('‚ö°'), 500);
                    break;
            }

            addChatMessage(player, message);
        }

        // Fake online counter with smooth animation
        // IMPORTANT: Spectators are a SUBSET of online players, not added on top!
        let baseOnline = 1337; // Minimum base players online
        let targetOnline = 1337;
        let currentOnline = 1337;

        function updateOnlineCount() {
            // Online count = TOTAL players on the platform (including spectators)
            // Spectators = subset of online players who are watching YOU
            // Therefore: spectators <= online ALWAYS

            // Update base online slowly over time (between 1K-3K)
            if (Math.random() < 0.1) { // 10% chance to update base
                baseOnline = 1000 + Math.floor(Math.random() * 2000);
            }

            // Set initial target online (will be adjusted if spectators are higher)
            targetOnline = baseOnline;

            // Add some random variance to make it feel dynamic
            const variance = Math.floor(Math.random() * 200) - 100; // +/- 100
            targetOnline += variance;

            // Ensure minimum of 100 players online
            targetOnline = Math.max(100, targetOnline);
        }
        
        function animateOnlineCount() {
            // Update target based on current spectators
            updateOnlineCount();

            // CRITICAL: Ensure online count is always >= spectator count
            // If spectators are higher than target online, boost online count
            if (spectators > targetOnline) {
                targetOnline = Math.floor(spectators * (1.2 + Math.random() * 0.3)); // 120-150% of spectators
            }

            const difference = targetOnline - currentOnline;
            if (Math.abs(difference) > 1) {
                currentOnline += difference * 0.2; // Faster catch-up

                // SAFETY CHECK: Never let displayed online count go below spectator count
                if (currentOnline < spectators) {
                    currentOnline = spectators;
                }

                document.getElementById('playersOnline').textContent = Math.round(currentOnline).toLocaleString();
            } else {
                currentOnline = targetOnline;

                // Final safety check
                if (currentOnline < spectators) {
                    currentOnline = spectators;
                }

                document.getElementById('playersOnline').textContent = currentOnline.toLocaleString();
            }
        }
        
        // Update online count display frequently to stay in sync with spectators
        setInterval(animateOnlineCount, 200);
        
        setInterval(() => {
            updateSpectators();
        }, 5000);

        // Fake chat messages (frequency based on ONLINE PLAYERS - MORE CRAZY!)
        setInterval(() => {
            if (!gameActive) return;

            // More online players = WAY more frequent chat!
            let chatChance = 0.1; // 10% base chance
            if (currentOnline > 100) chatChance = 0.3;
            if (currentOnline > 500) chatChance = 0.5;
            if (currentOnline > 1000) chatChance = 0.7;
            if (currentOnline > 5000) chatChance = 0.9;
            if (currentOnline > 10000) chatChance = 1.0; // Always chat!
            if (currentOnline > 50000) chatChance = 1.5; // CHAT EXPLOSION - multiple messages!

            // At super high online counts, spam multiple messages at once!
            const messageCount = currentOnline > 50000 ? 2 : 1;

            if (Math.random() < chatChance) {
                for (let i = 0; i < messageCount; i++) {
                    setTimeout(() => {
                        const player = playerNames[Math.floor(Math.random() * playerNames.length)];
                        const message = chatMessages[Math.floor(Math.random() * chatMessages.length)];
                        addChatMessage(player, message);
                    }, i * 200);
                }
            }
        }, 3000); // Check every 3 seconds

        // Random donations during gameplay based on spectator count
        setInterval(() => {
            if (!gameActive || currentPlayer !== 'X') return;

            let randomDonationChance = 0;

            // More spectators = random donations even during gameplay!
            if (spectators < 500) randomDonationChance = 0;
            else if (spectators < 1000) randomDonationChance = 0.05; // 5%
            else if (spectators < 5000) randomDonationChance = 0.15; // 15%
            else if (spectators < 10000) randomDonationChance = 0.25; // 25%
            else randomDonationChance = 0.4; // 40% for massive tournaments

            if (Math.random() < randomDonationChance) {
                let minDono = 3;
                let maxDono = 15;

                if (spectators > 1000) { minDono = 5; maxDono = 30; }
                if (spectators > 5000) { minDono = 15; maxDono = 75; }
                if (spectators > 10000) { minDono = 30; maxDono = 150; }

                const donation = Math.floor(Math.random() * (maxDono - minDono + 1)) + minDono;
                spawnDonation(donation);
                const donor = playerNames[Math.floor(Math.random() * playerNames.length)];

                const donationMessages = [
                    `donated $${donation}! üí∞`,
                    `$${donation} for the GOAT!`,
                    `throwing $${donation} at you`,
                    `have $${donation}! gl!`,
                    `$${donation} lets go!`,
                    `here's $${donation} king üëë`,
                    `$${donation} you got this!`
                ];

                addChatMessage(donor, donationMessages[Math.floor(Math.random() * donationMessages.length)]);
            }
        }, 8000); // Check every 8 seconds

        // Random spectator events
        setInterval(() => {
            if (gameActive && Math.random() < 0.2) {
                reactiveChat('spectator_join');
            }
        }, 15000);

        // IDLE CHAT CONVERSATIONS - Players talking to each other!
        setInterval(() => {
            if (!gameActive || currentPlayer !== 'X') return;

            // More likely to chat when there are more viewers watching YOUR game
            let conversationChance = 0.3; // 30% base
            if (spectators > 1000) conversationChance = 0.5;
            if (spectators > 10000) conversationChance = 0.7;
            if (spectators > 50000) conversationChance = 0.9;

            if (Math.random() < conversationChance) {
                // Pick 2 random players for conversation
                const player1 = playerNames[Math.floor(Math.random() * playerNames.length)];
                let player2 = playerNames[Math.floor(Math.random() * playerNames.length)];
                while (player2 === player1) {
                    player2 = playerNames[Math.floor(Math.random() * playerNames.length)];
                }

                // Conversation templates
                const conversations = [
                    // Hype conversations
                    { p1: 'anyone else hyped?', p2: 'SO HYPED', delay: 1200 },
                    { p1: 'this is gonna be good', p2: 'for real', delay: 1000 },
                    { p1: 'lets gooo', p2: 'HYPE', delay: 800 },
                    { p1: 'who winning this?', p2: 'player for sure', delay: 1300 },
                    { p1: 'ez win incoming', p2: 'doubt', delay: 1100 },

                    // Casual chat
                    { p1: 'gl everyone', p2: 'u2!', delay: 900 },
                    { p1: 'first time watching?', p2: 'nah been here', delay: 1400 },
                    { p1: 'this player is nuts', p2: 'fr fr', delay: 1000 },
                    { p1: 'bet they win this', p2: 'hope so', delay: 1200 },
                    { p1: 'clutch potential?', p2: 'maybe', delay: 1000 },

                    // Tournament specific
                    { p1: 'big tournament energy', p2: 'stakes are high', delay: 1300 },
                    { p1: 'imagine losing here', p2: 'would be tragic', delay: 1400 },
                    { p1: 'chat moving fast', p2: 'tons of people here', delay: 1200 },
                    { p1: 'whos donated the most?', p2: 'idk but its a lot', delay: 1500 },

                    // Funny banter
                    { p1: 'im eating popcorn rn', p2: 'same lol', delay: 1100 },
                    { p1: 'should i donate', p2: 'DO IT', delay: 900 },
                    { p1: 'my mouse died', p2: 'rip', delay: 800 },
                    { p1: 'lag?', p2: 'nope just you', delay: 1000 },
                    { p1: 'this game is addicting', p2: 'been here 3 hours', delay: 1400 },

                    // Strategy talk
                    { p1: 'that was smart', p2: 'big brain play', delay: 1200 },
                    { p1: 'predict the next move', p2: 'probably center', delay: 1300 },
                    { p1: 'AI looking tough', p2: 'yeah this is hard', delay: 1200 },
                    { p1: 'comeback possible?', p2: 'still in it', delay: 1100 },

                    // Meta chat
                    { p1: 'wish i was playing', p2: 'same fr', delay: 1000 },
                    { p1: 'spectating is fun tho', p2: 'true no pressure', delay: 1300 },
                    { p1: 'donate gang', p2: 'üí∞üí∞üí∞', delay: 900 },
                    { p1: 'W stream', p2: 'W community', delay: 1100 },

                    // Economy chat
                    { p1: 'taxes are brutal', p2: 'government taking everything üíÄ', delay: 1400 },
                    { p1: 'how much they won so far?', p2: 'not enough after tax lol', delay: 1500 },
                    { p1: 'i rebirthed yesterday', p2: 'worth it?', delay: 1200 },
                    { p1: 'shop prices crazy', p2: 'inflation hit different', delay: 1300 },
                    { p1: 'whale incoming?', p2: 'hopefully üêã', delay: 1100 }
                ];

                const convo = conversations[Math.floor(Math.random() * conversations.length)];

                // First message
                addChatMessage(player1, convo.p1);

                // Reply after delay
                setTimeout(() => {
                    addChatMessage(player2, convo.p2);
                }, convo.delay);
            }
        }, 7000); // Check every 7 seconds

        function showMoneyWon(amount) {
            const popup = document.getElementById('moneyWonPopup');
            const amountEl = document.getElementById('moneyWonAmount');
            
            amountEl.textContent = '+$' + amount.toLocaleString();
            popup.classList.add('show');
            
            playSound('win');
            
            setTimeout(() => {
                popup.classList.remove('show');
            }, 3000);
        }

        function addChatMessage(player, message) {
            const chatFeed = document.getElementById('chatFeed');
            const msgDiv = document.createElement('div');
            msgDiv.className = 'chat-message';
            msgDiv.innerHTML = `<span class="chat-player">${player}</span>: ${message}`;
            chatFeed.appendChild(msgDiv);
            chatFeed.scrollTop = chatFeed.scrollHeight;

            // Keep only last 10 messages
            while (chatFeed.children.length > 10) {
                chatFeed.removeChild(chatFeed.firstChild);
            }
        }

        // MASSIVE CHAT SPAM FUNCTION! Percentage of viewers spam messages!
        function massiveChatSpam(percentage, messageArray, duration = 3000) {
            // Calculate how many people spam (based on SPECTATORS watching YOU, not total online)
            const spammerCount = Math.floor(spectators * percentage);
            const messagesPerSecond = Math.min(spammerCount / (duration / 1000), 30); // Cap at 30 msg/sec
            const totalMessages = Math.min(spammerCount, 100); // Cap at 100 total messages

            // Don't spam if there aren't enough viewers!
            if (totalMessages < 1) return;

            // Spam messages over the duration
            for (let i = 0; i < totalMessages; i++) {
                setTimeout(() => {
                    const player = playerNames[Math.floor(Math.random() * playerNames.length)];
                    const message = messageArray[Math.floor(Math.random() * messageArray.length)];
                    addChatMessage(player, message);
                }, Math.random() * duration); // Random timing spread over duration
            }
        }

        function showAchievement(title, desc) {
            const popup = document.getElementById('achievementPopup');
            document.getElementById('achievementDesc').textContent = desc;
            popup.classList.add('show');
            playSound('win');
            setTimeout(() => {
                popup.classList.remove('show');
            }, 3000);
        }

        function updateStats() {
            document.getElementById('winStreak').textContent = winStreak;
            document.getElementById('bestStreak').textContent = bestStreak;
            document.getElementById('totalWins').textContent = totalWins;
            document.getElementById('globalRank').textContent = globalRank.toLocaleString();
        }

        function generateLeaderboard() {
            const list = document.getElementById('leaderboardList');
            list.innerHTML = '';
            
            const leaders = [];
            for (let i = 0; i < 20; i++) {
                leaders.push({
                    name: playerNames[Math.floor(Math.random() * playerNames.length)] + Math.floor(Math.random() * 1000),
                    streak: Math.floor(Math.random() * 50) + 1
                });
            }
            
            // Add player
            leaders.push({ name: 'YOU', streak: winStreak });
            leaders.sort((a, b) => b.streak - a.streak);
            
            leaders.forEach((leader, i) => {
                const entry = document.createElement('div');
                entry.className = 'leaderboard-entry' + (leader.name === 'YOU' ? ' you' : '');
                
                let rankClass = '';
                if (i === 0) rankClass = 'gold';
                else if (i === 1) rankClass = 'silver';
                else if (i === 2) rankClass = 'bronze';
                
                entry.innerHTML = `
                    <div class="rank ${rankClass}">#${i + 1}</div>
                    <div class="player-name">${leader.name}</div>
                    <div class="streak">${leader.streak} üî•</div>
                `;
                list.appendChild(entry);
            });
            
            // Update global rank
            globalRank = leaders.findIndex(l => l.name === 'YOU') + 1;
            updateStats();
        }

        function showLeaderboard() {
            generateLeaderboard();
            document.getElementById('leaderboardModal').classList.add('show');
        }

        function closeLeaderboard() {
            document.getElementById('leaderboardModal').classList.remove('show');
        }

        function closeCheatMenu() {
            document.getElementById('cheatMenu').classList.remove('show');
        }

        // Cheat functions
        function instantWin() {
            cheatsActive = true;
            document.getElementById('cheatIndicator').classList.add('show');
            
            reactiveChat('instant_win');
            
            // Find winning combo for player
            for (let condition of winConditions) {
                const [a, b, c] = condition;
                if (megaBoard[a] === '' && megaBoard[b] === '' && megaBoard[c] === '') {
                    // Win these boards
                    [a, b, c].forEach(board => {
                        if (megaBoard[board] === '') {
                            megaBoard[board] = 'X';
                            markBoardWon(board, 'X');
                        }
                    });
                    endGame('X');
                    return;
                }
            }
        }

        function toggleHints() {
            hintsEnabled = !hintsEnabled;
            document.getElementById('hintStatus').textContent = hintsEnabled ? 'ON' : 'OFF';
            
            if (hintsEnabled) {
                cheatsActive = true;
                document.getElementById('cheatIndicator').classList.add('show');
                addChatMessage('System', 'üí° Hints enabled');
                updateHint();
            } else {
                document.querySelectorAll('.cell').forEach(c => c.classList.remove('hint'));
                addChatMessage('System', 'üí° Hints disabled');
            }
        }

        function updateHint() {
            if (!hintsEnabled) return;
            
            document.querySelectorAll('.cell').forEach(c => c.classList.remove('hint'));
            
            // Get ALL available moves across ALL boards
            const moves = getAvailableMoves();
            
            if (moves.length > 0 && gameActive && currentPlayer === 'X') {
                // Evaluate ALL possible moves
                let bestMove = null;
                let bestScore = -Infinity;

                moves.forEach(move => {
                    const score = evaluateMoveForPlayer(move);
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                });

                // Show the absolute best move across ALL boards
                if (bestMove) {
                    const cell = document.querySelector(`[data-board="${bestMove.board}"][data-cell="${bestMove.cell}"]`);
                    if (cell && !cell.classList.contains('taken')) {
                        cell.classList.add('hint');
                    }
                }
            }
        }

        function evaluateMoveForPlayer(move) {
            let score = 0;

            // MEGA BOARD WINNING - HIGHEST PRIORITY
            // Check if this move would directly win a small board that completes a mega board win
            const tempMiniBoard = [...miniBoards[move.board]];
            tempMiniBoard[move.cell] = 'X';
            if (checkWin(tempMiniBoard)) {
                // This wins the small board, check if it wins mega board
                const tempMegaBoard = [...megaBoard];
                tempMegaBoard[move.board] = 'X';
                if (checkWin(tempMegaBoard)) {
                    score += 10000; // INSTANT WIN!
                }
                
                // Check if this creates a 2-in-a-row on mega board
                for (let condition of winConditions) {
                    const [a, b, c] = condition;
                    const boards = [tempMegaBoard[a], tempMegaBoard[b], tempMegaBoard[c]];
                    if (boards.filter(b => b === 'X').length === 2 && boards.includes('')) {
                        score += 500; // Sets up mega board win
                    }
                }
                
                score += 100; // Winning any board is good
            }

            // BLOCK OPPONENT FROM WINNING MEGA BOARD
            const blockMiniBoard = [...miniBoards[move.board]];
            blockMiniBoard[move.cell] = 'O';
            if (checkWin(blockMiniBoard)) {
                const tempMegaBoard = [...megaBoard];
                tempMegaBoard[move.board] = 'O';
                if (checkWin(tempMegaBoard)) {
                    score += 8000; // MUST BLOCK opponent from winning!
                }
                
                // Check if opponent would get 2-in-a-row on mega board
                for (let condition of winConditions) {
                    const [a, b, c] = condition;
                    const boards = [tempMegaBoard[a], tempMegaBoard[b], tempMegaBoard[c]];
                    if (boards.filter(b => b === 'O').length === 2 && boards.includes('')) {
                        score += 400; // Must block this threat
                    }
                }
                
                score += 60; // Blocking any board win is important
            }

            // STRATEGIC POSITIONING
            // Prefer center cells (more winning combinations)
            if (move.cell === 4) score += 15;
            // Prefer corners (second best)
            if ([0, 2, 6, 8].includes(move.cell)) score += 8;

            // BOARD CONTROL - prefer sending opponent to bad boards
            // If opponent would go to a won/full board (can play anywhere), that's good
            if (megaBoard[move.cell] !== '') {
                score += 50; // Opponent sent to dead board
            }
            // If opponent goes to a board where we have 2-in-a-row, that's bad
            else if (miniBoards[move.cell]) {
                const opponentBoard = miniBoards[move.cell];
                const tempOpponentBoard = [...opponentBoard];
                for (let i = 0; i < 9; i++) {
                    if (tempOpponentBoard[i] === '') {
                        tempOpponentBoard[i] = 'X';
                        if (checkWin(tempOpponentBoard)) {
                            score -= 30; // Opponent could win this board
                        }
                        tempOpponentBoard[i] = '';
                    }
                }
            }

            return score;
        }

        function toggleAutoPlay() {
            autoPlayEnabled = !autoPlayEnabled;
            document.getElementById('autoPlayStatus').textContent = autoPlayEnabled ? 'ON' : 'OFF';
            cheatsActive = autoPlayEnabled;
            document.getElementById('cheatIndicator').classList.toggle('show', cheatsActive);
            
            if (autoPlayEnabled) {
                reactiveChat('cheat_detected');
            }
            
            if (autoPlayEnabled && currentPlayer === 'X' && gameActive) {
                setTimeout(autoPlayMove, 500);
            }
        }

        function autoPlayMove() {
            if (!autoPlayEnabled || !gameActive || currentPlayer !== 'X') return;
            
            const move = impossibleAI();
            if (move) {
                makeMove(move.board, move.cell);
            }
        }

        function toggleRainbow() {
            const isEnabled = document.body.classList.toggle('rainbow-mode');
            document.getElementById('rainbowStatus').textContent = isEnabled ? 'ON' : 'OFF';
        }

        function boostOnlinePlayers() {
            targetOnline += 10000;
            currentOnline += 10000;
            document.getElementById('onlineCount').textContent = Math.floor(currentOnline).toLocaleString();

            // Chat reacts!
            addChatMessage('System', 'üöÄ Server capacity increased! +10K players online!');
            setTimeout(() => {
                const reactions = [
                    'YOOO MORE PEOPLE!',
                    'server poppin off',
                    'huge crowd now',
                    'everyone\'s watching!',
                    'this is getting big',
                    'BLOWN UP'
                ];
                addChatMessage(playerNames[Math.floor(Math.random() * playerNames.length)],
                    reactions[Math.floor(Math.random() * reactions.length)]);
            }, 500);
        }

        function addWinStreak() {
            winStreak += 10;
            if (winStreak > bestStreak) bestStreak = winStreak;
            totalWins += 10;
            updateStats();
        }

        function maxStats() {
            winStreak = 999;
            bestStreak = 999;
            totalWins = 9999;
            globalRank = 1;
            updateStats();
        }

        function togglePlayAnywhere() {
            playAnywhereEnabled = !playAnywhereEnabled;
            document.getElementById('playAnywhereStatus').textContent = playAnywhereEnabled ? 'ON' : 'OFF';
            cheatsActive = playAnywhereEnabled || overwriteMovesEnabled || autoPlayEnabled || hintsEnabled;
            document.getElementById('cheatIndicator').classList.toggle('show', cheatsActive);

            if (playAnywhereEnabled) {
                addChatMessage('System', 'üéØ Play Anywhere enabled');
                unlockAchievement('cheater'); // Unlock cheater achievement
                if (Math.random() < 0.5) {
                    setTimeout(() => {
                        const player = playerNames[Math.floor(Math.random() * playerNames.length)];
                        const suspiciousMessages = ['wait how did you move there???', 'thats not legal lol', 'huh??', 'MODS'];
                        addChatMessage(player, suspiciousMessages[Math.floor(Math.random() * suspiciousMessages.length)]);
                    }, 1000);
                }
            } else {
                addChatMessage('System', 'üéØ Play Anywhere disabled');
            }
        }

        function toggleOverwriteMoves() {
            overwriteMovesEnabled = !overwriteMovesEnabled;
            document.getElementById('overwriteStatus').textContent = overwriteMovesEnabled ? 'ON' : 'OFF';
            cheatsActive = playAnywhereEnabled || overwriteMovesEnabled || autoPlayEnabled || hintsEnabled;
            document.getElementById('cheatIndicator').classList.toggle('show', cheatsActive);

            if (overwriteMovesEnabled) {
                addChatMessage('System', '‚úèÔ∏è Overwrite Moves enabled');
                unlockAchievement('cheater'); // Unlock cheater achievement
                if (Math.random() < 0.5) {
                    setTimeout(() => {
                        const player = playerNames[Math.floor(Math.random() * playerNames.length)];
                        const confusedMessages = ['did that move just change??', 'am i going crazy', 'wtf???', 'glitching rn', 'BRO WHAT'];
                        addChatMessage(player, confusedMessages[Math.floor(Math.random() * confusedMessages.length)]);
                    }, 1200);
                }
            } else {
                addChatMessage('System', '‚úèÔ∏è Overwrite Moves disabled');
            }
        }

        function toggleInstantBoardWin() {
            instantBoardWinEnabled = !instantBoardWinEnabled;
            document.getElementById('instantBoardWinStatus').textContent = instantBoardWinEnabled ? 'ON' : 'OFF';
            cheatsActive = playAnywhereEnabled || overwriteMovesEnabled || autoPlayEnabled || hintsEnabled || instantBoardWinEnabled;
            document.getElementById('cheatIndicator').classList.toggle('show', cheatsActive);

            if (instantBoardWinEnabled) {
                addChatMessage('System', 'üéØ Instant Board Win enabled (Left=X, Right=O)');
                unlockAchievement('cheater');
                setTimeout(() => {
                    const player = playerNames[Math.floor(Math.random() * playerNames.length)];
                    const messages = ['wait how did that board just get won???', 'MODS', 'board just disappeared', 'huh???', 'this is rigged'];
                    addChatMessage(player, messages[Math.floor(Math.random() * messages.length)]);
                }, 1200);
            } else {
                addChatMessage('System', 'üéØ Instant Board Win disabled');
            }
        }

        function instantWinBoard(boardIndex, winner) {
            if (!gameActive) return;
            if (megaBoard[boardIndex] !== '') return; // Already won

            // Mark the board as won
            megaBoard[boardIndex] = winner;
            markBoardWon(boardIndex, winner);

            // Chat reacts!
            if (Math.random() < 0.6) {
                setTimeout(() => {
                    const player = playerNames[Math.floor(Math.random() * playerNames.length)];
                    const reactions = [
                        'did anyone else see that?',
                        'board glitched',
                        'instant win???',
                        'WHAT JUST HAPPENED',
                        'magic board',
                        'hacker confirmed',
                        'sus board',
                        'teleported to victory'
                    ];
                    addChatMessage(player, reactions[Math.floor(Math.random() * reactions.length)]);
                }, 500);
            }

            // Check if game is won
            const megaWinner = checkWin(megaBoard);
            if (megaWinner) {
                endGame(megaWinner);
            }
        }

        // Achievement System
        function unlockAchievement(id) {
            if (achievements.includes(id)) return false;

            const achievement = allAchievements.find(a => a.id === id);
            if (!achievement) return false;

            achievements.push(id);
            localStorage.setItem('tttAchievements', JSON.stringify(achievements));
            showAchievement(achievement.name, achievement.desc);
            return true;
        }

        function checkAchievements() {
            allAchievements.forEach(achievement => {
                if (!achievements.includes(achievement.id) && achievement.check()) {
                    unlockAchievement(achievement.id);
                }
            });
        }

        function showAchievements() {
            const listEl = document.getElementById('achievementsList');

            listEl.innerHTML = allAchievements.map(achievement => {
                const unlocked = achievements.includes(achievement.id);

                return `
                    <div class="leaderboard-entry ${unlocked ? '' : ''}" style="opacity: ${unlocked ? '1' : '0.5'};">
                        <div style="flex: 1;">
                            <div style="font-weight: bold; margin-bottom: 3px;">${achievement.name}</div>
                            <div style="font-size: 0.85em; opacity: 0.9;">${achievement.desc}</div>
                        </div>
                        <div style="font-size: 1.5em;">${unlocked ? '‚úÖ' : 'üîí'}</div>
                    </div>
                `;
            }).join('');

            document.getElementById('achievementsModal').classList.add('show');
        }

        function closeAchievements() {
            document.getElementById('achievementsModal').classList.remove('show');
        }

        // Shop System
        function showShop() {
            const listEl = document.getElementById('shopList');
            document.getElementById('shopBalance').textContent = bankBalance.toLocaleString();

            listEl.innerHTML = shopItems.map(item => {
                const purchased = purchasedItems.includes(item.id);
                const canAfford = bankBalance >= item.price;

                return `
                    <div class="tournament-card ${purchased ? '' : (canAfford ? '' : 'locked')}"
                         onclick="${purchased ? '' : (canAfford ? `buyItem('${item.id}')` : '')}"
                         style="cursor: ${purchased ? 'default' : (canAfford ? 'pointer' : 'not-allowed')};">
                        <div class="tournament-name">${item.name}</div>
                        <div class="tournament-details" style="margin: 8px 0;">
                            ${item.desc}
                        </div>
                        <div class="tournament-details" style="font-size: 1.2em; color: #ffd700;">
                            üí∞ $${item.price.toLocaleString()}
                        </div>
                        ${purchased ? '<div style="color: #43e97b; font-size: 1.1em; margin-top: 8px;">‚úÖ OWNED</div>' : ''}
                        ${!canAfford && !purchased ? '<div style="color: #ff6b6b; font-size: 0.9em; margin-top: 5px;">‚ùå Not enough money</div>' : ''}
                    </div>
                `;
            }).join('');

            document.getElementById('shopModal').classList.add('show');
        }

        function closeShop() {
            document.getElementById('shopModal').classList.remove('show');
        }

        function buyItem(itemId) {
            const item = shopItems.find(i => i.id === itemId);
            if (!item) return;

            if (purchasedItems.includes(itemId)) {
                alert('You already own this! üéâ');
                return;
            }

            if (bankBalance < item.price) {
                alert('Not enough money! üí∏');
                return;
            }

            // Purchase item
            bankBalance -= item.price;
            purchasedItems.push(itemId);
            localStorage.setItem('tttPurchased', JSON.stringify(purchasedItems));
            updateBankDisplay();
            addTransaction('purchase', -item.price, `üõí Bought: ${item.name}`);

            // Apply item effects immediately
            applyItemEffects(itemId);

            // Show success
            playSound('win');
            spawnEmote('üí∞');
            addChatMessage('System', `‚úÖ Purchased ${item.name}!`);

            // Reactions from chat
            setTimeout(() => {
                const reactions = ['BIG SPENDER!', 'whale alert!', 'rich guy', 'ok mr money bags', 'FLEX'];
                addChatMessage(playerNames[Math.floor(Math.random() * playerNames.length)],
                    reactions[Math.floor(Math.random() * reactions.length)]);
            }, 800);

            // Refresh shop
            showShop();
        }

        function applyItemEffects(itemId) {
            switch(itemId) {
                case 'rainbow_board':
                    document.body.classList.add('rainbow-mode');
                    document.getElementById('rainbowStatus').textContent = 'ON';
                    break;
                case 'instant_rank_1':
                    globalRank = 1;
                    updateStats();
                    break;
                case 'god_mode':
                    addChatMessage('System', '‚ö° GOD MODE ACTIVATED ‚ö°');
                    setTimeout(() => {
                        addChatMessage(playerNames[Math.floor(Math.random() * playerNames.length)], 'uh oh');
                    }, 1000);
                    setTimeout(() => {
                        addChatMessage(playerNames[Math.floor(Math.random() * playerNames.length)], 'this guy cant lose now');
                    }, 2000);
                    break;
                case 'money_printer':
                    addChatMessage('System', 'üñ®Ô∏è Money Printer activated! Earning $800/min');
                    setInterval(() => {
                        if (purchasedItems.includes('money_printer')) {
                            bankBalance += 800;
                            updateBankDisplay();
                        }
                    }, 60000);
                    break;
            }
        }

        function hasItem(itemId) {
            return purchasedItems.includes(itemId);
        }

        // Rich Whale System
        function spawnRichWhale() {
            if (richWhaleActive || spectators < 5000) return;

            richWhaleActive = true;
            const whaleName = ['xXMegaWhaleXx', 'BillionaireGaming', 'RichDude2024', 'MoneyBagz', 'LuxuryPlayer', 'DiamondHands', 'CryptoKing'][Math.floor(Math.random() * 7)];

            // Sound effect!
            playSound('whale');

            // Chat goes CRAZY
            setTimeout(() => {
                addChatMessage('System', `üíé ${whaleName} (MEGA WHALE) has joined! üíé`);
            }, 200);

            setTimeout(() => {
                addChatMessage(playerNames[Math.floor(Math.random() * playerNames.length)], 'YOOO A WHALE!!!');
            }, 800);

            setTimeout(() => {
                addChatMessage(playerNames[Math.floor(Math.random() * playerNames.length)], 'BIG MONEY IN THE CHAT');
            }, 1400);

            setTimeout(() => {
                addChatMessage(playerNames[Math.floor(Math.random() * playerNames.length)], 'we bout to get PAID üí∞');
            }, 2000);

            // Whale donates every 3-6 seconds (MORE FREQUENT!)
            let donationCount = 0;
            const maxDonations = 15 + Math.floor(Math.random() * 25); // 15-40 donations (WAY MORE!)

            richWhaleInterval = setInterval(() => {
                if (!gameActive || !richWhaleActive || donationCount >= maxDonations) {
                    clearInterval(richWhaleInterval);
                    richWhaleActive = false;
                    if (donationCount >= maxDonations) {
                        setTimeout(() => {
                            addChatMessage(whaleName, 'gg gotta go üëã');
                            setTimeout(() => {
                                addChatMessage(playerNames[Math.floor(Math.random() * playerNames.length)], 'thanks for the dono king');
                            }, 800);
                        }, 2000);
                    }
                    return;
                }

                // Whale donates MASSIVE MONEY (scales with spectators!)
                let minDono = 2000;
                let maxDono = 10000;

                if (spectators > 50000) { minDono = 5000; maxDono = 25000; }
                if (spectators > 100000) { minDono = 10000; maxDono = 50000; }
                if (spectators > 500000) { minDono = 25000; maxDono = 100000; } // THE FINAL BOSS whale

                const donation = minDono + Math.floor(Math.random() * (maxDono - minDono));
                spawnDonation(donation);

                // Whale messages scale with donation size
                let whaleMessage;
                if (donation >= 50000) {
                    whaleMessage = `üíéüíé DONATED $${donation}!! YOU GOT THIS!! üíéüíé`;
                } else if (donation >= 20000) {
                    whaleMessage = `üíé donated $${donation}! CARRYING YOU!`;
                } else if (donation >= 10000) {
                    whaleMessage = `üíµ donated $${donation}! Keep it up!`;
                } else {
                    whaleMessage = `üí∞ donated $${donation}! Let's go!`;
                }

                addChatMessage(whaleName, whaleMessage);

                // Chat reacts to BIG donations
                if (donation >= 20000 && Math.random() < 0.7) {
                    setTimeout(() => {
                        const bigReactions = [
                            'HOLY WHALE',
                            'THIS GUY IS INSANE',
                            'DROP THE WALLET',
                            'BIG MONEY MOVES',
                            'CASUALLY DROPPING BAGS',
                            'ACTUAL BILLIONAIRE',
                            'im broke watching this'
                        ];
                        addChatMessage(playerNames[Math.floor(Math.random() * playerNames.length)],
                            bigReactions[Math.floor(Math.random() * bigReactions.length)]);
                    }, 400);
                }

                donationCount++;
            }, 3000 + Math.random() * 3000); // Every 3-6 seconds (FASTER!)
        }

        // Matchmaking animation
        function showMatchmaking() {
            const statuses = ['Finding opponent...', 'Connecting...', 'Match found!'];
            let i = 0;
            const interval = setInterval(() => {
                document.getElementById('status').textContent = statuses[i] + ' üîç';
                i++;
                if (i >= statuses.length) {
                    clearInterval(interval);
                    setTimeout(() => {
                        updateActiveBoard();
                    }, 500);
                }
            }, 700);
        }

        function createBoard() {
            const megaBoardEl = document.getElementById('megaBoard');
            megaBoardEl.innerHTML = '';

            for (let i = 0; i < 9; i++) {
                const miniBoardEl = document.createElement('div');
                miniBoardEl.className = 'mini-board';
                miniBoardEl.dataset.board = i;

                // CHEAT: Instant Board Win (left-click = X wins, right-click = O wins)
                // Click ANYWHERE in the mini board!
                miniBoardEl.addEventListener('click', (e) => {
                    if (!instantBoardWinEnabled) return;
                    // Use currentTarget to get the mini-board, not the clicked element
                    const boardIndex = parseInt(e.currentTarget.dataset.board);
                    instantWinBoard(boardIndex, 'X');
                    e.stopPropagation();
                    e.preventDefault();
                });

                miniBoardEl.addEventListener('contextmenu', (e) => {
                    if (!instantBoardWinEnabled) return;
                    e.preventDefault();
                    // Use currentTarget to get the mini-board, not the clicked element
                    const boardIndex = parseInt(e.currentTarget.dataset.board);
                    instantWinBoard(boardIndex, 'O');
                    e.stopPropagation();
                });

                for (let j = 0; j < 9; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.board = i;
                    cell.dataset.cell = j;
                    cell.addEventListener('click', handleCellClick);
                    miniBoardEl.appendChild(cell);
                }

                megaBoardEl.appendChild(miniBoardEl);
            }
        }

        function handleCellClick(e) {
            if (!gameActive || currentPlayer !== 'X') return;

            const boardIndex = parseInt(e.target.dataset.board);
            const cellIndex = parseInt(e.target.dataset.cell);

            // CHEAT: Play Anywhere - ignore board restrictions
            if (!playAnywhereEnabled) {
                if (activeBoard !== null && activeBoard !== boardIndex) return;
                if (megaBoard[boardIndex] !== '') return;
            }

            // CHEAT: Overwrite Moves - can click on taken cells
            if (!overwriteMovesEnabled) {
                if (miniBoards[boardIndex][cellIndex] !== '') return;
            } else {
                // If overwriting, clear the cell first
                if (miniBoards[boardIndex][cellIndex] !== '') {
                    miniBoards[boardIndex][cellIndex] = '';
                    // Update visual
                    const cells = document.querySelectorAll(`[data-board="${boardIndex}"][data-cell="${cellIndex}"]`);
                    cells.forEach(cell => {
                        cell.textContent = '';
                        cell.classList.remove('x', 'o', 'taken', 'ai-move', 'last-move');
                    });
                }
            }

            playSound('click');
            makeMove(boardIndex, cellIndex);
        }

        function makeMove(boardIndex, cellIndex, isAI = false) {
            if (!isAI) moveCount++;

            miniBoards[boardIndex][cellIndex] = currentPlayer;
            updateCell(boardIndex, cellIndex, isAI);

            // TOURNAMENT SPAM - Chat goes CRAZY for 5 seconds on tournament moves!
            if (!isAI && currentPlayer === 'X' && currentTournament) {
                const tournamentSpamMessages = [
                    'LETS GO!', 'POGGERS', 'good move', 'nice!', 'W', 'smart play',
                    'BIG BRAIN', 'calculated', 'ez', 'clean', 'CARRY', 'GOAT',
                    'sheesh', 'POG', 'GG', 'insane', 'cracked', 'built different'
                ];

                // Spam messages every 300ms for 5 seconds (17 messages total)
                for (let i = 0; i < 17; i++) {
                    setTimeout(() => {
                        const player = playerNames[Math.floor(Math.random() * playerNames.length)];
                        const message = tournamentSpamMessages[Math.floor(Math.random() * tournamentSpamMessages.length)];
                        addChatMessage(player, message);
                    }, i * 300);
                }
            }

            // 25% OF CHAT SPAMS ON EVERY SINGLE MOVE!! (SOMEHOW?! üò≠)
            // Only if there are ENOUGH viewers watching YOUR game!
            if (!isAI && currentPlayer === 'X' && spectators > 500) {
                const anyMoveMessages = [
                    'nice', 'ok', 'i see', 'interesting', 'hmm', 'lets see', 'yep',
                    'good', 'solid', 'okay', 'bet', 'aight', 'kk', 'mhm', 'sure',
                    'oooh', 'alright', 'cool', 'got it', 'makes sense', 'fair',
                    'lol', 'bruh', 'wait', 'yo', 'huh', 'what', 'oh', 'uhh',
                    'üëÄ', 'üëç', 'ü§î', 'fr?', 'ngl', 'tbh', 'lowkey', 'highkey'
                ];

                // 25% OF VIEWERS SPAM (FOR SOME REASON!)
                massiveChatSpam(0.25, anyMoveMessages, 1500);
            }

            // INTERACTIVE CHAT - React to specific moves!
            if (!isAI && currentPlayer === 'X' && spectators > 100 && Math.random() < 0.15) {
                const interactiveMessages = [];

                // React to center moves
                if (cellIndex === 4) {
                    interactiveMessages.push('center play!', 'smart move', 'going for center', 'nice positioning');
                }

                // React to corner moves
                if ([0, 2, 6, 8].includes(cellIndex)) {
                    interactiveMessages.push('corner strat', 'classic corner', 'playing corners i see');
                }

                // React to risky plays
                if (megaBoard.filter(b => b === 'O').length > megaBoard.filter(b => b === 'X').length) {
                    interactiveMessages.push('comeback time?', 'trying to catch up', 'still in this');
                }

                // General hype
                interactiveMessages.push('good move', 'nice', 'i see you', 'interesting', 'POGGERS');

                if (interactiveMessages.length > 0) {
                    setTimeout(() => {
                        addChatMessage(playerNames[Math.floor(Math.random() * playerNames.length)],
                            interactiveMessages[Math.floor(Math.random() * interactiveMessages.length)]);
                    }, 400);
                }
            }

            const boardWon = checkWin(miniBoards[boardIndex]);
            if (boardWon) {
                megaBoard[boardIndex] = currentPlayer;
                markBoardWon(boardIndex, currentPlayer);

                // PLAYER WINS A MINI BOARD - 75% OF CHAT GOES CRAZY!!
                // Only if there are enough viewers watching YOUR game!
                if (!isAI && currentPlayer === 'X' && spectators > 200) {
                    // Chat spam messages for board wins
                    const boardWinMessages = [
                        'NICE BOARD!', 'LETS GO!', 'clean board win', 'POG', 'gg that board',
                        'well played', 'üî•', 'nice', 'W', 'clutch board', 'POGGIES',
                        'CLEAN', 'SHEESH', 'HUGE', 'GG', 'that was nasty', 'EZ BOARD',
                        'gg wp', 'calculated', 'BIG BRAIN', 'pro plays', 'outplayed',
                        'skill issue (for AI)', 'GOT EM', 'DOMINATED', 'too ez'
                    ];

                    // 75% OF VIEWERS SPAM! (ABSOLUTE CHAOS!)
                    massiveChatSpam(0.75, boardWinMessages, 2500);

                    // Donation chance - higher with more spectators
                    let boardWinDonationChance = 0;

                    if (spectators < 200) boardWinDonationChance = 0.15; // 15%
                    else if (spectators < 500) boardWinDonationChance = 0.3; // 30%
                    else if (spectators < 1000) boardWinDonationChance = 0.45; // 45%
                    else if (spectators < 5000) boardWinDonationChance = 0.6; // 60%
                    else if (spectators < 10000) boardWinDonationChance = 0.8; // 80%
                    else boardWinDonationChance = 0.95; // 95% for massive audiences

                    if (Math.random() < boardWinDonationChance) {
                        setTimeout(() => {
                            let minDono = 3;
                            let maxDono = 15;

                            if (spectators > 1000) { minDono = 8; maxDono = 30; }
                            if (spectators > 5000) { minDono = 15; maxDono = 60; }
                            if (spectators > 10000) { minDono = 25; maxDono = 120; }

                            const donation = Math.floor(Math.random() * (maxDono - minDono + 1)) + minDono;
                            spawnDonation(donation);
                            const donor = playerNames[Math.floor(Math.random() * playerNames.length)];
                            addChatMessage(donor, `donated $${donation}!`);
                        }, 600);
                    }
                }

                // AI WINS A MINI BOARD - 50% OF CHAT BOOS!!
                // Only if there are enough viewers watching YOUR game!
                if (isAI && currentPlayer === 'O' && spectators > 200) {
                    const booMessages = [
                        'BOOO', 'BOO', 'nooo', 'rip', 'NOOOO', 'unlucky', 'sadge',
                        'L', 'oof', 'damn', 'bruh', 'pain', 'F', 'rough', 'tragic',
                        'comeback time', 'its over', 'we lost', 'gg go next', 'AI op',
                        'nerf AI', 'AI diff', 'skill issue', 'outplayed', 'bot diff',
                        'how', 'RIGGED', 'scripted', 'unfair', 'hacks', 'sus AI'
                    ];

                    // 50% OF VIEWERS BOO! (HALF THE CHAT!)
                    massiveChatSpam(0.50, booMessages, 2000);
                }
            } else if (!miniBoards[boardIndex].includes('')) {
                megaBoard[boardIndex] = 'TIE';
                markBoardWon(boardIndex, 'TIE');
            }

            const megaWinner = checkWin(megaBoard);
            if (megaWinner) {
                endGame(currentPlayer);
                return;
            }

            const allBoardsFull = megaBoard.every(b => b !== '');
            if (allBoardsFull) {
                endGame('TIE');
                return;
            }

            if (megaBoard[cellIndex] === '') {
                activeBoard = cellIndex;
            } else {
                activeBoard = null;
            }

            updateActiveBoard();
            changePlayer();

            // Update hint after move if hints are enabled
            if (hintsEnabled && currentPlayer === 'X') {
                setTimeout(updateHint, 100);
            }

            if (currentPlayer === 'O' && gameActive) {
                document.getElementById('status').textContent = 'Opponent thinking... ü§î';
                setTimeout(aiMove, 700);
            } else if (autoPlayEnabled && currentPlayer === 'X' && gameActive) {
                setTimeout(autoPlayMove, 500);
            }
        }

        function updateCell(boardIndex, cellIndex, isAI = false) {
            if (isAI) {
                document.querySelectorAll('.cell').forEach(c => c.classList.remove('last-move'));
            }
            
            const cells = document.querySelectorAll(`[data-board="${boardIndex}"][data-cell="${cellIndex}"]`);
            cells.forEach(cell => {
                cell.textContent = currentPlayer;
                cell.classList.add(currentPlayer.toLowerCase(), 'taken');
                if (isAI) {
                    cell.classList.add('ai-move', 'last-move');
                    setTimeout(() => cell.classList.remove('ai-move'), 600);
                }
            });
        }

        function markBoardWon(boardIndex, winner) {
            const board = document.querySelector(`[data-board="${boardIndex}"].mini-board`);
            board.classList.add('won');
            if (winner !== 'TIE') {
                board.classList.add(winner.toLowerCase() + '-won');
                board.dataset.winner = winner;
            }
        }

        function checkWin(board) {
            for (let condition of winConditions) {
                const [a, b, c] = condition;
                if (board[a] && 
                    board[a] !== '' && 
                    board[a] !== 'TIE' && 
                    board[a] === board[b] && 
                    board[a] === board[c]) {
                    return true;
                }
            }
            return false;
        }

        function updateActiveBoard() {
            document.querySelectorAll('.mini-board').forEach((board, i) => {
                board.classList.remove('active');
                if ((activeBoard === null && megaBoard[i] === '') || activeBoard === i) {
                    if (megaBoard[i] === '') {
                        board.classList.add('active');
                    }
                }
            });

            if (currentPlayer === 'X' && gameActive) {
                if (activeBoard === null) {
                    document.getElementById('status').textContent = 'Your turn! Play anywhere! üî•';
                } else {
                    document.getElementById('status').textContent = `Your turn! Play in glowing board! üéØ`;
                }
                
                // Update hint when board changes
                if (hintsEnabled) {
                    setTimeout(updateHint, 100);
                }
            }
        }

        function changePlayer() {
            currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
        }

        function endGame(winner) {
            // GOD MODE CHECK - Can't lose!
            if (hasItem('god_mode') && winner === 'O') {
                addChatMessage('System', '‚ö° GOD MODE: Converting loss to win!');
                setTimeout(() => {
                    addChatMessage(playerNames[Math.floor(Math.random() * playerNames.length)], 'WHAT');
                }, 600);
                setTimeout(() => {
                    addChatMessage(playerNames[Math.floor(Math.random() * playerNames.length)], 'he just won after losing???');
                }, 1400);
                setTimeout(() => {
                    addChatMessage(playerNames[Math.floor(Math.random() * playerNames.length)], 'report this guy');
                }, 2200);
                winner = 'X'; // Force win!
            }

            gameActive = false;
            const gameTime = (Date.now() - gameStartTime) / 1000; // seconds

            if (winner === 'X') {
                playSound('win');
                document.getElementById('status').textContent = 'üéâ VICTORY! üî•';
                scores.player++;
                document.getElementById('playerScore').textContent = scores.player;
                createConfetti(window.innerWidth / 2, window.innerHeight / 2);
                
                // Tournament winnings WITH TAXES!
                if (currentTournament) {
                    const grossWin = currentTournament.win * rebirthMultiplier;
                    const taxAmount = Math.floor(grossWin * taxRate);
                    const netWin = Math.floor(grossWin - taxAmount);

                    bankBalance += netWin;
                    updateBankDisplay();
                    addTransaction('win', netWin, `üèÜ ${currentTournament.name} Victory!`);
                    addTransaction('tax', -taxAmount, `üí∏ Government Tax (${(taxRate * 100)}%)`);

                    // BIG POPUP showing winnings
                    setTimeout(() => {
                        showMoneyWon(netWin);
                    }, 1500);

                    setTimeout(() => {
                        addChatMessage('System', `üí∞ Won $${grossWin.toLocaleString()}! After tax: $${netWin.toLocaleString()}`);
                        spawnEmote('üí∞');
                    }, 1000);

                    // Tax complaints from chat!
                    setTimeout(() => {
                        const taxComplaints = [
                            'RIP TAXES üíÄ',
                            'government moment',
                            'taxed to death',
                            '25% BRUTAL',
                            'they took your money lol',
                            'tax man got you',
                            'oof those taxes'
                        ];
                        addChatMessage(playerNames[Math.floor(Math.random() * playerNames.length)],
                            taxComplaints[Math.floor(Math.random() * taxComplaints.length)]);
                    }, 2000);
                    
                    currentTournament = null;
                    currentBet = 0;
                } else {
                    // Quick match small reward
                    const reward = 5 + Math.floor(Math.random() * 10);
                    bankBalance += reward;
                    updateBankDisplay();
                    addTransaction('win', reward, 'üéÆ Quick Match Win');
                    
                    // Small notification for quick match
                    setTimeout(() => {
                        spawnDonation(reward);
                    }, 1000);
                }
                
                // CHAT SPAM EXPLOSION when player wins!
                const chatSpamMessages = [
                    'GG!!',
                    'LETS GOOO',
                    'GGWP',
                    'clean win',
                    'ez clap',
                    'POG',
                    'that was insane',
                    'wp wp',
                    'GOAT',
                    'üî•üî•üî•',
                    'clutch!',
                    'too good',
                    'gg well played',
                    'absolute legend',
                    'SHEEEESH',
                    'W W W W W',
                    'MASSIVE W',
                    'NO WAY',
                    'POGGERS',
                    'THIS GUY IS CRACKED',
                    'insane gameplay',
                    'what a match!',
                    'GGs only',
                    'respect',
                    'built different',
                    'HES HIM',
                    'literal demon',
                    'HOW???',
                    'teach me pls',
                    'god tier',
                    'KING üëë',
                    'destroyed',
                    'monster plays',
                    'unbeatable',
                    'chad energy',
                    'absolute unit',
                    'goated fr',
                    'WENT CRAZY',
                    'certified beast',
                    'ayo???',
                    'nasty win',
                    'clean sweep',
                    'perfection',
                    'S tier player',
                    'not even close',
                    'made it look easy',
                    'calculated',
                    'GIGACHAD',
                    'legend status',
                    'hall of fame'
                ];

                // 90% OF ALL VIEWERS SPAM!! (ABSOLUTE INSANITY!! üî•üî•üî•)
                // Random duration between 6-13 seconds!
                // Only if there are enough viewers watching YOUR game!
                if (spectators > 100) {
                    const victorySpamDuration = 6000 + Math.floor(Math.random() * 7000); // 6000-13000ms
                    massiveChatSpam(0.90, chatSpamMessages, victorySpamDuration);
                }
                
                // Random viewer donations during wins - MORE VIEWERS = MORE DONATIONS!
                let donationChance = 0;
                let numDonations = 0;

                if (spectators < 100) {
                    donationChance = 0.2; // 20% chance, 1 donation
                    numDonations = 1;
                } else if (spectators < 500) {
                    donationChance = 0.5; // 50% chance, 1-2 donations
                    numDonations = Math.random() < 0.5 ? 1 : 2;
                } else if (spectators < 1000) {
                    donationChance = 0.7; // 70% chance, 2-3 donations
                    numDonations = 2 + Math.floor(Math.random() * 2);
                } else if (spectators < 5000) {
                    donationChance = 0.9; // 90% chance, 3-5 donations
                    numDonations = 3 + Math.floor(Math.random() * 3);
                } else if (spectators < 10000) {
                    donationChance = 1.0; // 100% chance, 5-8 donations
                    numDonations = 5 + Math.floor(Math.random() * 4);
                } else {
                    donationChance = 1.0; // 100% chance, 8-15 donations for HUGE audiences
                    numDonations = 8 + Math.floor(Math.random() * 8);
                }

                if (Math.random() < donationChance) {
                    // Stagger donations over time
                    for (let i = 0; i < numDonations; i++) {
                        setTimeout(() => {
                            // Donation amount scales with viewer count too
                            let minDonation = 5;
                            let maxDonation = 20;

                            if (spectators > 1000) {
                                minDonation = 10;
                                maxDonation = 50;
                            }
                            if (spectators > 5000) {
                                minDonation = 25;
                                maxDonation = 100;
                            }
                            if (spectators > 10000) {
                                minDonation = 50;
                                maxDonation = 250;
                            }

                            const donation = Math.floor(Math.random() * (maxDonation - minDonation + 1)) + minDonation;
                            spawnDonation(donation);
                            const donor = playerNames[Math.floor(Math.random() * playerNames.length)];
                            addChatMessage(donor, `donated $${donation}! üí∞`);
                        }, 1500 + (i * 800)); // Stagger donations
                    }
                }
                
                winStreak++;
                totalWins++;

                // Check for achievements!
                checkAchievements();

                // Specific difficulty achievements
                if (currentTournament) {
                    if (currentTournament.difficulty === 'expert') unlockAchievement('beat_expert');
                    if (currentTournament.difficulty === 'impossible') unlockAchievement('beat_impossible');
                    if (currentTournament.difficulty === 'nightmare') unlockAchievement('beat_nightmare');
                    if (currentTournament.difficulty === 'godlike') unlockAchievement('beat_godlike');
                    if (currentTournament.difficulty === 'yoadish') unlockAchievement('beat_yoad');

                    // Tournament-specific achievements
                    unlockAchievement('tournament_winner');
                    if (currentTournament.name === 'WHALE WARS üêã') unlockAchievement('whale_wars_winner');
                    if (currentTournament.name === 'THE FINAL BOSS üíé') unlockAchievement('final_boss_winner');
                    if (currentTournament.name === 'YOAD üò∫') unlockAchievement('yoad_legend');
                }

                // Fast win achievement
                if (gameTime < 30) unlockAchievement('fast_win');

                // Reactive chat based on conditions
                if (cheatsActive) {
                    reactiveChat('cheat_detected');
                } else if (gameTime < 30 && moveCount < 10) {
                    reactiveChat('fast_win');
                } else if (winStreak >= 5) {
                    reactiveChat('big_streak', { streak: winStreak });
                } else if (difficulty === 'impossible') {
                    reactiveChat('rage_quit');
                } else {
                    reactiveChat('normal_win');
                }
                
                if (winStreak > bestStreak) {
                    bestStreak = winStreak;
                    if (bestStreak === 3) showAchievement('üî• On Fire!', 'Win 3 games in a row');
                    if (bestStreak === 5) showAchievement('üåü Unstoppable!', 'Win 5 games in a row');
                    if (bestStreak === 10) showAchievement('üëë LEGEND!', 'Win 10 games in a row');
                }
                if (globalRank > 100) globalRank -= Math.floor(Math.random() * 50) + 10;
                updateStats();
                
                setTimeout(() => {
                    const opponent = playerNames[Math.floor(Math.random() * playerNames.length)];
                    addChatMessage(opponent, 'gg wp');
                }, 1500);
            } else if (winner === 'O') {
                playSound('lose');
                document.getElementById('status').textContent = 'üíÄ DEFEAT! Try again!';
                scores.ai++;
                document.getElementById('aiScore').textContent = scores.ai;
                
                // Lose tournament bet (already deducted, just record the loss)
                if (currentTournament) {
                    addTransaction('loss', 0, `üíÄ ${currentTournament.name} - Defeated`);
                    addChatMessage('System', `You lost $${currentBet}! üò≠`);
                    currentTournament = null;
                    currentBet = 0;
                }
                
                // CHAT BOOS AND LAUGHS when AI wins!
                const booMessages = [
                    'BOOOOO',
                    'L',
                    'rip',
                    'unlucky',
                    'better luck next time',
                    'gg tho',
                    'close one',
                    'F',
                    'almost had it',
                    'tough loss',
                    'gg anyway',
                    'L + ratio',
                    'sadge',
                    'oof',
                    'rip bozo',
                    'KEKW',
                    'you tried',
                    'next time king',
                    'F in chat',
                    'so close!',
                    'unlucky really',
                    'it happens',
                    'dont give up',
                    'keep grinding',
                    'we believe',
                    'comeback time?',
                    'just lag',
                    'run it back',
                    'rematch!',
                    'AI too strong',
                    'need more practice',
                    'pain',
                    'sadness',
                    'üíÄüíÄüíÄ',
                    'big L',
                    'unlucky gg',
                    'respectable try',
                    'youll get em',
                    'tough opponent',
                    'F F F F F',
                    'not your game',
                    'happens to everyone',
                    'still learning',
                    'W for effort',
                    'valiant attempt'
                ];
                
                // Less spam than winning, but still significant reaction based on viewers
                let booCount;
                if (spectators < 100) booCount = 2;
                else if (spectators < 500) booCount = 4;
                else if (spectators < 1000) booCount = 6;
                else if (spectators < 5000) booCount = 10;
                else if (spectators < 10000) booCount = 14;
                else booCount = 20; // Still lots of reaction for huge audiences

                for (let i = 0; i < booCount; i++) {
                    setTimeout(() => {
                        const player = playerNames[Math.floor(Math.random() * playerNames.length)];
                        const message = booMessages[Math.floor(Math.random() * booMessages.length)];
                        addChatMessage(player, message);
                    }, 500 + (i * 350)); // Slightly slower than win spam
                }
                
                // Check for Streak Protection
                if (hasItem('streak_protection') && winStreak > 0) {
                    addChatMessage('System', 'üõ°Ô∏è Streak Protection activated! Streak saved!');
                    setTimeout(() => {
                        addChatMessage(playerNames[Math.floor(Math.random() * playerNames.length)], 'wait what');
                    }, 800);
                    setTimeout(() => {
                        addChatMessage(playerNames[Math.floor(Math.random() * playerNames.length)], 'his streak didnt reset???');
                    }, 1600);

                    // Remove the protection (one-time use)
                    purchasedItems = purchasedItems.filter(id => id !== 'streak_protection');
                    localStorage.setItem('tttPurchased', JSON.stringify(purchasedItems));
                } else {
                    winStreak = 0;
                }

                if (globalRank < 9999) globalRank += Math.floor(Math.random() * 20) + 5;
                updateStats();
            } else {
                document.getElementById('status').textContent = 'ü§ù DRAW!';
                scores.tie++;
                document.getElementById('tieScore').textContent = scores.tie;
                
                // Refund tournament bet on tie
                if (currentTournament) {
                    bankBalance += currentBet;
                    updateBankDisplay();
                    addTransaction('refund', currentBet, `ü§ù ${currentTournament.name} - Tie Refund`);
                    currentTournament = null;
                    currentBet = 0;
                }
                
                // Some chat for ties
                setTimeout(() => {
                    addChatMessage(playerNames[Math.floor(Math.random() * playerNames.length)], 'draw gg');
                }, 500);
                setTimeout(() => {
                    addChatMessage(playerNames[Math.floor(Math.random() * playerNames.length)], 'fair game');
                }, 1000);
            }
        }

        function createConfetti(x, y) {
            for (let i = 0; i < 50; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = (x + (Math.random() - 0.5) * 300) + 'px';
                confetti.style.top = (y + (Math.random() - 0.5) * 300) + 'px';
                confetti.style.background = `hsl(${Math.random() * 360}, 70%, 60%)`;
                document.body.appendChild(confetti);
                setTimeout(() => confetti.remove(), 3000);
            }
        }

        function aiMove() {
            if (!gameActive) return;
            
            let move;
            switch(difficulty) {
                case 'baby': move = babyAI(); break;
                case 'easy': move = easyAI(); break;
                case 'medium': move = mediumAI(); break;
                case 'hard': move = hardAI(); break;
                case 'expert': move = expertAI(); break;
                case 'impossible': move = impossibleAI(); break;
                case 'nightmare': move = nightmareAI(); break;
                case 'godlike': move = godlikeAI(); break;
                case 'yoadish': move = yoadishAI(); break;
                default: move = mediumAI(); break;
            }

            if (move) {
                makeMove(move.board, move.cell, true);
            }
        }

        function getAvailableMoves() {
            const moves = [];
            if (activeBoard !== null) {
                if (megaBoard[activeBoard] === '') {
                    miniBoards[activeBoard].forEach((cell, i) => {
                        if (cell === '') moves.push({ board: activeBoard, cell: i });
                    });
                }
            } else {
                miniBoards.forEach((board, bIdx) => {
                    if (megaBoard[bIdx] === '') {
                        board.forEach((cell, cIdx) => {
                            if (cell === '') moves.push({ board: bIdx, cell: cIdx });
                        });
                    }
                });
            }
            return moves;
        }

        function babyAI() {
            // Completely random, doesn't even try to win or block
            const moves = getAvailableMoves();
            return moves[Math.floor(Math.random() * moves.length)];
        }

        function easyAI() {
            // Mostly random, but occasionally tries to win (30% chance)
            const moves = getAvailableMoves();

            if (Math.random() < 0.3 && activeBoard !== null) {
                const winMove = findWinningMove(miniBoards[activeBoard], 'O');
                if (winMove !== -1) return { board: activeBoard, cell: winMove };
            }

            return moves[Math.floor(Math.random() * moves.length)];
        }

        function mediumAI() {
            if (Math.random() < 0.3) return easyAI();
            
            if (activeBoard !== null) {
                const winMove = findWinningMove(miniBoards[activeBoard], 'O');
                if (winMove !== -1) return { board: activeBoard, cell: winMove };
                
                const blockMove = findWinningMove(miniBoards[activeBoard], 'X');
                if (blockMove !== -1) return { board: activeBoard, cell: blockMove };
            }
            
            return easyAI();
        }

        function hardAI() {
            const megaWin = findMegaBoardWin('O');
            if (megaWin) return megaWin;

            const megaBlock = findMegaBoardWin('X');
            if (megaBlock) return megaBlock;

            if (activeBoard !== null && megaBoard[activeBoard] === '') {
                const winMove = findWinningMove(miniBoards[activeBoard], 'O');
                if (winMove !== -1) return { board: activeBoard, cell: winMove };
                
                const blockMove = findWinningMove(miniBoards[activeBoard], 'X');
                if (blockMove !== -1) return { board: activeBoard, cell: blockMove };
            }

            return mediumAI();
        }

        function expertAI() {
            if (Math.random() < 0.15) return hardAI();
            return impossibleAI();
        }

        function impossibleAI() {
            const megaWin = findMegaBoardWin('O');
            if (megaWin) return megaWin;

            const megaBlock = findMegaBoardWin('X');
            if (megaBlock) return megaBlock;

            const moves = getAvailableMoves();
            let bestMove = null;
            let bestScore = -Infinity;

            moves.forEach(move => {
                const score = evaluateMove(move);
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            });

            return bestMove || easyAI();
        }

        function nightmareAI() {
            // Like impossible, but evaluates TWICE for each move with lookahead
            const megaWin = findMegaBoardWin('O');
            if (megaWin) return megaWin;

            const megaBlock = findMegaBoardWin('X');
            if (megaBlock) return megaBlock;

            const moves = getAvailableMoves();
            let bestMove = null;
            let bestScore = -Infinity;

            moves.forEach(move => {
                let score = evaluateMove(move);

                // LOOKAHEAD: Simulate this move and evaluate opponent's best response
                const savedMiniBoards = miniBoards.map(b => [...b]);
                const savedMegaBoard = [...megaBoard];

                // Simulate our move
                miniBoards[move.board][move.cell] = 'O';
                if (checkWin(miniBoards[move.board])) {
                    megaBoard[move.board] = 'O';
                }

                // Find opponent's best counter-move
                const opponentMoves = getAvailableMoves();
                let worstOpponentScore = Infinity;

                opponentMoves.slice(0, 10).forEach(oppMove => { // Check top 10 opponent moves
                    miniBoards[oppMove.board][oppMove.cell] = 'X';
                    if (checkWin(miniBoards[oppMove.board])) {
                        worstOpponentScore = Math.min(worstOpponentScore, -100);
                    }
                    miniBoards[oppMove.board][oppMove.cell] = '';
                });

                // Restore boards
                miniBoards = savedMiniBoards;
                megaBoard = savedMegaBoard;

                // Adjust score based on opponent's response
                score += worstOpponentScore * 0.5;

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            });

            return bestMove || impossibleAI();
        }

        function godlikeAI() {
            // The ULTIMATE AI - perfect play with deep lookahead
            const megaWin = findMegaBoardWin('O');
            if (megaWin) return megaWin;

            const megaBlock = findMegaBoardWin('X');
            if (megaBlock) return megaBlock;

            const moves = getAvailableMoves();
            let bestMove = null;
            let bestScore = -Infinity;

            // Evaluate ALL moves with deep analysis
            moves.forEach(move => {
                let score = evaluateMove(move) * 1.2; // Boost evaluation scores

                // DEEP LOOKAHEAD: 2 moves ahead
                const savedMiniBoards = miniBoards.map(b => [...b]);
                const savedMegaBoard = [...megaBoard];

                // Simulate our move
                miniBoards[move.board][move.cell] = 'O';
                if (checkWin(miniBoards[move.board])) {
                    megaBoard[move.board] = 'O';
                }

                // Check if we won
                if (checkWin(megaBoard)) {
                    miniBoards = savedMiniBoards;
                    megaBoard = savedMegaBoard;
                    return { board: move.board, cell: move.cell }; // INSTANT WIN!
                }

                // Evaluate ALL opponent responses
                const opponentMoves = getAvailableMoves();
                let totalOpponentThreat = 0;

                opponentMoves.forEach(oppMove => {
                    miniBoards[oppMove.board][oppMove.cell] = 'X';

                    if (checkWin(miniBoards[oppMove.board])) {
                        megaBoard[oppMove.board] = 'X';
                        if (checkWin(megaBoard)) {
                            totalOpponentThreat -= 200; // They can win!
                        } else {
                            totalOpponentThreat -= 50; // They win a board
                        }
                        megaBoard[oppMove.board] = '';
                    }

                    miniBoards[oppMove.board][oppMove.cell] = '';
                });

                // Restore boards
                miniBoards = savedMiniBoards;
                megaBoard = savedMegaBoard;

                // Factor in opponent threats
                score += totalOpponentThreat / opponentMoves.length;

                // Add perfect strategic positioning bonus
                if (move.cell === 4) score += 20; // Center is KING
                if ([0, 2, 6, 8].includes(move.cell)) score += 12; // Corners are STRONG

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            });

            return bestMove || nightmareAI();
        }

        function yoadishAI() {
            // üò∫ YOAD-ISH - UNBEATABLE MINIMAX ALGORITHM! üò∫
            // This is THE LEGENDARY AI!

            // First, check for instant wins/blocks
            const megaWin = findMegaBoardWin('O');
            if (megaWin) return megaWin;

            const megaBlock = findMegaBoardWin('X');
            if (megaBlock) return megaBlock;

            const moves = getAvailableMoves();
            if (moves.length === 0) return null;

            let bestMove = null;
            let bestScore = -Infinity;

            // MINIMAX with alpha-beta pruning!
            moves.forEach(move => {
                // Save current state
                const savedMiniBoards = miniBoards.map(b => [...b]);
                const savedMegaBoard = [...megaBoard];
                const savedActiveBoard = activeBoard;

                // Make the move
                miniBoards[move.board][move.cell] = 'O';
                if (checkWin(miniBoards[move.board])) {
                    megaBoard[move.board] = 'O';
                }

                // Check if this wins the game
                if (checkWin(megaBoard)) {
                    miniBoards = savedMiniBoards;
                    megaBoard = savedMegaBoard;
                    activeBoard = savedActiveBoard;
                    return move; // INSTANT WIN!
                }

                // Update active board
                if (megaBoard[move.cell] === '') {
                    activeBoard = move.cell;
                } else {
                    activeBoard = null;
                }

                // Minimax evaluation (depth-limited for performance)
                const score = minimaxEvaluate(3, false, -Infinity, Infinity);

                // Restore state
                miniBoards = savedMiniBoards;
                megaBoard = savedMegaBoard;
                activeBoard = savedActiveBoard;

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            });

            return bestMove || godlikeAI();
        }

        function minimaxEvaluate(depth, isMaximizing, alpha, beta) {
            // Check terminal states
            if (checkWin(megaBoard)) {
                return isMaximizing ? -1000 : 1000;
            }

            const availableMoves = getAvailableMoves();
            if (availableMoves.length === 0 || depth === 0) {
                // Evaluate board state
                return evaluateBoardState();
            }

            if (isMaximizing) {
                // AI's turn (O)
                let maxScore = -Infinity;
                for (let move of availableMoves) {
                    const savedMiniBoards = miniBoards.map(b => [...b]);
                    const savedMegaBoard = [...megaBoard];
                    const savedActiveBoard = activeBoard;

                    miniBoards[move.board][move.cell] = 'O';
                    if (checkWin(miniBoards[move.board])) {
                        megaBoard[move.board] = 'O';
                    }
                    if (megaBoard[move.cell] === '') {
                        activeBoard = move.cell;
                    } else {
                        activeBoard = null;
                    }

                    const score = minimaxEvaluate(depth - 1, false, alpha, beta);

                    miniBoards = savedMiniBoards;
                    megaBoard = savedMegaBoard;
                    activeBoard = savedActiveBoard;

                    maxScore = Math.max(maxScore, score);
                    alpha = Math.max(alpha, score);
                    if (beta <= alpha) break; // Prune
                }
                return maxScore;
            } else {
                // Player's turn (X)
                let minScore = Infinity;
                for (let move of availableMoves) {
                    const savedMiniBoards = miniBoards.map(b => [...b]);
                    const savedMegaBoard = [...megaBoard];
                    const savedActiveBoard = activeBoard;

                    miniBoards[move.board][move.cell] = 'X';
                    if (checkWin(miniBoards[move.board])) {
                        megaBoard[move.board] = 'X';
                    }
                    if (megaBoard[move.cell] === '') {
                        activeBoard = move.cell;
                    } else {
                        activeBoard = null;
                    }

                    const score = minimaxEvaluate(depth - 1, true, alpha, beta);

                    miniBoards = savedMiniBoards;
                    megaBoard = savedMegaBoard;
                    activeBoard = savedActiveBoard;

                    minScore = Math.min(minScore, score);
                    beta = Math.min(beta, score);
                    if (beta <= alpha) break; // Prune
                }
                return minScore;
            }
        }

        function evaluateBoardState() {
            let score = 0;

            // Evaluate mega board control
            for (let i = 0; i < 9; i++) {
                if (megaBoard[i] === 'O') score += 10;
                else if (megaBoard[i] === 'X') score -= 10;
            }

            // Evaluate potential wins
            for (let condition of winConditions) {
                const [a, b, c] = condition;
                const boards = [megaBoard[a], megaBoard[b], megaBoard[c]];

                const oCount = boards.filter(b => b === 'O').length;
                const xCount = boards.filter(b => b === 'X').length;

                if (oCount > 0 && xCount === 0) score += oCount * 3;
                if (xCount > 0 && oCount === 0) score -= xCount * 3;
            }

            return score;
        }

        function evaluateMove(move) {
            let score = 0;

            // PRIORITY 1: Check if this wins a small board
            const tempBoard = [...miniBoards[move.board]];
            tempBoard[move.cell] = 'O';
            if (checkWin(tempBoard)) {
                score += 100;

                // PRIORITY 1A: Does winning this board win the mega board?
                const tempMega = [...megaBoard];
                tempMega[move.board] = 'O';
                if (checkWin(tempMega)) {
                    return 10000; // INSTANT WIN!
                }

                // Check if winning this creates mega board threats
                for (let condition of winConditions) {
                    const [a, b, c] = condition;
                    const boards = [tempMega[a], tempMega[b], tempMega[c]];
                    if (boards.filter(b => b === 'O').length === 2 && boards.includes('')) {
                        score += 300; // Creates a winning threat on mega board!
                    }
                }
            }

            // PRIORITY 2: Check if opponent could win this board if we don't play here
            const blockBoard = [...miniBoards[move.board]];
            blockBoard[move.cell] = 'X';
            if (checkWin(blockBoard)) {
                score += 80;

                // Is this blocking a mega board win?
                const blockMega = [...megaBoard];
                blockMega[move.board] = 'X';
                if (checkWin(blockMega)) {
                    return 9000; // MUST BLOCK!
                }

                // Blocking a mega board threat
                for (let condition of winConditions) {
                    const [a, b, c] = condition;
                    const boards = [blockMega[a], blockMega[b], blockMega[c]];
                    if (boards.filter(b => b === 'X').length === 2 && boards.includes('')) {
                        score += 250; // Block mega board threat!
                    }
                }
            }

            // PRIORITY 3: Check if this creates 2-in-a-row on current board
            for (let condition of winConditions) {
                const [a, b, c] = condition;
                const cells = [tempBoard[a], tempBoard[b], tempBoard[c]];
                if (cells.filter(c => c === 'O').length === 2 && cells.includes('')) {
                    score += 40; // Creating a threat
                }

                // Block opponent's 2-in-a-row
                const blockCells = [miniBoards[move.board][a], miniBoards[move.board][b], miniBoards[move.board][c]];
                if (blockCells.filter(c => c === 'X').length === 2 && blockCells.includes('')) {
                    if ([a, b, c].includes(move.cell)) {
                        score += 35; // Block their threat
                    }
                }
            }

            // PRIORITY 4: Strategic positioning - center and corners
            if (move.cell === 4) score += 10; // Center is good
            if ([0, 2, 6, 8].includes(move.cell)) score += 6; // Corners are decent

            // PRIORITY 5: Where will opponent be sent?
            const nextBoard = move.cell;

            // If we send them to a won/tied board (they can play anywhere), that's GOOD
            if (megaBoard[nextBoard] !== '') {
                score += 45;
            } else {
                // If we send them to a board where they could win, that's BAD
                const opponentWinMove = findWinningMove(miniBoards[nextBoard], 'X');
                if (opponentWinMove !== -1) {
                    score -= 60; // Bad! They can win that board

                    // Even worse if that board win would give them mega board advantage
                    const futureOpponentMega = [...megaBoard];
                    futureOpponentMega[nextBoard] = 'X';
                    for (let condition of winConditions) {
                        const [a, b, c] = condition;
                        const boards = [futureOpponentMega[a], futureOpponentMega[b], futureOpponentMega[c]];
                        if (boards.filter(b => b === 'X').length === 2 && boards.includes('')) {
                            score -= 40; // They'd get a mega threat!
                        }
                    }
                }

                // If we send them to a board where WE have 2-in-a-row, that's also bad
                const weCanWinThere = findWinningMove(miniBoards[nextBoard], 'O');
                if (weCanWinThere !== -1) {
                    score -= 25; // We're giving up a board we could win later
                }
            }

            // PRIORITY 6: Mega board positioning
            // Prefer moves that help us control strategic mega board positions
            const megaBoardPos = move.board;
            if (megaBoardPos === 4) score += 15; // Center mega board
            if ([0, 2, 6, 8].includes(megaBoardPos)) score += 8; // Corner mega boards

            // PRIORITY 7: Add some randomness to avoid being too predictable (5% variance)
            score += (Math.random() - 0.5) * 10;

            return score;
        }

        function findWinningMove(board, player) {
            for (let i = 0; i < 9; i++) {
                if (board[i] === '') {
                    board[i] = player;
                    const won = checkWin(board);
                    board[i] = '';
                    if (won) return i;
                }
            }
            return -1;
        }

        function findMegaBoardWin(player) {
            for (let condition of winConditions) {
                const [a, b, c] = condition;
                const boards = [megaBoard[a], megaBoard[b], megaBoard[c]];
                
                if (boards.filter(b => b === player).length === 2 && boards.includes('')) {
                    const targetBoard = [a, b, c].find(i => megaBoard[i] === '');
                    if (activeBoard === null || activeBoard === targetBoard) {
                        const move = findWinningMove(miniBoards[targetBoard], 'O');
                        if (move !== -1) return { board: targetBoard, cell: move };
                    }
                }
            }
            return null;
        }

        function resetGame() {
            miniBoards = Array(9).fill(null).map(() => ['', '', '', '', '', '', '', '', '']);
            megaBoard = ['', '', '', '', '', '', '', '', ''];
            currentPlayer = 'X';
            activeBoard = null;
            gameActive = true;
            moveCount = 0;
            gameStartTime = Date.now();
            
            createBoard();
            showMatchmaking();
            updateSpectators();
        }

        document.querySelectorAll('.difficulty-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                difficulty = btn.dataset.difficulty;
                resetGame();
            });
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            // Quick Match clears tournament
            currentTournament = null;
            currentBet = 0;
            resetGame();
        });

        // Bank System Functions
        function updateBankDisplay() {
            document.getElementById('bankBalance').textContent = bankBalance.toLocaleString();
            document.getElementById('bankBalanceModal').textContent = bankBalance.toLocaleString();
            localStorage.setItem('tttBalance', bankBalance);
        }

        function addTransaction(type, amount, description) {
            const transaction = {
                type,
                amount,
                description,
                date: new Date().toLocaleString()
            };
            transactions.unshift(transaction);
            if (transactions.length > 20) transactions.pop();
            localStorage.setItem('tttTransactions', JSON.stringify(transactions));
        }

        function showBank() {
            document.getElementById('bankModal').classList.add('show');
            updateTransactionHistory();
            // Update rebirth display
            document.getElementById('rebirthLevelDisplay').textContent = rebirthLevel;
            document.getElementById('rebirthMultDisplay').textContent = rebirthMultiplier.toFixed(1);
            document.getElementById('taxRateDisplay').textContent = (taxRate * 100).toFixed(0);
        }

        function closeBank() {
            document.getElementById('bankModal').classList.remove('show');
        }

        function updateTransactionHistory() {
            const historyEl = document.getElementById('transactionHistory');
            if (transactions.length === 0) {
                historyEl.innerHTML = '<div style="text-align: center; opacity: 0.6; padding: 20px;">No transactions yet</div>';
                return;
            }
            
            historyEl.innerHTML = transactions.map(t => `
                <div class="transaction ${t.type === 'win' || t.type === 'bonus' ? 'positive' : 'negative'}">
                    <div>
                        <div>${t.description}</div>
                        <div style="font-size: 0.75em; opacity: 0.7;">${t.date}</div>
                    </div>
                    <div style="font-weight: bold; color: ${t.type === 'win' || t.type === 'bonus' ? '#43e97b' : '#ff6b6b'}">
                        ${t.type === 'win' || t.type === 'bonus' ? '+' : '-'}$${Math.abs(t.amount).toLocaleString()}
                    </div>
                </div>
            `).join('');
        }

        function dailyBonus() {
            const today = new Date().toDateString();
            if (lastDailyBonus === today) {
                alert('You already claimed your daily bonus! Come back tomorrow! üéÅ');
                return;
            }

            const bonusAmount = Math.floor(400 * rebirthMultiplier);
            bankBalance += bonusAmount;
            lastDailyBonus = today;
            localStorage.setItem('tttLastDaily', lastDailyBonus);
            addTransaction('bonus', bonusAmount, 'üéÅ Daily Login Bonus');
            updateBankDisplay();
            updateTransactionHistory();
            spawnEmote('üí∞');
            addChatMessage('System', 'claimed daily bonus!');
        }

        function addMoney() {
            bankBalance += 8000;
            addTransaction('bonus', 8000, 'üîì Dev Bonus');
            updateBankDisplay();
            updateTransactionHistory();
        }

        function performRebirth() {
            if (bankBalance < 1000000) {
                alert(`You need $1,000,000 to rebirth! Current: $${bankBalance.toLocaleString()}`);
                return;
            }

            const confirmRebirth = confirm(`üîÑ REBIRTH CONFIRMATION üîÑ\n\nYou will LOSE:\n- All money\n- All stats\n- All achievements\n- All shop items\n\nYou will GAIN:\n- Rebirth Level +1\n- Income Multiplier +50%\n- Tax Rate -5%\n- Permanent advantage!\n\nProceed?`);

            if (!confirmRebirth) return;

            // Increment rebirth
            rebirthLevel++;
            rebirthMultiplier = 1 + (rebirthLevel * 0.5);
            taxRate = Math.max(0.05, 0.25 - (rebirthLevel * 0.05)); // Reduce tax by 5% per rebirth, minimum 5%

            // Reset everything
            bankBalance = 800;
            winStreak = 0;
            bestStreak = 0;
            totalWins = 0;
            globalRank = 999999;
            achievements = [];
            purchasedItems = [];
            transactions = [];

            // Save rebirth to localStorage
            localStorage.setItem('tttRebirth', rebirthLevel);
            localStorage.setItem('tttBalance', bankBalance);
            localStorage.setItem('tttAchievements', JSON.stringify(achievements));
            localStorage.setItem('tttPurchased', JSON.stringify(purchasedItems));
            localStorage.setItem('tttTransactions', JSON.stringify(transactions));

            // Update UI
            updateStats();
            updateBankDisplay();
            updateTransactionHistory();
            document.getElementById('rebirthLevelDisplay').textContent = rebirthLevel;
            document.getElementById('rebirthMultDisplay').textContent = rebirthMultiplier.toFixed(1);
            document.getElementById('taxRateDisplay').textContent = (taxRate * 100).toFixed(0);

            // Chat reactions
            playSound('win');
            addChatMessage('System', `üîÑ ${playerNames[0]} HAS REBIRTHED! Level ${rebirthLevel}!`);
            setTimeout(() => {
                const rebirthMessages = [
                    'THEY RESET EVERYTHING?!',
                    'absolute madlad',
                    'starting over with power',
                    'PRESTIGE MODE',
                    'built different fr',
                    'the grind never stops',
                    `${rebirthMultiplier.toFixed(1)}x income now wtf`
                ];
                addChatMessage(playerNames[Math.floor(Math.random() * playerNames.length)],
                    rebirthMessages[Math.floor(Math.random() * rebirthMessages.length)]);
            }, 1000);

            alert(`‚úÖ REBIRTH COMPLETE!\n\nYou are now Rebirth Level ${rebirthLevel}!\nIncome Multiplier: ${rebirthMultiplier.toFixed(1)}x\nTax Rate: ${(taxRate * 100).toFixed(0)}%\n\nGood luck!`);
        }

        // Tournament System
        function showTournaments() {
            const listEl = document.getElementById('tournamentList');
            listEl.innerHTML = tournaments.map((t, i) => {
                const canAfford = bankBalance >= t.bet;
                const locked = t.locked && bankBalance < t.unlockAt;
                const isLocked = locked || !canAfford;

                return `
                    <div class="tournament-card ${isLocked ? 'locked' : ''}" onclick="${isLocked ? '' : `startTournament(${i})`}">
                        <div class="tournament-name">${t.name}</div>
                        <div class="tournament-details">
                            <span class="tournament-bet">üí∏ Entry Fee: $${t.bet.toLocaleString()}</span>
                        </div>
                        <div class="tournament-details" style="font-size: 1.1em; color: #43e97b;">
                            <span class="tournament-win">üèÜ Win Prize: $${t.win.toLocaleString()}</span>
                        </div>
                        <div class="tournament-details" style="font-size: 0.8em; opacity: 0.7; margin-top: 5px;">
                            ‚ö†Ô∏è You pay $${t.bet.toLocaleString()} now. Win = Get $${t.win.toLocaleString()}. Lose = Lose $${t.bet.toLocaleString()}!
                        </div>
                        <div class="tournament-details">
                            üëÅÔ∏è ${t.viewers.toLocaleString()} viewers ‚Ä¢
                            Difficulty: ${t.difficulty.toUpperCase()}
                        </div>
                        ${locked ? '<div style="color: #ffd700; font-size: 0.85em;">üîí Unlock at $' + t.unlockAt.toLocaleString() + '</div>' : ''}
                        ${!canAfford && !locked ? '<div style="color: #ff6b6b; font-size: 0.85em;">‚ùå Need $' + t.bet.toLocaleString() + '</div>' : ''}
                    </div>
                `;
            }).join('');

            document.getElementById('tournamentModal').classList.add('show');
        }

        function closeTournaments() {
            document.getElementById('tournamentModal').classList.remove('show');
        }

        function showCustomTournament() {
            document.getElementById('tournamentModal').classList.remove('show');
            document.getElementById('customTournamentModal').classList.add('show');
            
            // Update preview on input changes
            const updatePreview = () => {
                const bet = parseInt(document.getElementById('customBet').value) || 100;
                const multiplier = parseFloat(document.getElementById('customMultiplier').value) || 5;
                const prize = Math.floor(bet * multiplier);
                document.getElementById('customPreview').innerHTML = 
                    `üí∞ Preview: Pay <span style="color: #ff6b6b;">$${bet.toLocaleString()}</span> ‚Üí Win <span style="color: #43e97b;">$${prize.toLocaleString()}</span>`;
            };
            
            document.getElementById('customBet').addEventListener('input', updatePreview);
            document.getElementById('customMultiplier').addEventListener('input', updatePreview);
            updatePreview();
        }

        function closeCustomTournament() {
            document.getElementById('customTournamentModal').classList.remove('show');
        }

        function createCustomTournament() {
            const name = document.getElementById('customName').value || 'Custom Tournament';
            const bet = parseInt(document.getElementById('customBet').value) || 100;
            const multiplier = parseFloat(document.getElementById('customMultiplier').value) || 5;
            const difficulty = document.getElementById('customDifficulty').value;
            const viewers = parseInt(document.getElementById('customViewers').value) || 1000;
            
            const win = Math.floor(bet * multiplier);
            
            if (bet < 1) {
                alert('Entry fee must be at least $1!');
                return;
            }
            
            if (bankBalance < bet) {
                alert('Insufficient funds! üí∏');
                return;
            }
            
            const customTournament = {
                name,
                bet,
                win,
                difficulty,
                viewers
            };
            
            // Deduct bet
            bankBalance -= bet;
            currentBet = bet;
            currentTournament = customTournament;
            updateBankDisplay();
            addTransaction('bet', -bet, `üéÆ ${name} Entry Fee`);
            
            // Set difficulty
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.difficulty === difficulty) {
                    btn.classList.add('active');
                }
            });
            window.difficulty = difficulty;
            
            closeCustomTournament();
            resetGame();
            
            addChatMessage('System', `üèÜ ${name} starting! ${viewers.toLocaleString()} viewers watching!`);
            setTimeout(() => {
                reactiveChat('spectator_join');
                spawnEmote('üî•');
            }, 2000);
        }

        function startTournament(index) {
            const tournament = tournaments[index];

            if (bankBalance < tournament.bet) {
                alert('Insufficient funds! üí∏');
                return;
            }

            // Deduct bet
            bankBalance -= tournament.bet;
            currentBet = tournament.bet;
            currentTournament = tournament;
            updateBankDisplay();
            addTransaction('bet', -tournament.bet, `üéÆ ${tournament.name} Entry Fee`);

            // Set difficulty
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.difficulty === tournament.difficulty) {
                    btn.classList.add('active');
                }
            });
            difficulty = tournament.difficulty;
            
            closeTournaments();
            resetGame();

            addChatMessage('System', `üèÜ ${tournament.name} starting! ${tournament.viewers.toLocaleString()} viewers watching!`);
            setTimeout(() => {
                reactiveChat('spectator_join');
                spawnEmote('üî•');
            }, 2000);

            // RICH WHALE SPAWN CHANCE based on tournament size!
            let whaleSpawnChance = 0;

            // Whale Magnet item guarantees whale spawn!
            if (hasItem('guaranteed_whale')) {
                whaleSpawnChance = 1.0;
            } else {
                if (tournament.viewers >= 5000 && tournament.viewers < 10000) whaleSpawnChance = 0.1; // 10%
                else if (tournament.viewers >= 10000 && tournament.viewers < 25000) whaleSpawnChance = 0.2; // 20%
                else if (tournament.viewers >= 25000 && tournament.viewers < 75000) whaleSpawnChance = 0.35; // 35%
                else if (tournament.viewers >= 75000 && tournament.viewers < 150000) whaleSpawnChance = 0.5; // 50%
                else if (tournament.viewers >= 150000) whaleSpawnChance = 0.7; // 70% for massive tournaments!
            }

            if (Math.random() < whaleSpawnChance) {
                setTimeout(() => {
                    spawnRichWhale();
                }, 3000 + Math.floor(Math.random() * 5000)); // Spawn 3-8 seconds into the game
            }
        }

        function spawnDonation(amount) {
            // Check for 2x Donations modifier
            if (hasItem('double_donations')) {
                amount *= 2;
            }

            // Apply rebirth multiplier
            amount = Math.floor(amount * rebirthMultiplier);

            // Apply TAXES (even on donations!)
            const taxAmount = Math.floor(amount * taxRate);
            const netAmount = amount - taxAmount;

            const popup = document.createElement('div');
            popup.className = 'donation-popup';
            popup.textContent = `+$${netAmount} üí∞${hasItem('double_donations') ? ' (2X!)' : ''} (-${taxAmount} tax)`;
            popup.style.left = (Math.random() * (window.innerWidth - 150)) + 'px';
            popup.style.top = (window.innerHeight * 0.3) + 'px';
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 2000);

            playSound('click');
            bankBalance += netAmount;
            updateBankDisplay();
            addTransaction('bonus', netAmount, 'üíù Viewer Donation');
        }

        // ====== SPECTATOR MODE SYSTEM ======
        let liveMatches = [];
        let currentSpectatingMatch = null;
        let spectatorBet = null;
        let matchSimulationInterval = null;

        function showSpectatorMode() {
            document.getElementById('spectatorModal').classList.add('show');
            generateLiveMatches();
            renderLiveMatches();
        }

        function closeSpectator() {
            document.getElementById('spectatorModal').classList.remove('show');
            if (matchSimulationInterval) {
                clearInterval(matchSimulationInterval);
                matchSimulationInterval = null;
            }
            currentSpectatingMatch = null;
            spectatorBet = null;
        }

        function generateLiveMatches() {
            // Generate 5-10 live matches with AI vs AI
            const matchCount = 5 + Math.floor(Math.random() * 6);
            liveMatches = [];

            for (let i = 0; i < matchCount; i++) {
                const player1 = playerNames[Math.floor(Math.random() * playerNames.length)];
                const player2 = playerNames[Math.floor(Math.random() * playerNames.length)];
                const tournament = tournaments[Math.floor(Math.random() * tournaments.length)];
                const viewers = Math.floor(Math.random() * 50000) + 1000;

                // Random match progress (0-50%)
                const progress = Math.floor(Math.random() * 50);

                liveMatches.push({
                    id: i,
                    player1,
                    player2,
                    tournament: tournament.name,
                    difficulty: tournament.difficulty,
                    viewers,
                    progress,
                    player1Score: 0, // Mega board squares won
                    player2Score: 0,
                    winner: null,
                    miniBoards: Array(9).fill(null).map(() => ['', '', '', '', '', '', '', '', '']),
                    megaBoard: ['', '', '', '', '', '', '', '', ''],
                    currentPlayer: Math.random() > 0.5 ? 'X' : 'O',
                    activeBoard: null,
                    chatMessages: []
                });
            }
        }

        function renderLiveMatches() {
            const listEl = document.getElementById('liveMatchesList');

            if (liveMatches.length === 0) {
                listEl.innerHTML = '<div style="text-align: center; opacity: 0.6;">No live matches right now. Check back soon!</div>';
                return;
            }

            listEl.innerHTML = `
                <div style="font-size: 1.1em; font-weight: bold; margin-bottom: 15px; text-align: center;">üî¥ LIVE MATCHES</div>
                ${liveMatches.filter(m => !m.winner).map(match => `
                    <div class="tournament-card" onclick="watchMatch(${match.id})" style="cursor: pointer;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="flex: 1; text-align: center;">
                                <div style="font-weight: bold; font-size: 1.1em;">${match.player1}</div>
                                <div style="font-size: 0.8em; opacity: 0.7;">Score: ${match.player1Score}</div>
                            </div>
                            <div style="font-size: 1.5em; margin: 0 20px;">VS</div>
                            <div style="flex: 1; text-align: center;">
                                <div style="font-weight: bold; font-size: 1.1em;">${match.player2}</div>
                                <div style="font-size: 0.8em; opacity: 0.7;">Score: ${match.player2Score}</div>
                            </div>
                        </div>
                        <div style="margin-top: 10px; font-size: 0.9em; opacity: 0.8; text-align: center;">
                            üèÜ ${match.tournament} ‚Ä¢ üëÅÔ∏è ${match.viewers.toLocaleString()} viewers
                        </div>
                        <div style="margin-top: 5px; background: rgba(255,255,255,0.1); height: 8px; border-radius: 4px; overflow: hidden;">
                            <div style="width: ${match.progress}%; height: 100%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);"></div>
                        </div>
                    </div>
                `).join('')}
            `;
        }

        function watchMatch(matchId) {
            currentSpectatingMatch = liveMatches.find(m => m.id === matchId);
            if (!currentSpectatingMatch) return;

            // Hide match list, show spectator view
            document.getElementById('liveMatchesList').style.display = 'none';
            document.getElementById('spectatorView').style.display = 'block';

            // Update player names
            document.getElementById('specPlayer1Name').textContent = currentSpectatingMatch.player1;
            document.getElementById('specPlayer2Name').textContent = currentSpectatingMatch.player2;
            document.getElementById('betPlayer1Name').textContent = currentSpectatingMatch.player1;
            document.getElementById('betPlayer2Name').textContent = currentSpectatingMatch.player2;
            document.getElementById('donatePlayer1Name').textContent = currentSpectatingMatch.player1;
            document.getElementById('donatePlayer2Name').textContent = currentSpectatingMatch.player2;
            document.getElementById('specTournamentName').textContent = currentSpectatingMatch.tournament;
            document.getElementById('specViewers').textContent = currentSpectatingMatch.viewers.toLocaleString();

            // Reset bet
            spectatorBet = null;
            document.getElementById('currentBetDisplay').textContent = '';

            // Start simulating the match
            updateSpectatorView();
            simulateMatch();
        }

        function simulateMatch() {
            if (matchSimulationInterval) clearInterval(matchSimulationInterval);

            // Simulate moves every 2-4 seconds
            matchSimulationInterval = setInterval(() => {
                if (!currentSpectatingMatch || currentSpectatingMatch.winner) {
                    clearInterval(matchSimulationInterval);
                    return;
                }

                // Simulate one AI move
                const availableMoves = [];
                for (let board = 0; board < 9; board++) {
                    if (currentSpectatingMatch.megaBoard[board] !== '') continue;
                    if (currentSpectatingMatch.activeBoard !== null && currentSpectatingMatch.activeBoard !== board) continue;

                    for (let cell = 0; cell < 9; cell++) {
                        if (currentSpectatingMatch.miniBoards[board][cell] === '') {
                            availableMoves.push({ board, cell });
                        }
                    }
                }

                if (availableMoves.length === 0) {
                    // Match is a draw
                    currentSpectatingMatch.winner = 'draw';
                    handleMatchEnd();
                    return;
                }

                // Make random move
                const move = availableMoves[Math.floor(Math.random() * availableMoves.length)];
                currentSpectatingMatch.miniBoards[move.board][move.cell] = currentSpectatingMatch.currentPlayer;

                // Check if mini board is won
                if (checkWin(currentSpectatingMatch.miniBoards[move.board])) {
                    currentSpectatingMatch.megaBoard[move.board] = currentSpectatingMatch.currentPlayer;

                    // Update scores
                    if (currentSpectatingMatch.currentPlayer === 'X') {
                        currentSpectatingMatch.player1Score++;
                    } else {
                        currentSpectatingMatch.player2Score++;
                    }

                    // Chat reaction
                    addSpectatorChat('System', `${currentSpectatingMatch.currentPlayer === 'X' ? currentSpectatingMatch.player1 : currentSpectatingMatch.player2} won a board!`);

                    // Random chat spam
                    if (Math.random() > 0.6) {
                        const reactions = ['NICE!', 'WOW', 'GOOD MOVE', 'EZ', 'LETS GO', 'CLUTCH', 'INSANE'];
                        addSpectatorChat(playerNames[Math.floor(Math.random() * playerNames.length)],
                            reactions[Math.floor(Math.random() * reactions.length)]);
                    }

                    // Check mega board win
                    if (checkWin(currentSpectatingMatch.megaBoard)) {
                        currentSpectatingMatch.winner = currentSpectatingMatch.currentPlayer === 'X' ? 'player1' : 'player2';
                        handleMatchEnd();
                        return;
                    }
                }

                // Set next active board
                if (currentSpectatingMatch.megaBoard[move.cell] === '') {
                    currentSpectatingMatch.activeBoard = move.cell;
                } else {
                    currentSpectatingMatch.activeBoard = null;
                }

                // Switch player
                currentSpectatingMatch.currentPlayer = currentSpectatingMatch.currentPlayer === 'X' ? 'O' : 'X';

                // Update progress
                currentSpectatingMatch.progress = Math.min(95, currentSpectatingMatch.progress + Math.random() * 8);

                updateSpectatorView();
                updateOdds();
            }, 2000 + Math.random() * 2000); // 2-4 seconds per move
        }

        function updateSpectatorView() {
            if (!currentSpectatingMatch) return;

            // Update scores
            document.getElementById('specPlayer1Score').textContent = currentSpectatingMatch.player1Score;
            document.getElementById('specPlayer2Score').textContent = currentSpectatingMatch.player2Score;

            // Update board display (simplified)
            const boardStatus = `üìä ${currentSpectatingMatch.player1}: ${currentSpectatingMatch.player1Score} boards | ${currentSpectatingMatch.player2}: ${currentSpectatingMatch.player2Score} boards`;
            document.getElementById('spectatorBoard').textContent = boardStatus;
        }

        function updateOdds() {
            if (!currentSpectatingMatch || currentSpectatingMatch.winner) return;

            // Calculate odds based on current scores and AI difficulty
            const scoreDiff = currentSpectatingMatch.player1Score - currentSpectatingMatch.player2Score;

            // Base odds are 2.0x for both
            let player1Odds = 2.0;
            let player2Odds = 2.0;

            // Adjust based on score difference
            if (scoreDiff > 0) {
                // Player 1 is winning - lower odds for player1, higher for player2
                player1Odds = Math.max(1.2, 2.0 - (scoreDiff * 0.3));
                player2Odds = Math.min(5.0, 2.0 + (scoreDiff * 0.4));
            } else if (scoreDiff < 0) {
                // Player 2 is winning
                player2Odds = Math.max(1.2, 2.0 - (Math.abs(scoreDiff) * 0.3));
                player1Odds = Math.min(5.0, 2.0 + (Math.abs(scoreDiff) * 0.4));
            }

            document.getElementById('betPlayer1Odds').textContent = player1Odds.toFixed(1);
            document.getElementById('betPlayer2Odds').textContent = player2Odds.toFixed(1);
        }

        function placeBet(player) {
            if (!currentSpectatingMatch || currentSpectatingMatch.winner) {
                alert('This match is over!');
                return;
            }

            if (spectatorBet) {
                alert('You already placed a bet on this match!');
                return;
            }

            const betAmount = parseInt(document.getElementById('betAmount').value) || 100;

            if (betAmount < 10) {
                alert('Minimum bet is $10!');
                return;
            }

            if (bankBalance < betAmount) {
                alert('Insufficient funds! üí∏');
                return;
            }

            const odds = parseFloat(document.getElementById(player === 'player1' ? 'betPlayer1Odds' : 'betPlayer2Odds').textContent);
            const playerName = player === 'player1' ? currentSpectatingMatch.player1 : currentSpectatingMatch.player2;

            // Deduct bet
            bankBalance -= betAmount;
            updateBankDisplay();
            addTransaction('bet', -betAmount, `üé∞ Bet on ${playerName}`);

            // Store bet
            spectatorBet = {
                player,
                amount: betAmount,
                odds,
                playerName
            };

            document.getElementById('currentBetDisplay').textContent =
                `Current Bet: $${betAmount.toLocaleString()} on ${playerName} (${odds}x) - Potential win: $${(betAmount * odds).toLocaleString()}`;

            addSpectatorChat('You', `Bet $${betAmount.toLocaleString()} on ${playerName}!`);
            playSound('click');
        }

        function handleMatchEnd() {
            if (!currentSpectatingMatch) return;

            clearInterval(matchSimulationInterval);

            const winnerName = currentSpectatingMatch.winner === 'player1' ? currentSpectatingMatch.player1 :
                               currentSpectatingMatch.winner === 'player2' ? currentSpectatingMatch.player2 :
                               'Nobody';

            addSpectatorChat('System', `üèÜ ${winnerName} wins the match!`);

            // Spam chat reactions
            setTimeout(() => {
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const reactions = ['GG!', 'AMAZING', 'WOW', 'INSANE MATCH', 'EPIC', 'GGWP', 'CLOSE GAME'];
                        addSpectatorChat(playerNames[Math.floor(Math.random() * playerNames.length)],
                            reactions[Math.floor(Math.random() * reactions.length)]);
                    }, i * 300);
                }
            }, 500);

            // Handle bet result
            if (spectatorBet) {
                if (currentSpectatingMatch.winner === spectatorBet.player) {
                    const winAmount = Math.floor(spectatorBet.amount * spectatorBet.odds);

                    // Apply taxes
                    const taxAmount = Math.floor(winAmount * taxRate);
                    const netWin = winAmount - taxAmount;

                    bankBalance += netWin;
                    updateBankDisplay();
                    addTransaction('win', netWin, `üé∞ Won bet on ${spectatorBet.playerName}`);
                    addTransaction('tax', -taxAmount, `üí∏ Government Tax (${(taxRate * 100)}%)`);

                    addSpectatorChat('System', `üí∞ You won $${netWin.toLocaleString()}! (After ${(taxRate * 100)}% tax)`);
                    playSound('win');
                    spawnEmote('üí∞');
                } else if (currentSpectatingMatch.winner === 'draw') {
                    // Refund on draw
                    bankBalance += spectatorBet.amount;
                    updateBankDisplay();
                    addTransaction('bonus', spectatorBet.amount, `üîÑ Bet refunded (draw)`);
                    addSpectatorChat('System', `üîÑ Match drew - bet refunded!`);
                } else {
                    addSpectatorChat('System', `üí∏ You lost your bet!`);
                    playSound('lose');
                }

                spectatorBet = null;
            }

            // Disable betting buttons
            document.getElementById('currentBetDisplay').textContent = `Match ended! Winner: ${winnerName}`;
        }

        function donateToPlayer(player) {
            if (!currentSpectatingMatch || currentSpectatingMatch.winner) {
                alert('This match is over!');
                return;
            }

            const donationAmount = 50;

            if (bankBalance < donationAmount) {
                alert('You need at least $50 to donate! üí∏');
                return;
            }

            const playerName = player === 'player1' ? currentSpectatingMatch.player1 : currentSpectatingMatch.player2;

            bankBalance -= donationAmount;
            updateBankDisplay();
            addTransaction('bet', -donationAmount, `üíù Donated to ${playerName}`);

            addSpectatorChat('You', `üíù Donated $50 to ${playerName}!`);
            addSpectatorChat('System', `${playerName} received a $50 donation!`);

            // Random thank you response
            if (Math.random() > 0.5) {
                setTimeout(() => {
                    const thanks = ['Thanks!', 'Appreciate it!', 'TYSM!', 'Legend!', 'Much love!'];
                    addSpectatorChat(playerName, thanks[Math.floor(Math.random() * thanks.length)]);
                }, 1000);
            }

            playSound('click');
            spawnEmote('üíù');
        }

        function sendSpectatorMessage() {
            if (!currentSpectatingMatch) return;

            const input = document.getElementById('spectatorChatInput');
            const message = input.value.trim();

            if (!message) return;

            addSpectatorChat('You', message);
            input.value = '';

            // Random chat responses (20% chance)
            if (Math.random() > 0.8) {
                setTimeout(() => {
                    const responses = [
                        'true', 'fr fr', 'real', 'facts', 'no cap', 'based',
                        'W take', 'L take', 'ratio', 'agreed', 'nah'
                    ];
                    addSpectatorChat(playerNames[Math.floor(Math.random() * playerNames.length)],
                        responses[Math.floor(Math.random() * responses.length)]);
                }, 1000 + Math.random() * 2000);
            }
        }

        function addSpectatorChat(sender, message) {
            if (!currentSpectatingMatch) return;

            currentSpectatingMatch.chatMessages.push({ sender, message });

            const chatFeed = document.getElementById('spectatorChatFeed');
            const messageEl = document.createElement('div');
            messageEl.style.marginBottom = '5px';
            messageEl.innerHTML = `<span style="color: #667eea; font-weight: bold;">${sender}:</span> ${message}`;
            chatFeed.appendChild(messageEl);
            chatFeed.scrollTop = chatFeed.scrollHeight;

            // Limit to 50 messages
            if (currentSpectatingMatch.chatMessages.length > 50) {
                currentSpectatingMatch.chatMessages.shift();
                chatFeed.removeChild(chatFeed.firstChild);
            }
        }

        function leaveSpectator() {
            // Stop simulation
            if (matchSimulationInterval) {
                clearInterval(matchSimulationInterval);
                matchSimulationInterval = null;
            }

            currentSpectatingMatch = null;
            spectatorBet = null;

            // Show match list, hide spectator view
            document.getElementById('liveMatchesList').style.display = 'block';
            document.getElementById('spectatorView').style.display = 'none';

            // Regenerate live matches
            generateLiveMatches();
            renderLiveMatches();
        }

        createBoard();
        showMatchmaking();
        updateStats();
        gameStartTime = Date.now();
        updateSpectators();
        updateBankDisplay();
    </script>
</body>
</html>
